<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yeungeek</title>
  <icon>https://www.gravatar.com/avatar/0a7bd4cded6dbbd2a98de3e1269895c0</icon>
  <subtitle>技术沉思录</subtitle>
  <link href="http://yeungeek.github.io/atom.xml" rel="self"/>
  
  <link href="http://yeungeek.github.io/"/>
  <updated>2025-02-18T02:37:18.916Z</updated>
  <id>http://yeungeek.github.io/</id>
  
  <author>
    <name>Yeungeek</name>
    <email>yeungeek@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenGLES 3.0 - Grafika源码分析</title>
    <link href="http://yeungeek.github.io/2023/11/15/OpenGL-Grafika/"/>
    <id>http://yeungeek.github.io/2023/11/15/OpenGL-Grafika/</id>
    <published>2023-11-15T19:34:59.000Z</published>
    <updated>2025-02-18T02:37:18.916Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
    <category term="Video" scheme="http://yeungeek.github.io/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - AudioVideoRecording源码分析</title>
    <link href="http://yeungeek.github.io/2023/11/14/OpenGL-AudioVideoRecording/"/>
    <id>http://yeungeek.github.io/2023/11/14/OpenGL-AudioVideoRecording/</id>
    <published>2023-11-14T19:32:12.000Z</published>
    <updated>2025-02-18T02:37:18.915Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
    <category term="Video" scheme="http://yeungeek.github.io/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - 3D模型加载和渲染</title>
    <link href="http://yeungeek.github.io/2023/11/12/OpenGL-Load3DModel/"/>
    <id>http://yeungeek.github.io/2023/11/12/OpenGL-Load3DModel/</id>
    <published>2023-11-12T11:15:00.000Z</published>
    <updated>2025-02-18T02:37:18.917Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="3D" scheme="http://yeungeek.github.io/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - 3D模型</title>
    <link href="http://yeungeek.github.io/2023/11/11/OpenGL-3DModel/"/>
    <id>http://yeungeek.github.io/2023/11/11/OpenGL-3DModel/</id>
    <published>2023-11-11T11:10:42.000Z</published>
    <updated>2025-02-18T02:37:18.915Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="3D" scheme="http://yeungeek.github.io/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - 相机基础滤镜</title>
    <link href="http://yeungeek.github.io/2023/10/28/OpenGL-CameraFilter/"/>
    <id>http://yeungeek.github.io/2023/10/28/OpenGL-CameraFilter/</id>
    <published>2023-10-28T09:50:50.000Z</published>
    <updated>2025-02-18T02:37:18.915Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - 相机预览</title>
    <link href="http://yeungeek.github.io/2023/10/28/OpenGL-CameraPreview/"/>
    <id>http://yeungeek.github.io/2023/10/28/OpenGL-CameraPreview/</id>
    <published>2023-10-28T09:49:44.000Z</published>
    <updated>2025-02-18T02:37:18.915Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - UBO和TBO</title>
    <link href="http://yeungeek.github.io/2023/10/27/OpenGL-UBO-TBO/"/>
    <id>http://yeungeek.github.io/2023/10/27/OpenGL-UBO-TBO/</id>
    <published>2023-10-27T20:56:00.000Z</published>
    <updated>2025-02-18T02:37:19.015Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - PBO</title>
    <link href="http://yeungeek.github.io/2023/10/23/OpenGL-PBO/"/>
    <id>http://yeungeek.github.io/2023/10/23/OpenGL-PBO/</id>
    <published>2023-10-23T15:09:15.000Z</published>
    <updated>2025-02-18T02:37:18.917Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - FBO离屏渲染</title>
    <link href="http://yeungeek.github.io/2023/10/18/OpenGL-FBO/"/>
    <id>http://yeungeek.github.io/2023/10/18/OpenGL-FBO/</id>
    <published>2023-10-18T14:09:22.000Z</published>
    <updated>2025-02-18T02:37:18.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNTIwMzAzNg==&mid=2654161576&idx=1&sn=cafaa3f9a4cb0af7c7e1c15dfddf5286">NDK OpenGLES3.0 开发（五）：FBO 离屏渲染</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNTIwMzAzNg==&amp;mid=2</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - EGL详解</title>
    <link href="http://yeungeek.github.io/2023/10/17/OpenGL-EGL/"/>
    <id>http://yeungeek.github.io/2023/10/17/OpenGL-EGL/</id>
    <published>2023-10-17T10:03:38.000Z</published>
    <updated>2025-02-18T02:37:18.916Z</updated>
    
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - 坐标系统</title>
    <link href="http://yeungeek.github.io/2023/10/10/OpenGL-Coordinate/"/>
    <id>http://yeungeek.github.io/2023/10/10/OpenGL-Coordinate/</id>
    <published>2023-10-10T11:37:45.000Z</published>
    <updated>2025-02-18T02:37:18.916Z</updated>
    
    <content type="html"><![CDATA[<p>坐标系统</p><p>OpenGL右手坐标系</p><p>MVP</p><p>投影矩阵</p><p>正交投影<br>透视投影</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">坐标系统</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;坐标系统&lt;/p&gt;
&lt;p&gt;OpenGL右手坐标系&lt;/p&gt;
&lt;p&gt;MVP&lt;/p&gt;
&lt;p&gt;投影矩阵&lt;/p&gt;
&lt;p&gt;正交投影&lt;br&gt;透视投影&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - VBO、EBO和VAO</title>
    <link href="http://yeungeek.github.io/2023/10/09/OpenGL-TextureBuffer/"/>
    <id>http://yeungeek.github.io/2023/10/09/OpenGL-TextureBuffer/</id>
    <published>2023-10-09T11:41:11.000Z</published>
    <updated>2025-02-18T02:37:18.917Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几个章节中，我们使用到了很多概念，没有进行描述，本节针对前面使用到的一些概念，再进行一个普及。已经涉及到的几个概念：VBO、EBO(IBO)、VAO。<br>VBO和EBO是在OpenGL1.5中引入的，主要用于优化顶点数据的存储和索引管理。<br>VAO则是在OpenGL3.0中引入的，用于简化顶点缓冲和属性的管理。<br>VBO和EBO的作用是在显存中申请一块内存，用于缓存数据，降低内存拷贝带来的开销。之前用于绘制的顶点数据会先保存在CPU，每次调用绘制函数的时候，再把顶点数据从CPU拷贝到显存中，这也是一个比较大的开销。</p><span id="more"></span><h1 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h1><p>VBO(Vertex Buffer Object)，顶点缓存对象。它将数据(顶点位置、颜色、纹理坐标等)存储到GPU显存中。<br>主要流程:</p><ul><li>创建一个VBO对象</li><li>绑定VBO</li><li>调用glBufferData函数，将数据拷贝到显存中</li><li>链接顶点属性</li></ul><p>示例代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. create vbo</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;mVBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. bind vbo</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, mVBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(mVertices), mVertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. set vertex attribute</span></span><br><span class="line"><span class="comment">//xyz</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(GLfloat), (<span class="type">void</span> *) <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//rgb</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(GLfloat),</span><br><span class="line">                        (<span class="type">void</span> *) (<span class="number">3</span> * <span class="built_in">sizeof</span>(GLfloat)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//st</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(GLfloat),</span><br><span class="line">                        (<span class="type">void</span> *) (<span class="number">6</span> * <span class="built_in">sizeof</span>(GLfloat)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h2><p>使用到的顶点数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GLfloat mVertices[] = &#123;</span><br><span class="line">        <span class="comment">//xyz, rgb, st</span></span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在绘制渲染前，需要指定OpenGL该如何解析顶点数据，使用<code>glVertexAttribPointer</code>函数进行解析。<br><img src="/2023/10/09/OpenGL-TextureBuffer/vertex_attribute_pointer_interleaved_textures.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.rgb</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(GLfloat),</span><br><span class="line">                        (<span class="type">void</span> *) (<span class="number">3</span> * <span class="built_in">sizeof</span>(GLfloat)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><code>glVertexAttribPointer</code>参数：</p><ol><li>配置的顶点属性。顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值</li><li>顶点属性的大小。顶点属性是<code>vec3</code>，值是3</li><li>指定数据的类型。<code>GL_FLOAT</code>(GLSL中vec*都是由浮点数值组成的)</li><li>数据是否被标准化(Normalize)。<code>GL_TRUE</code>，数据都会被映射到0到1之间。这里设置为<code>GL_FALSE</code></li><li>步长(stride)。连续的顶点属性组之间的间隔。下个顶点是在8个<code>float</code>后，步长设置为<code>8*sizeof(float)</code></li><li>起始位置的偏移量(Offset)。颜色的偏移量是在位置数据(3个<code>float</code>)后，所以偏移量是<code>3*sizeof(float)</code></li></ol><h1 id="EBO"><a href="#EBO" class="headerlink" title="EBO"></a>EBO</h1><p>VBO(Vertex Buffer Object)，元素缓冲对象。用于存储顶点索引的缓冲对象，通过索引来引用顶点数据，避免了重复存储相同的顶点数据。EBO 可以与 VBO 结合使用，实现更高效的渲染。<br>主要流程：</p><ul><li>创建一个EBO对象</li><li>绑定EBO</li><li>调用glBufferData函数，将数据拷贝到显存中</li><li>绘制：使用 glDrawElements() 按照索引顺序绘制图形</li></ul><p>示例代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. create ebo</span></span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;mEBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. bind ebo</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, mEBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(mIndices), mIndices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. draw</span></span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_SHORT, (<span class="type">void</span> *) <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h1><p>VAO(Vertex Array Object，顶点数组对象)，元素缓冲对象，用于存储顶点属性配置状态的对象。减少<code>glBindBuffer</code>、<code>glEnableVertexAttribArray</code>、 <code>glVertexAttribPointer</code>的调用，简化了与VBO和EBO相关的状态管理。</p><p>VAO、VBO、EBO之间的关系：<br><img src="/2023/10/09/OpenGL-TextureBuffer/vertex_array_objects_ebo.png"><br>主要流程：</p><ol><li>创建一个VAO对象</li><li>绑定VAO</li><li>配置VBO和EBO</li><li>绘制：当需要渲染时，直接绑定VAO，再进行绘制即可</li></ol><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. create vao</span></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;mVAO);</span><br><span class="line"><span class="comment">//2. bind vao</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(mVAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. record vbo and ebo</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, mVBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(mVertices), mVertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, mEBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(mIndices), mIndices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//xyz</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(GLfloat), (<span class="type">void</span> *) <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//rgb</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(GLfloat),</span><br><span class="line">                        (<span class="type">void</span> *) (<span class="number">3</span> * <span class="built_in">sizeof</span>(GLfloat)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//st</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="built_in">sizeof</span>(GLfloat),</span><br><span class="line">                        (<span class="type">void</span> *) (<span class="number">6</span> * <span class="built_in">sizeof</span>(GLfloat)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. draw</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(mVAO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_SHORT, (<span class="type">void</span> *) <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>通过VAO，你只需设置一次 VBO、EBO和顶点属性，之后可以快速切换不同的VAO进行渲染，避免重复配置，提高了开发效率和渲染性能。<br>在面试中经常被问到的问题，VBO、EBO和VAO中哪些是可共享的资源，正好一起梳理下：</p><ul><li>可以共享的资源：<blockquote><p>纹理<br>shader<br>program着色器程序<br>buffer类对象，如VBO、EBO、RBO等</p></blockquote></li><li>不可以共享的资源：<blockquote><p>FBO帧缓冲区对象（不属于buffer类）<br>VAO顶点数组对象（不属于buffer类）</p></blockquote></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://cloud.tencent.com/developer/article/2357696">关于OpenGL的渲染上下文</a></li><li><a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/">三角形</a></li><li><a href="https://www.khronos.org/opengl/wiki/History_of_OpenGL">OpenGL History</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面几个章节中，我们使用到了很多概念，没有进行描述，本节针对前面使用到的一些概念，再进行一个普及。已经涉及到的几个概念：VBO、EBO(IBO)、VAO。&lt;br&gt;VBO和EBO是在OpenGL1.5中引入的，主要用于优化顶点数据的存储和索引管理。&lt;br&gt;VAO则是在OpenGL3.0中引入的，用于简化顶点缓冲和属性的管理。&lt;br&gt;VBO和EBO的作用是在显存中申请一块内存，用于缓存数据，降低内存拷贝带来的开销。之前用于绘制的顶点数据会先保存在CPU，每次调用绘制函数的时候，再把顶点数据从CPU拷贝到显存中，这也是一个比较大的开销。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
    <category term="Texture" scheme="http://yeungeek.github.io/tags/Texture/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - 纹理映射</title>
    <link href="http://yeungeek.github.io/2023/10/08/OpenGL-TextureMap/"/>
    <id>http://yeungeek.github.io/2023/10/08/OpenGL-TextureMap/</id>
    <published>2023-10-08T15:35:08.000Z</published>
    <updated>2025-02-18T02:37:19.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>纹理是指在计算机图形学中，为了增加物体表面的细节和真实感而使用的一种技术。纹理是一个2D图片，（甚至也有1D和3D的纹理）,可以简单理解为物体表面的图案。<br>在OpenGL ES中，纹理实际上是一个可以被采样的复杂数据集合，是 GPU 的图像数据结构，纹理分为2D纹理、2D纹理数组、3D纹理和立方图纹理。<br>在Android GLES中，主要分为外部GLES纹理(GL_TEXTURE_EXTERNAL_OES)与传统GLES纹理 (GL_TEXTURE_2D)。</p><span id="more"></span><h1 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h1><p>纹理映射(Texture Mapping)，又称纹理贴图，是将纹理空间中的纹理像素映射到屏幕空间中的像素的过程。简单来说，就是把一幅图像贴到三维物体的表面上来增强真实感，可以和光照计算、图像混合等技术结合起来形成许多非常漂亮的效果。在OpenGL中来说，就是将纹理坐标所指定的纹理区域，映射到顶点坐标对应的渲染区域。</p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>OpenGL中常用的坐标系有：顶点坐标、纹理坐标，屏幕坐标等，对坐标的理解，是渲染绘制图形的基础。</p><h3 id="顶点坐标"><a href="#顶点坐标" class="headerlink" title="顶点坐标"></a>顶点坐标</h3><p><img src="/2023/10/08/OpenGL-TextureMap/opengl_coordinate.png"><br>首先明确OpenGL是右手坐标系，上图中的右手坐标系：伸开右手，大拇指指向X轴正方向，食指指向Y轴正方向，其他三个手指指向Z轴正方向。<br>而顶点坐标(Vertex Coordinate)，也叫顶点位置，是顶点在空间中的位置，通常用(x,y,z)表示，其中x、y、z都是浮点数，范围通常是[-1,1]。如图：<br><img src="/2023/10/08/OpenGL-TextureMap/vertex_coordinate.png"></p><h3 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h3><p>纹理坐标(Texture Coordinate)，也叫UV坐标，是为了将纹理映射到三维几何体上，需要定义一个坐标系。纹理坐标通常用(u,v)表示，其中u和v是二维图像的水平和垂直轴坐标，范围通常是[0,1]。<br><img src="/2023/10/08/OpenGL-TextureMap/texture_coordinate.png"><br>它的坐标原点位于左下角，水平向右为S轴，竖直向上为Y轴。</p><h3 id="屏幕坐标"><a href="#屏幕坐标" class="headerlink" title="屏幕坐标"></a>屏幕坐标</h3><p>屏幕坐标系，就是应用在设备屏幕上的坐标系，也是图形最终显示的地方。<br><img src="/2023/10/08/OpenGL-TextureMap/screen_coordinate.png"><br>水平向右为X轴，竖直向下为Y轴。<br>从纹理坐标系和屏幕坐标系看出，图像默认的原点是在左上角，而OpenGL的纹理读取数据是从左下角开始，所以会出现图像上下颠倒的现象。要得到正确的图像，只要对纹理坐标进行上下翻转就可以。</p><h2 id="纹理采样"><a href="#纹理采样" class="headerlink" title="纹理采样"></a>纹理采样</h2><p>在渲染过程中，OpenGL会通过插值算法将纹理坐标与几何体的每个片元(像素)进行对应，然后从纹理中提取颜色信息，这一过程称为纹理采样。<br>常见的环绕方式：</p><table><thead><tr><th align="left">环绕方式</th><th>描述</th></tr></thead><tbody><tr><td align="left">GL_REPEAT</td><td>纹理的默认行为。重复纹理图像。</td></tr><tr><td align="left">GL_MIRRORED_REPEAT</td><td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td align="left">GL_CLAMP_TO_EDGE</td><td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td align="left">GL_CLAMP_TO_BORDER</td><td>超出的坐标为用户指定的边缘颜色。</td></tr></tbody></table><p>当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。<br><img src="/2023/10/08/OpenGL-TextureMap/texture_wrapping.png"></p><h2 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h2><p>渲染一个图像，不能保证绘制的实际大小就是图片的原本大小，都是需要进行缩放。OpenGL中，只指定了顶点数据，中间点都是通过OpenGL内部采用插值器进行计算。这种插值方式，叫做<code>纹理过滤</code>。<br>纹理过滤常用的选项有两个：<code>GL_NEAREST</code>和<code>GL_LINEAR</code>。  </p><ul><li><p>GL_NEAREST：邻近过滤(Nearest Neighbor Filtering)是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。<br>返回的颜色是距离纹理坐标最近的颜色。<br><img src="/2023/10/08/OpenGL-TextureMap/filter_nearest.png"></p></li><li><p>GL_LINEAR：线性过滤(Linear Filtering)，它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。<br>返回的颜色是临近像素的混合色。<br><img src="/2023/10/08/OpenGL-TextureMap/filter_linear.png"><br>两种纹理过滤的效果：<br><img src="/2023/10/08/OpenGL-TextureMap/filter_comparison.png"><br><code>GL_NEAREST</code>会产生颗粒状的图像，能看到组成纹理的像素而<code>GL_LINEAR</code>则更平滑，产生更加真实的效果。</p></li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>加载纹理：将外部纹理加载到内存</li><li>生成纹理对象：使用<code>glGenTextures()</code>在OpenGL中生成纹理对象，并绑定到合适的纹理目标</li><li>设置纹理参数：通过<code>glTexParameteri()</code>设置纹理参数，如环绕方式、过滤方式等</li><li>上传纹理数据：使用<code>glTexImage2D()</code>将纹理数据上传到OpenGL</li><li>应用纹理：在渲染时，通过着色器和纹理坐标将纹理映射到三维物体的表面</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><ul><li>生成纹理，并加载图像数据到纹理：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. gen texture</span></span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;mTextureId);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, mTextureId);</span><br><span class="line"><span class="comment">//2. set filter S = Vertical, T = Horizontal</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="comment">//3. set texture sample</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. upload texture data</span></span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, </span><br><span class="line">        GL_RGBA,GL_UNSIGNED_BYTE,data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5. unbind texture</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, GL_NONE);</span><br></pre></td></tr></table></figure><ul><li>纹理采样的片段着色器：</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他draw的代码和以前类似，这里就不累述了。<br>效果如图：<br><img src="../OpenGL-TextureMap/texture_result.png" width="50%" height="50%"><br>看着效果图是不是有点拉伸，这个后续通过投影矩阵来解决。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/">纹理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNTIwMzAzNg==&mid=2654161543&idx=1&sn=bb69fdacc5d9e85e4dea8e87e29abd66&chksm=8cf399b4bb8410a249167518e518798a7bc29b0e9c5d1343876928ff0cf5cd794f0878c73789&scene=178&cur_album_id=1340922292116996097#rd">NDK OpenGLES 3.0 开发（二）：纹理映射</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjU1MDk3Ng==&mid=2451526345&idx=1&sn=fa138cced3c7aba01011f8455f1d9922&chksm=886ffb66bf18727008c5032fba31d22331daa727b13613e7174c2c3910f1e3082170e428813f&scene=178&cur_album_id=1337181710408302593#rd">OpenGL 学习系列 — 纹理</a></li><li><a href="https://blog.csdn.net/u010281924/article/details/105305991">OpenGL ES 3. 顶点坐标 纹理坐标</a></li><li><a href="https://www.codersrc.com/archives/20344.html">OpenGL ES 笛卡尔坐标系之纹理坐标和顶点坐标</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;纹理&quot;&gt;&lt;a href=&quot;#纹理&quot; class=&quot;headerlink&quot; title=&quot;纹理&quot;&gt;&lt;/a&gt;纹理&lt;/h1&gt;&lt;p&gt;纹理是指在计算机图形学中，为了增加物体表面的细节和真实感而使用的一种技术。纹理是一个2D图片，（甚至也有1D和3D的纹理）,可以简单理解为物体表面的图案。&lt;br&gt;在OpenGL ES中，纹理实际上是一个可以被采样的复杂数据集合，是 GPU 的图像数据结构，纹理分为2D纹理、2D纹理数组、3D纹理和立方图纹理。&lt;br&gt;在Android GLES中，主要分为外部GLES纹理(GL_TEXTURE_EXTERNAL_OES)与传统GLES纹理 (GL_TEXTURE_2D)。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
    <category term="Texture" scheme="http://yeungeek.github.io/tags/Texture/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - 着色器语言GLSL</title>
    <link href="http://yeungeek.github.io/2023/09/27/OpenGL-GLSL/"/>
    <id>http://yeungeek.github.io/2023/09/27/OpenGL-GLSL/</id>
    <published>2023-09-27T20:06:30.000Z</published>
    <updated>2025-02-18T02:37:18.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在OpenGL开发过程中，我们经常会用到着色器语言(GLSL)，它主要用于编写顶点着色器和片段着色器，接下来会详细讲解着色器语言GL Shader Language(GLSL)的一些基本概念。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>GLSL最初随着OpenGL2.0版本一同发布，随着OpenGL版本的不断升级。OpenGL版本和GLSL版本对应关系：</p><table><thead><tr><th align="center">OpenGL版本</th><th align="center">GLSL版本</th><th align="center">发布时间</th></tr></thead><tbody><tr><td align="center">2.0</td><td align="center">110</td><td align="center">2004年9月7日</td></tr><tr><td align="center">2.1</td><td align="center">120</td><td align="center">2006年7月2日</td></tr><tr><td align="center">3.0</td><td align="center">130</td><td align="center">2008年8月11日</td></tr><tr><td align="center">3.1</td><td align="center">140</td><td align="center">2009年3月24日</td></tr><tr><td align="center">3.2</td><td align="center">150</td><td align="center">2009年8月3日</td></tr><tr><td align="center">3.3</td><td align="center">330</td><td align="center">2010年3月11日</td></tr><tr><td align="center">4.0</td><td align="center">400</td><td align="center">2010年3月11日</td></tr><tr><td align="center">4.1</td><td align="center">410</td><td align="center">2010年7月26日</td></tr><tr><td align="center">4.2</td><td align="center">420</td><td align="center">2011年8月8日</td></tr><tr><td align="center">4.3</td><td align="center">430</td><td align="center">2012年8月6日</td></tr><tr><td align="center">4.4</td><td align="center">440</td><td align="center">2013年7月23日</td></tr><tr><td align="center">4.5</td><td align="center">450</td><td align="center">2014年7月</td></tr><tr><td align="center">4.6</td><td align="center">460</td><td align="center">2017年7月</td></tr></tbody></table><p>同样的，对于嵌入式设备，对于OpenGLES，也有对应的GLSL ES版本，对应关系：</p><table><thead><tr><th align="center">OpenGLES版本</th><th align="center">GLSL ES版本</th></tr></thead><tbody><tr><td align="center">2.0</td><td align="center">110</td></tr><tr><td align="center">3.0</td><td align="center">130</td></tr><tr><td align="center">3.1</td><td align="center">140</td></tr><tr><td align="center">3.2</td><td align="center">150</td></tr></tbody></table><p>本文主要讲解的是OpenGL ES3.0版本的GLSL。</p><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><p>OpenGL ES 着色器语言支持的变量类型：</p><table><thead><tr><th align="center">分类</th><th align="center">变量类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">标量</td><td align="center">float,int,bool,uint</td><td align="center">标量也被称为 “无向量”，</br>其值只有大小，并不具有方向</td></tr><tr><td align="center">浮点向量</td><td align="center">float, vec2, vec3, vec4</td><td align="center">有 1、2、3、4 个分量，</br>基于浮点的向量类型</td></tr><tr><td align="center">正数向量</td><td align="center">int, ivec2, ivec3, ivec4</td><td align="center">有 1、2、3、4 个分量，</br>基于整数的向量类型</td></tr><tr><td align="center">布尔向量</td><td align="center">bool, bvec2, bvec3, bvec4</td><td align="center">有 1、2、3、4 个分量，</br>基于布尔的向量类型</td></tr><tr><td align="center">无符号整数向量</td><td align="center">uint, uvec2, uvec3, uvec4</td><td align="center">有 1、2、3、4 个分量，</br>基于无符号整数的向量类型</td></tr><tr><td align="center">矩阵</td><td align="center">mat2x2,mat2x3,max2x4…</td><td align="center">矩阵是按照列的顺序组织的，</br> 第一个数字表示列数</br>第二个表示行数</td></tr><tr><td align="center">纹理句柄</td><td align="center">sampler2D, samplerCube</td><td align="center">表示2D，立方体纹理的句柄</td></tr><tr><td align="center">空类型</td><td align="center">void</td><td align="center">用于无返回值的函数或空的</br>参数列表</td></tr></tbody></table><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>类似C语言中的结构体，使用<code>struct</code>关键字声明结构体。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct foo&#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line">    <span class="type">float</span> start;</span><br><span class="line">&#125; fooVar;</span><br><span class="line"></span><br><span class="line">fooVar = foo(<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>),<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>可以声明各种类型的数组。<br>声明数组的方式：</p><ul><li><p>声明数组的同时，指定大小：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> position[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></li><li><p>声明数组并初始化：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a[] = <span class="type">float</span>[](<span class="number">1.0</span>,<span class="number">2.0</span>f);</span><br><span class="line"><span class="type">float</span> b[] = <span class="type">float</span>[<span class="number">2</span>](<span class="number">1.0</span>,<span class="number">2.0</span>f);</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的声明和C语言类似，从<code>main</code>主函数开始执行。<br>注意：函数不能够递归调用，且必须声明返回值类型(无返回值时声明为void)</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec3</span> n;</span><br><span class="line">    <span class="type">vec3</span> l;</span><br><span class="line">    <span class="type">vec4</span> b;</span><br><span class="line">    ...</span><br><span class="line">    fragColor = diffuse(n,l,b);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> diffuse(<span class="type">vec3</span> normal, <span class="type">vec3</span> light, <span class="type">vec4</span> baseColor) &#123;</span><br><span class="line">    <span class="keyword">return</span> baseColor * <span class="built_in">dot</span>(normal, light);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>OpenGL ES 着色语言有许多内置函数，处理各种计算任务。<br>这些内置函数，可分为4种变体：</p><table><thead><tr><th align="center">变体类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">genType</td><td align="center">float,vec2,vec3,vec4</td></tr><tr><td align="center">genIType</td><td align="center">int,ivec2,ivec3,ivec4</td></tr><tr><td align="center">genBType</td><td align="center">uint,uvec2,uvec3,uvec4</td></tr><tr><td align="center">genUType</td><td align="center">uint,uvec2,uvec3,uvec4</td></tr></tbody></table><p>和上文中提到的4种变量对应(float,int,bool,uint)。<br>内置函数都是使用了非常高效的方式来实现，必须熟悉一些常见的内置函数。 </p><h1 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h1><h2 id="存储限定符"><a href="#存储限定符" class="headerlink" title="存储限定符"></a>存储限定符</h2><p>在GLSL140版本之前，模型的一次渲染过程，顶点着色器中每次运行都会改变的数据称为attribute，每次运行保持不变的数据称为uniform，着色器之间顺序传递的数据称为varying，这些就是所谓的存储限定符。<br><img src="/2023/09/27/OpenGL-GLSL/s_1.png"><br>为了强化渲染管线的输入输出概念，GLSL140版本后，存储限定符attribute和varying不再被推荐使用，取而代之的是in和out。<br><img src="/2023/09/27/OpenGL-GLSL/s_2.png"></p><h3 id="in限定符"><a href="#in限定符" class="headerlink" title="in限定符"></a>in限定符</h3><p>in限定符修饰的全局变量，叫输入变量。<br>顶点着色器的输入变量只能使用in限定符来修饰。片段着色器可以使用in或者centroid in 限定符来修饰全局变量。<br>in限定修饰符和OpenGL ES2.0中的<code>attribute</code>限定符类似。</p><h3 id="out限定符"><a href="#out限定符" class="headerlink" title="out限定符"></a>out限定符</h3><p>out限定符修饰的全局变量，叫输出变量。<br>顶点着色器的输出变量可以使用in或者centroid out限定符来修饰全局变量，用于向渲染管线后继阶段传递当前顶点的数据。<br>片段着色器的输出变量只能使用in限定符来修饰，表示由片段着色器写入计算完成片段颜色值的变量。 </p><h3 id="uniform限定符"><a href="#uniform限定符" class="headerlink" title="uniform限定符"></a>uniform限定符</h3><p>uniform限定符修饰的全局变量，叫统一变量。统一变量的命名空间在顶点着色器和片段着色器中都是共享的。 </p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>const限定符，可将变量声明为常量，常量只可读，不可修改。常量必须在声明时初始化。例如：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> PI = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure><h3 id="插值限定符"><a href="#插值限定符" class="headerlink" title="插值限定符"></a>插值限定符</h3><p>插值限定符，其主要用于控制顶点着色器传递到片段着色器数据的插值方式。 </p><table><thead><tr><th align="center">插值限定符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">smooth</td><td align="center">默认值，平滑着色，顶点着色器的输出变量在图元中线性插值</td></tr><tr><td align="center">flat</td><td align="center">平面着色，将一个顶点视为驱动顶点（取决于图元类型），</br>该顶点的值用于图元中所有片段</td></tr><tr><td align="center">centroid</td><td align="center">质心采样，使用多重采样渲染时，</br>该限定符可用于强制插值发生在被渲染图元内部，否则图元边缘可能出现伪像</td></tr></tbody></table><h3 id="layout限定符"><a href="#layout限定符" class="headerlink" title="layout限定符"></a>layout限定符</h3><p>layout限定符是OpenGL ES3.3中新增的特性，主要用于设置变量的存储索引值。<br>声明的方式：</p><ul><li>作为接口块定义的一部分或者接口块的成员&#x2F;仅仅修饰uniform，用于建立其他一致变量声明的参照</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">layout</span> 限定符&gt; <span class="keyword">uniform</span></span><br></pre></td></tr></table></figure><ul><li>用于修饰被接口限定符修饰的单独变量</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">layout</span> 限定符&gt; &lt;接口限定符&gt; &lt;变量声明&gt;</span><br></pre></td></tr></table></figure><p>使用layout为in变量指定存储索引值：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> vPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec4</span> vTexCoord;</span><br></pre></td></tr></table></figure><p>如果变量是一个数组，则数组的每一个元素都会占据一个location的编号位置，例子中长度为3的数组，会占用5,6,7三个索引位置：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">5</span>) <span class="keyword">uniform</span> <span class="type">mat4</span> mMatrix[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>对于out变量，layout索引独立于in变量：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br></pre></td></tr></table></figure><h3 id="统一变量块"><a href="#统一变量块" class="headerlink" title="统一变量块"></a>统一变量块</h3><p>统一变量块是OpenGL ES3.3中新增的特性，使用于<code>统一变量缓冲区对象</code>，通过缓冲对象送入渲染管线，以统一变量块的形式批量传送数据比单个传送效率高。基本语法：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;<span class="keyword">layout</span> 限定符&gt;] unifrom 一致块名称 &#123;&lt;成员变量列表&gt;&#125; [&lt;实例名&gt;]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version es 300</span></span><br><span class="line"><span class="keyword">uniform</span> Transform&#123;</span><br><span class="line"><span class="type">float</span> radius;</span><br><span class="line"><span class="type">mat4</span> modelViewMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat3</span> normalMatrix;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> a_position;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = modelViewMatrix * a_position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="精度限定符"><a href="#精度限定符" class="headerlink" title="精度限定符"></a>精度限定符</h3><p>较低的精度效率更高，较高的精度效果更高。<br>精度限定符种类：</p><ul><li>lowp : 低精度</li><li>mediump : 中精度</li><li>highp : 高精度</li></ul><blockquote><p><font color='red'> <strong>注意:</strong></font> </p><ol><li>顶点着色器中，如果没有指定默认精度，则int和float默认精度都是highp</li><li>在片段着色器中，浮点值没有默认精度，必须由开发者声明</li></ol></blockquote><h1 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h1><h2 id="顶点着色器中的内置变量"><a href="#顶点着色器中的内置变量" class="headerlink" title="顶点着色器中的内置变量"></a>顶点着色器中的内置变量</h2><h3 id="内置输入变量"><a href="#内置输入变量" class="headerlink" title="内置输入变量"></a>内置输入变量</h3><ul><li>gl_VertexID：顶点整数索引</li><li>gl_InstanceID：实例 ID</li></ul><h3 id="内置输出变量"><a href="#内置输出变量" class="headerlink" title="内置输出变量"></a>内置输出变量</h3><ul><li>gl_Position：顶点位置</li><li>gl_PointSize：点大小</li></ul><h2 id="片段着色器中的内置变量"><a href="#片段着色器中的内置变量" class="headerlink" title="片段着色器中的内置变量"></a>片段着色器中的内置变量</h2><h3 id="内置输入变量-1"><a href="#内置输入变量-1" class="headerlink" title="内置输入变量"></a>内置输入变量</h3><ul><li>gl_FragCoord：片段位置</li><li>gl_FragColor：片段颜色</li><li>gl_FragData：片段颜色缓冲区</li></ul><h3 id="内置输出变量-1"><a href="#内置输出变量-1" class="headerlink" title="内置输出变量"></a>内置输出变量</h3><ul><li>gl_FragDepth：片段深度值</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language">OpenGL Shading Language</a></li><li><a href="https://bbs.huaweicloud.com/blogs/313360">GLSL的存储限定符和布局限定符</a></li><li><a href="https://github.com/mattdesl/lwjgl-basics/wiki/GLSL-Versions">GLSL-Versions</a></li><li><a href="https://segmentfault.com/a/1190000037495091">Android OpenGL ES - GLSL基础篇</a></li><li><a href="https://segmentfault.com/a/1190000037563032">Android OpenGL ES - GLSL高级篇</a></li><li><a href="https://blog.csdn.net/afei__/article/details/88922112">OpenGL ES 3.0 shader 着色语言基础语法</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在OpenGL开发过程中，我们经常会用到着色器语言(GLSL)，它主要用于编写顶点着色器和片段着色器，接下来会详细讲解着色器语言GL Sha</summary>
      
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
    <category term="GLSL" scheme="http://yeungeek.github.io/tags/GLSL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES 3.0 - 简介和基础绘制流程</title>
    <link href="http://yeungeek.github.io/2023/08/02/OpenGL-Intro/"/>
    <id>http://yeungeek.github.io/2023/08/02/OpenGL-Intro/</id>
    <published>2023-08-02T11:15:53.000Z</published>
    <updated>2025-02-18T02:37:18.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><p><img src="https://s1.ax1x.com/2023/08/13/pPK8x4P.jpg" alt="pPK8x4P.jpg"><br><a href="https://www.opengl.org/">OpenGL(Open Graphics Library,开放图形库)</a>，是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口规范。<br>它本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范（Specification）。它的实现由显示设备厂商提供，并且非常依赖该厂商提供的硬件。<br>当你使用Apple系统的时候，OpenGL库是由Apple维护的。在Windows上，OpenGL库可能是Direct3D接口的一个封装(Wrapper)。表面上调用OpenGL接口，实际上是间接调用了Direct3D接口。</p><span id="more"></span><p>像现在非常火爆的GPU生产商Nvidia，会提供满足OpenGL规范的实现，它们负责将OpenGL定义的API命令翻译为GPU指令。<br>OpenGL应用场景广泛，通常用于CAD、科学可视化、游戏开发等，像游戏开发引擎Unity,Unreal底层渲染引擎都是基于OpenGL，当然也支持Vulkan。</p><h2 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h2><p><img src="https://s1.ax1x.com/2023/08/13/pPKULDS.png"><br><a href="https://www.khronos.org/opengles">OpenGL ES(OpenGL for Embedded Systems)</a>，是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。本系列文章介绍OpenGL版本基于OpenGL ES3.0， 是OpenGLES 2.0的扩展版本，向下兼容OpenGLES 2.0 ，但不兼容OpenGLES 1.0。</p><h3 id="3-0主要新特性"><a href="#3-0主要新特性" class="headerlink" title="3.0主要新特性"></a>3.0主要新特性</h3><h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><ul><li>sRGB 纹理和帧缓冲区 - 允许应用程序执行伽玛校正渲染</li><li>2D纹理数组 - 存储2D纹理数组的纹理目标</li><li>3D纹理 - OpenGL ES 3.0中作为强制功能</li><li>深度纹理和阴影比较 - 允许将深度缓冲区存储在纹理中</li><li>无缝立方体贴图 - 在OpenGL ES 2.0中，使用立方体贴图进行渲染可能会在立方体贴图面之间的边界处产生伪影。在OpenGL ES 3.0中，可以对立方体贴图进行采样，以便过滤使用来自相邻面的数据并消除接缝伪影</li><li>浮点纹理 - OpenGL ES 3.0极大地扩展了支持的纹理格式</li><li>ETC2&#x2F;EAC 纹理压缩</li><li>整数纹理 - OpenGL ES 3.0引入了渲染和提取存储为非标准化有符号或无符号8位、16位和32位整数纹理的纹理的功能</li><li>其他纹理格式</li><li>纹理混合 - 引入了新的纹理对象状态，以允许独立控制纹理数据的每个通道（R、G、B 和 A）在着色器中映射到的位置</li><li>不可变纹理 — 为应用程序提供一种机制，在加载数据之前指定纹理的格式和大小</li><li>增加了最小尺寸 - OpenGL ES 3.0 最小2D纹理尺寸为2048</li></ul><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><ul><li>程序二进制文件 - 在 OpenGL ES 3.0中，整个链接程序二进制文件（包含顶点和片段着色器）可以以离线二进制格式存储，运行时无需链接步骤</li><li>强制在线编译器</li><li>非方阵 - 支持方阵以外的新矩阵类型，并且将关联的统一调用添加到API中以支持加载它们</li><li>完整整数支持</li><li>质心采样</li><li>平面&#x2F;平滑插值程序</li><li>统一变量块 - 统一变量值可以组合为统一变量块。统一变量块可以更高效地加载，也可在多个着色器程序间共享</li><li>布局限定符</li><li>实例和顶点ID</li><li>片段深度 - 片段着色器可以显式控制当前片段的深度值，而不是依赖于其深度值的插值</li><li>新的内置函数</li><li>放宽限制 - OpenGL ES 3.0放宽了对着色器的限制。着色器不再受指令长度限制，完全支持变量循环和分支，并支持数组索引</li></ul><h4 id="几何形状"><a href="#几何形状" class="headerlink" title="几何形状"></a>几何形状</h4><ul><li>变换反馈 - 允许在缓冲区对象中捕获顶点着色器的输出</li><li>布尔遮挡查询</li><li>实例化渲染 - 高效渲染包含相似几何图形但属性（例如变换矩阵、颜色或大小）不同的对象</li><li>图元重新启动</li><li>新的顶点格式 - 新的顶点格式，包括10-10-10-2有符号和无符号标准化顶点属性</li></ul><h4 id="缓冲区对象"><a href="#缓冲区对象" class="headerlink" title="缓冲区对象"></a>缓冲区对象</h4><ul><li>统一缓冲区对象 - 提供存储&#x2F;绑定大块统一的有效方法</li><li>顶点数组对象 - 提供一种有效的方法来绑定和切换顶点数组状态</li><li>采样器对象 - 将采样器状态（纹理环绕模式和过滤）与纹理对象分开</li><li>同步对象 - 为应用程序提供一种机制来检查一组 OpenGL ES 操作是否已在GPU上完成执行</li><li>像素缓冲区对象 - 使应用程序能够执行数据到像素操作和纹理传输操作的异步传输</li><li>缓冲区子范围映射 - 允许应用程序映射缓冲区的子区域以供CPU访问</li><li>缓冲区对象间拷贝</li></ul><h4 id="帧缓冲区"><a href="#帧缓冲区" class="headerlink" title="帧缓冲区"></a>帧缓冲区</h4><ul><li>多个渲染目标(MRT) — 允许应用程序一次同时渲染到多个颜色缓冲区</li><li>多重采样渲染缓冲区 - 使应用程序能够通过多重采样抗锯齿渲染到离屏帧缓冲区</li><li>帧缓冲区失效提示 </li><li>新的混合方程 - OpenGL ES 3.0支持最小&#x2F;最大函数作为混合方程</li></ul><h1 id="OpenGL绘制流程"><a href="#OpenGL绘制流程" class="headerlink" title="OpenGL绘制流程"></a>OpenGL绘制流程</h1><p>本系列是基于Android的OpenGL，绘制使用了GLSurfaceView，具体的渲染实现使用JNI实现。<br>使用GLSurfaceView，需要设置一个Renderer，整个渲染流程是由Renderer实现，主要实现三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">open <span class="keyword">class</span> <span class="title class_">ShaderRenderer</span>(sample: Sample) : Renderer &#123;</span><br><span class="line">    <span class="keyword">private</span> val nativeRender: ShaderNativeRender</span><br><span class="line">    <span class="keyword">private</span> val mSample:Sample</span><br><span class="line">    init &#123;</span><br><span class="line">        nativeRender = ShaderNativeRender()</span><br><span class="line">        mSample = sample</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onSurfaceCreated</span><span class="params">(gl: GL10?, config: EGLConfig?)</span> &#123;</span><br><span class="line">        <span class="comment">// GLSurfaceView视图创建时候调用</span></span><br><span class="line">        nativeRender.native_OnSurfaceCreated()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onSurfaceChanged</span><span class="params">(gl: GL10?, width: Int, height: Int)</span> &#123;</span><br><span class="line">        <span class="comment">// GLSurfaceView视图改变时调用</span></span><br><span class="line">        nativeRender.native_OnSurfaceChanged(width,height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onDrawFrame</span><span class="params">(gl: GL10?)</span> &#123;</span><br><span class="line">        <span class="comment">// 每帧调用</span></span><br><span class="line">        nativeRender.native_OnDrawFrame()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        nativeRender.native_Init(mSample.id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        nativeRender.native_UnInit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Native，JNI的声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShaderNativeRender</span>() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        init &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;shader-render&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_Init</span><span class="params">(id:Int)</span></span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_UnInit</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_OnSurfaceCreated</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_OnSurfaceChanged</span><span class="params">(width: Int, height: Int)</span></span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_OnDrawFrame</span><span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNI层的部分实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderContext::OnSurfaceCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;###### ShaderContext OnSurfaceCreated&quot;</span>);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderContext::OnSurfaceChanged</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;###### ShaderContext OnSurfaceChanged,w=%d,h=%d&quot;</span>, width, height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderContext::OnDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>学习OpenGL，渲染流程是非常重要的，下图是图形渲染管线每个阶段的抽象展示<br><img src="/2023/08/02/OpenGL-Intro/pipeline.png"><br>开始绘制之前，需要提供给OpenGL一些顶点数据，作为顶点输入，接下来就是图形渲染管线的第一部分 - 顶点着色器。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器(Vertex Shader)是几个可编程着色器中的一个，主要作用是<code>确定绘制图形的形状</code>。<br>定义一个着色器程序，需要通过GLSL(OpenGL Shading Language)语言来编写，下面这段是非常典型的顶点着色器源码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>in</code>关键字定义输入顶点属性，把位置数据赋值给预定义的<code>gl_Position</code>变量，设置的值会成为该顶点着色器的输出。</p><h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>输入的数据，就是上一个阶段顶点着色器输出的所有顶点，并将输入的数据装配成指定图元的形状。图元的类型：点、线、三角形，其他复杂的图形都是由这三种基本的图形组成。</p><h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>几何着色器把图元形式的一系列顶点的集合作为输入，通过对输入的顶点进行处理，会决定输出的图元类型和个数。</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>这个阶段会把图元映射为最终屏幕上的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>主要目的是计算一个像素的最终颜色，这是另外一个可编程的着色器。</p><h3 id="测试与混合"><a href="#测试与混合" class="headerlink" title="测试与混合"></a>测试与混合</h3><p>这个阶段检测片段的深度，判断像素和其他物体的前后关系，确定是否丢弃，检查Alpha值并对物体进行混合。</p><p>可以看到渲染管线是非常复杂的，包含了很多可配置的部分。其中顶点着色器和片段着色器是可编程，也是我们需要关注的。几何着色器是可选，一般使用默认即可。</p><h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><h3 id="定义着色器"><a href="#定义着色器" class="headerlink" title="定义着色器"></a>定义着色器</h3><p>顶点着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> vPosition;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = vPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编译OpenGL程序"><a href="#编译OpenGL程序" class="headerlink" title="编译OpenGL程序"></a>编译OpenGL程序</h3><p>根据顶点和片段着色器类型，创建和编译着色器程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据不同的类型创建着色器ID</span></span><br><span class="line">GLuint shader = <span class="built_in">glCreateShader</span>(shaderType);</span><br><span class="line"><span class="keyword">if</span> (shader) &#123;</span><br><span class="line">    <span class="comment">//将着色器ID和内容连接</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(shader, <span class="number">1</span>, &amp;source, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//编译着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(shader);</span><br><span class="line"></span><br><span class="line">    GLint compiled = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//检查是否编译成功</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;compiled);</span><br><span class="line">    <span class="keyword">if</span> (!compiled) &#123;</span><br><span class="line">        GLint infoLen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(shader, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class="line">        <span class="keyword">if</span> (infoLen) &#123;</span><br><span class="line">            <span class="type">char</span> *buf = (<span class="type">char</span> *) <span class="built_in">malloc</span>((<span class="type">size_t</span>) infoLen);</span><br><span class="line">            <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">                <span class="comment">//获取错误消息</span></span><br><span class="line">                <span class="built_in">glGetShaderInfoLog</span>(shader, infoLen, <span class="literal">NULL</span>, buf);</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;###### LoadShader compiled error %d, \n%s&quot;</span>, shaderType, buf);</span><br><span class="line">                <span class="built_in">free</span>(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">glDeleteShader</span>(shader);</span><br><span class="line">            shader = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GLuint glCreateShader(GLenum shaderType)：根据不同的类型创建着色器ID</li><li>void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)：<br>将着色器ID和内容连接</li><li>void glCompileShader(GLuint shader)：编译着色器</li><li>void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)：检查编译是否成功</li><li>void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)：<br>获取错误消息</li></ul><h3 id="创建OpenGL程序和链接着色器"><a href="#创建OpenGL程序和链接着色器" class="headerlink" title="创建OpenGL程序和链接着色器"></a>创建OpenGL程序和链接着色器</h3><p>接下来就是创建OpenGL程序，并链接着色器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="built_in">LOGD</span>(<span class="string">&quot;###### Create Program Result: %d&quot;</span>, program);</span><br><span class="line"><span class="keyword">if</span> (program) &#123;</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vertexShaderId);</span><br><span class="line">    <span class="built_in">CheckGLError</span>(<span class="string">&quot;glAttachShader&quot;</span>);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fragmentShaderId);</span><br><span class="line">    <span class="built_in">CheckGLError</span>(<span class="string">&quot;glAttachShader&quot;</span>);</span><br><span class="line">    <span class="comment">//链接OpenGL程序</span></span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    GLint linkResult = GL_FALSE;</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(program, GL_LINK_STATUS, &amp;linkResult);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GLuint glCreateProgram(void)：创建程序</li><li>void glAttachShader(GLuint program, GLuint shader)：将指定的shader附着到指定的program对象上</li><li>void glLinkProgram(GLuint program)：链接OpenGL程序</li></ul><h3 id="使用OpenGL程序"><a href="#使用OpenGL程序" class="headerlink" title="使用OpenGL程序"></a>使用OpenGL程序</h3><p>接着调用<code>glUseProgram</code>，创建的程序对象作为它的参数，之后每个着色器调用和渲染调用都会使用这个程序对象。</p><ul><li>void glUseProgram(GLuint program)：使用OpenGL程序</li></ul><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>最后一步就是绘制流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (mProgram == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//load vertex data</span></span><br><span class="line"><span class="comment">//设置顶点属性数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, stride, mVertices);</span><br><span class="line"><span class="comment">//启用顶点属性</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDisableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer)：<br>定义通用顶点属性数据<ul><li>index：配置的顶点属性，opengl3.0在顶点着色器定义的<code>layout(location=0)</code>表示位置为0</li><li>size：顶点属性的大小，顶点属性vec3，这个值就是3</li><li>type：数据的类型，<code>GL_FLOAT</code>表示是浮点数值</li><li>normalized：是否归一化</li><li>stride：步长，连续的顶点属性组之间的间隔。设置为0，则是让OpenGL决定具体的步长</li><li>pointer：表示位置数据在缓冲中起始位置的偏移量(Offset)</li></ul></li><li>void glEnableVertexAttribArray(GLuint index)：启用通用顶点属性数组，允许顶点着色器读取GPU数据</li><li>void glDrawArrays(GLenum mode, GLint first, GLsizei count)：绘制图形<ul><li>mode：绘制类型，包含<code>GL_POINTS</code>、<code>GL_LENS</code>、<code>GL_TRIANGLE</code>等</li></ul></li></ul><p><img src="/2023/08/02/OpenGL-Intro/draw_mode.jpeg"><br>这个就是OpenGL的整体绘制流程，遵循了GPU的渲染管线流程。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.opengl.org/">OpenGL</a></li><li><a href="https://www.khronos.org/opengles/">OpenGL ES</a></li><li><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/">OpenGL Refpages</a></li><li><a href="https://learnopengl-cn.github.io/">Learn OpenGL</a></li><li><a href="https://juejin.cn/post/7119135465302654984">一看就懂的OpenGL ES教程——图形渲染管线的那些事</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;OpenGL&quot;&gt;&lt;a href=&quot;#OpenGL&quot; class=&quot;headerlink&quot; title=&quot;OpenGL&quot;&gt;&lt;/a&gt;OpenGL&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/08/13/pPK8x4P.jpg&quot; alt=&quot;pPK8x4P.jpg&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://www.opengl.org/&quot;&gt;OpenGL(Open Graphics Library,开放图形库)&lt;/a&gt;，是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口规范。&lt;br&gt;它本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范（Specification）。它的实现由显示设备厂商提供，并且非常依赖该厂商提供的硬件。&lt;br&gt;当你使用Apple系统的时候，OpenGL库是由Apple维护的。在Windows上，OpenGL库可能是Direct3D接口的一个封装(Wrapper)。表面上调用OpenGL接口，实际上是间接调用了Direct3D接口。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL教程</title>
    <link href="http://yeungeek.github.io/2023/08/02/OpenGL-Tutorials/"/>
    <id>http://yeungeek.github.io/2023/08/02/OpenGL-Tutorials/</id>
    <published>2023-08-02T10:25:45.000Z</published>
    <updated>2025-02-18T02:37:19.015Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL的概念，相信大家都听说过，应用场景非常广泛，音视频、图形渲染、游戏等等。学习OpenGL是有一定的门槛，期间也看过很多其他OpenGL教程，有些写的是非常不错的，例如<a href="https://learnopengl.com/">LearnOpenGL</a>，能够系统性的学习OpenGL概念和应用。本系列教程，主要会从Android OpenGL ES入手，系统性的介绍图形学渲染技术，结合音视频进行相关应用，并分析两个教科书级别的项目，更加巩固OpenGL技术。</p><span id="more"></span><p><strong>本系列教程：</strong></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol><li><a href="/2023/08/02/OpenGL-Intro/">OpenGLES 3.0 - 简介和基础绘制流程</a></li><li><a href="/2023/09/27/OpenGL-GLSL/">OpenGLES 3.0 - 着色器语言GLSL</a></li><li><a href="/2023/10/08/OpenGL-TextureMap/">OpenGLES 3.0 - 纹理映射</a></li><li><a href="/2023/10/09/OpenGL-TextureBuffer/">OpenGLES 3.0 - VBO、EBO和VAO</a></li><li><a href="/2023/10/10/OpenGL-Coordinate/">OpenGLES 3.0 - 坐标系统</a></li><li><a href="/2023/10/17/OpenGL-EGL/">OpenGLES 3.0 - EGL详解</a></li><li><a href="/2023/10/18/OpenGL-FBO/">OpenGLES 3.0 - FBO离屏渲染</a></li><li><a href="/2023/10/23/OpenGL-PBO/">OpenGLES 3.0 - PBO</a></li><li><a href="/2023/10/27/OpenGL-UBO-TBO/">OpenGLES 3.0 - UBO和TBO</a></li><li><a href="/2023/10/28/OpenGL-CameraPreview/">OpenGLES 3.0 - 相机预览</a></li><li><a href="/2023/10/28/OpenGL-CameraFilter/">OpenGLES 3.0 - 相机基础滤镜</a></li><li><a href="/2023/11/11/OpenGL-3DModel/">OpenGLES 3.0 - 3D模型</a></li><li><a href="/2023/11/12/OpenGL-3DModelLoad/">OpenGLES 3.0 - 3D模型加载和渲染</a></li></ol><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><ol><li><a href="/2023/11/14/OpenGL-AudioVideoRecording/">AudioVideoRecording源码分析</a></li><li><a href="/2023/11/15/OpenGL-Grafika/">Grafika源码分析</a></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s/26BywT1MbM20zybeWD12mw">全网最全的 Android 音视频和 OpenGL ES 干货</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4MjU1MDk3Ng==&action=getalbum&album_id=1337181710408302593&scene=173&from_msgid=2451526136&from_itemidx=1&count=3&nolastread=1#wechat_redirect">OpenGL专题</a></li><li><a href="https://cstsinghua.github.io/2018/07/12/openGL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/">OpenGL学习路径</a></li><li><a href="https://zhuanlan.zhihu.com/p/553509106">图形渲染学习路线</a></li><li><a href="https://glumes.com/android-av-beginner-resource/">推荐几个堪称教科书级别的 Android 音视频入门项目</a></li><li><a href="https://www.zhihu.com/column/c_1375900139991678976">一步步学OpenGL3.3+</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenGL的概念，相信大家都听说过，应用场景非常广泛，音视频、图形渲染、游戏等等。学习OpenGL是有一定的门槛，期间也看过很多其他OpenGL教程，有些写的是非常不错的，例如&lt;a href=&quot;https://learnopengl.com/&quot;&gt;LearnOpenGL&lt;/a&gt;，能够系统性的学习OpenGL概念和应用。本系列教程，主要会从Android OpenGL ES入手，系统性的介绍图形学渲染技术，结合音视频进行相关应用，并分析两个教科书级别的项目，更加巩固OpenGL技术。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
    <category term="Video" scheme="http://yeungeek.github.io/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>Android知识体系</title>
    <link href="http://yeungeek.github.io/2020/05/09/Android-Knowledge-System/"/>
    <id>http://yeungeek.github.io/2020/05/09/Android-Knowledge-System/</id>
    <published>2020-05-09T10:13:46.000Z</published>
    <updated>2025-02-18T02:37:18.914Z</updated>
    
    <content type="html"><![CDATA[<p>建立一套比较完整的 Android 知识体系，对Android开发或者面试都有裨益，以及后面对某个垂直领域的深入，或者成为该领域的技术专家，甚至是架构师，也有一定的路线指导作用。<br>夯实基础是重中之重，深入某个垂直领域，都是根据当前的业务需求，一步步深入，从而成为该领域专家。<br>下面列表的内容，都是经过实例验证，做到真正掌握才会写到自己的博客里。比较完整的提纲是在最后的思维导图中，提纲中的内容，如果经过了自己验证，就会更新到博客里(持续更新)。 </p><span id="more"></span><h1 id="Android基础"><a href="#Android基础" class="headerlink" title="Android基础"></a>Android基础</h1><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h2 id="View体系"><a href="#View体系" class="headerlink" title="View体系"></a>View体系</h2><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><ul><li><a href="/2019/08/21/AndroidNDK-DeepUnderstandJNI/">Android NDK-深入理解JNI</a></li></ul><h1 id="Android框架层-Framework"><a href="#Android框架层-Framework" class="headerlink" title="Android框架层(Framework)"></a>Android框架层(Framework)</h1><h1 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><ul><li><a href="/2019/07/17/Network-OKHttp/">Android网络编程-OKHttp源码角度分析Http</a></li></ul><h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><ul><li><a href="/2019/07/25/Network-Retrofit/">Android网络编程-Retrofit源码角度分析Http</a></li></ul><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h1 id="推荐资源"><a href="#推荐资源" class="headerlink" title="推荐资源"></a>推荐资源</h1><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li><a href="https://item.jd.com/11760209.html">《Android开发艺术探索》</a></li><li><a href="https://item.jd.com/12438713.html">《Android进阶解密》</a></li></ul><h2 id="在线课程"><a href="#在线课程" class="headerlink" title="在线课程"></a>在线课程</h2><ul><li><a href="https://time.geekbang.org/column/intro/142">Android开发高手课</a></li><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a></li><li><a href="https://time.geekbang.org/column/intro/100010301">深入拆解Java虚拟机</a></li></ul><h1 id="Android知识体系"><a href="#Android知识体系" class="headerlink" title="Android知识体系"></a>Android知识体系</h1><p>思维导图的内容并不是需要全部掌握，根据当前的业务需求，在某些领域进行深入，不过基础是必须掌握的。<br><img src="https://s1.ax1x.com/2020/05/10/Y8cqc8.png" alt="Y8cqc8.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/henrymorgen/android-knowledge-system">Android应用开发原创知识体系</a></li><li><a href="https://blog.csdn.net/carson_ho/article/details/89838873">请收好这一份全面 &amp; 详细的Android学习指南</a></li><li><a href="https://mp.weixin.qq.com/s/rJkxRDlor1ZUfdmfwvqwNg">这些年“崛起”的Android技术博主们</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;建立一套比较完整的 Android 知识体系，对Android开发或者面试都有裨益，以及后面对某个垂直领域的深入，或者成为该领域的技术专家，甚至是架构师，也有一定的路线指导作用。&lt;br&gt;夯实基础是重中之重，深入某个垂直领域，都是根据当前的业务需求，一步步深入，从而成为该领域专家。&lt;br&gt;下面列表的内容，都是经过实例验证，做到真正掌握才会写到自己的博客里。比较完整的提纲是在最后的思维导图中，提纲中的内容，如果经过了自己验证，就会更新到博客里(持续更新)。 &lt;/p&gt;</summary>
    
    
    
    <category term="Android框架层" scheme="http://yeungeek.github.io/categories/Android%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
    
    <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-CameraX源码分析</title>
    <link href="http://yeungeek.github.io/2020/02/28/AndroidCamera-CameraXSource/"/>
    <id>http://yeungeek.github.io/2020/02/28/AndroidCamera-CameraXSource/</id>
    <published>2020-02-28T21:35:11.000Z</published>
    <updated>2025-02-18T02:37:18.914Z</updated>
    
    <content type="html"><![CDATA[<p>在前面一篇文章中，已经介绍了如何使用 CameraX，这篇文章就分析下 CameraX 主要流程的源码。</p><span id="more"></span><p>本篇分析的源码版本是1.0.0-alpha06，目前最新的 CameraX 版本是<a href="https://developer.android.com/jetpack/androidx/releases/camera">1.0.0-alpha10</a>。  </p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>在 build.gradle 中声明</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> camerax_version = <span class="string">&quot;1.0.0-alpha06&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-core:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-camera2:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> camerax_view_version = <span class="string">&quot;1.0.0-alpha03&quot;</span></span><br><span class="line"><span class="keyword">def</span> camerax_ext_version = <span class="string">&quot;1.0.0-alpha03&quot;</span></span><br><span class="line"><span class="comment">//other</span></span><br><span class="line"><span class="comment">// If you to use the Camera View class</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-view:$camerax_view_version&quot;</span></span><br><span class="line"><span class="comment">// If you to use Camera Extensions</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-extensions:$camerax_ext_version&quot;</span></span><br></pre></td></tr></table></figure><ul><li>camera-core：Camera核心库，设计架构的实现</li><li>camera-camera2：Camera2的配置和操作封装</li><li>camera-view：自定义的 CameraView 组件</li><li>camera-extensions：Camera的扩展，用于访问设备专属供应商效果（例如散景、HDR 及其他功能）的 API</li></ul><p>其中<code>camera-core</code>和<code>camera-camera2</code>是必须使用的库，使用该库，可以轻松地使用Camera2 API的功能</p><h1 id="CameraX结构"><a href="#CameraX结构" class="headerlink" title="CameraX结构"></a>CameraX结构</h1><p>首先看下 CameraX 的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CameraX</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraX</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">CameraRepository</span> <span class="variable">mCameraRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraRepository</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">mInitialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">UseCaseGroupRepository</span> <span class="variable">mUseCaseGroupRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseCaseGroupRepository</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorHandler</span> <span class="variable">mErrorHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorHandler</span>();</span><br><span class="line"><span class="keyword">private</span> CameraFactory mCameraFactory;</span><br><span class="line"><span class="keyword">private</span> CameraDeviceSurfaceManager mSurfaceManager;</span><br><span class="line"><span class="keyword">private</span> UseCaseConfigFactory mDefaultConfigFactory;</span><br><span class="line"><span class="keyword">private</span> Context mContext;</span><br></pre></td></tr></table></figure><p>主要看其中几个重要属性： </p><ul><li>CameraRepository：Camera仓库，保存可用 Camera 的列表</li><li>UseCaseGroupRepository：UseCaseGroupLifecycleController实例仓库，每个UseCaseGroupLifecycleController都与一个LifecycleOwner相关联，该LifecycleOwner调节组中所有用例共享的通用生命周期</li><li>CameraFactory：Camera抽象工厂，Camera2CameraFactory是具体的实现类</li><li>CameraDeviceSurfaceManager：Camera设备与对应数据流管理，具体实现是Camera2DeviceSurfaceManager</li><li>UseCaseConfigFactory：UseCase配置工厂</li></ul><p>CameraX主要使用<code>UseCase</code>的概念与相机设备进行交互，目前提供的<code>UseCase</code>：</p><ul><li>预览(Preview)</li><li>图片拍摄(ImageCapture)</li><li>图片分析(ImageAnalysis)</li></ul><h2 id="CameraX初始化"><a href="#CameraX初始化" class="headerlink" title="CameraX初始化"></a>CameraX初始化</h2><p><img src="https://s1.ax1x.com/2020/04/13/GXwNU1.png" alt="GXwNU1.png"></p><h3 id="Camera2Initializer"><a href="#Camera2Initializer" class="headerlink" title="Camera2Initializer"></a>Camera2Initializer</h3><p>CameraX初始化方法：init</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context, <span class="meta">@NonNull</span> AppConfig appConfig)</span> &#123;</span><br><span class="line">   INSTANCE.initInternal(context, appConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init 是通过ContentProvier配置初始化，具体实现类<code>Camera2Initializer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Camera2Initializer</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;Camera2Initializer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;CameraX initializing with Camera2 ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CameraX.init(getContext(), Camera2AppConfig.create(getContext()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AndroidMainifest.xml</code>会自动生成provider配置，ContentProvider的OnCreate调用比Applicantion的 onCreate调用更早。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;androidx.camera.camera2.impl.Camera2Initializer&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:multiprocess</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.camerax-init&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:initOrder</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Camera2AppConfig"><a href="#Camera2AppConfig" class="headerlink" title="Camera2AppConfig"></a>Camera2AppConfig</h3><p>init 方法传入的 AppConfig 的 create：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AppConfig <span class="title function_">create</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   <span class="comment">// Create the camera factory for creating Camera2 camera objects</span></span><br><span class="line">   <span class="type">CameraFactory</span> <span class="variable">cameraFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera2CameraFactory</span>(context);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create the DeviceSurfaceManager for Camera2</span></span><br><span class="line">   <span class="type">CameraDeviceSurfaceManager</span> <span class="variable">surfaceManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera2DeviceSurfaceManager</span>(context);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create default configuration factory</span></span><br><span class="line">   <span class="type">ExtendableUseCaseConfigFactory</span> <span class="variable">configFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtendableUseCaseConfigFactory</span>();</span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            ImageAnalysisConfig.class, <span class="keyword">new</span> <span class="title class_">ImageAnalysisConfigProvider</span>(cameraFactory, context));</span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            ImageCaptureConfig.class, <span class="keyword">new</span> <span class="title class_">ImageCaptureConfigProvider</span>(cameraFactory, context));</span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            VideoCaptureConfig.class, <span class="keyword">new</span> <span class="title class_">VideoCaptureConfigProvider</span>(cameraFactory, context));</span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            PreviewConfig.class, <span class="keyword">new</span> <span class="title class_">PreviewConfigProvider</span>(cameraFactory, context));</span><br><span class="line"></span><br><span class="line">   AppConfig.<span class="type">Builder</span> <span class="variable">appConfigBuilder</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AppConfig</span>.Builder()</span><br><span class="line">                  .setCameraFactory(cameraFactory)</span><br><span class="line">                  .setDeviceSurfaceManager(surfaceManager)</span><br><span class="line">                  .setUseCaseConfigFactory(configFactory);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> appConfigBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 AppConfig.Builder 进行构建，CameraX中的默认属性都在这里初始化。后面具体讲到某个 UseCase 的时候，详细分析下具体的ConfigProvider</p><h3 id="CameraX-initInternal"><a href="#CameraX-initInternal" class="headerlink" title="CameraX.initInternal"></a>CameraX.initInternal</h3><p>CameraX真正初始化方法：<code>initInternal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">(Context context, AppConfig appConfig)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mInitialized.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mContext = context.getApplicationContext();</span><br><span class="line">   mCameraFactory = appConfig.getCameraFactory(<span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (mCameraFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Invalid app configuration provided. Missing CameraFactory.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mSurfaceManager = appConfig.getDeviceSurfaceManager(<span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (mSurfaceManager == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Invalid app configuration provided. Missing CameraDeviceSurfaceManager.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mDefaultConfigFactory = appConfig.getUseCaseConfigRepository(<span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (mDefaultConfigFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Invalid app configuration provided. Missing UseCaseConfigFactory.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mCameraRepository.init(mCameraFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接从 AppConfig 中获取到具体实例，mCameraFactory对应的实例是<code>Camera2CameraFactory</code>，mCameraRepository.init(mCameraFactory)进行 Camera 相关的初始化</p><h3 id="CameraRepository-init"><a href="#CameraRepository-init" class="headerlink" title="CameraRepository.init"></a>CameraRepository.init</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(CameraFactory cameraFactory)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mCamerasLock) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            Set&lt;String&gt; camerasList = cameraFactory.getAvailableCameraIds();</span><br><span class="line">            <span class="keyword">for</span> (String id : camerasList) &#123;</span><br><span class="line">               Log.d(TAG, <span class="string">&quot;Added camera: &quot;</span> + id);</span><br><span class="line">               mCameras.put(id, cameraFactory.getCamera(id));</span><br><span class="line">            &#125;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getAvailableCameraIds</code>获取可用 Camera Id列表，Camera2CameraFactory的<code>getCamera</code>真正初始化Camera</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BaseCamera <span class="title function_">getCamera</span><span class="params">(<span class="meta">@NonNull</span> String cameraId)</span> &#123;</span><br><span class="line">   <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>(mCameraManager, cameraId,</span><br><span class="line">            mAvailabilityRegistry.getAvailableCameraCount(), sHandler);</span><br><span class="line">   mAvailabilityRegistry.registerCamera(camera);</span><br><span class="line">   <span class="keyword">return</span> camera;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>CameraAvailabilityRegistry</code>的<code>registerCamera</code>方法进行Camera注册<br>到此为止，CameraX 相关属性就初始化完成了</p><h2 id="bindToLifecycle"><a href="#bindToLifecycle" class="headerlink" title="bindToLifecycle"></a>bindToLifecycle</h2><p>从第一个<code>UseCase</code>预览(preview)来讲解CameraX 生命周期过程，以及数据传输流程。<br>前面一篇文章已经讲解过 CameraX 的使用，其中预览(preivew)，会先声明<code>PreviewConfig</code>,通过 config 生成<code>Preivew</code>，<code>preview.setOnPreviewOutputUpdateListener</code>设置监听Camera数据流。这一系列流程能够实现，主要通过<code>CameraX.bindToLifecycle</code>实现<br>具体流程：<br><img src="https://s1.ax1x.com/2020/04/13/GXRjuq.png" alt="GXRjuq.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindToLifecycle</span><span class="params">(LifecycleOwner lifecycleOwner, UseCase... useCases)</span> &#123;</span><br><span class="line">   Threads.checkMainThread();</span><br><span class="line">   <span class="type">UseCaseGroupLifecycleController</span> <span class="variable">useCaseGroupLifecycleController</span> <span class="operator">=</span></span><br><span class="line">            INSTANCE.getOrCreateUseCaseGroup(lifecycleOwner);</span><br><span class="line">   <span class="type">UseCaseGroup</span> <span class="variable">useCaseGroupToBind</span> <span class="operator">=</span> useCaseGroupLifecycleController.getUseCaseGroup();</span><br><span class="line"></span><br><span class="line">   Collection&lt;UseCaseGroupLifecycleController&gt; controllers =</span><br><span class="line">            INSTANCE.mUseCaseGroupRepository.getUseCaseGroups();</span><br><span class="line">   <span class="comment">//检查UseCase 只能在一个lifecycle上</span></span><br><span class="line">   <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">      <span class="keyword">for</span> (UseCaseGroupLifecycleController controller : controllers) &#123;</span><br><span class="line">            <span class="type">UseCaseGroup</span> <span class="variable">useCaseGroup</span> <span class="operator">=</span> controller.getUseCaseGroup();</span><br><span class="line">            <span class="keyword">if</span> (useCaseGroup.contains(useCase) &amp;&amp; useCaseGroup != useCaseGroupToBind) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        String.format(</span><br><span class="line">                              <span class="string">&quot;Use case %s already bound to a different lifecycle.&quot;</span>,</span><br><span class="line">                              useCase));</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//onBind监听回调</span></span><br><span class="line">   <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">      useCase.onBind();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   calculateSuggestedResolutions(lifecycleOwner, useCases);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">      useCaseGroupToBind.addUseCase(useCase);</span><br><span class="line">      <span class="keyword">for</span> (String cameraId : useCase.getAttachedCameraIds()) &#123;</span><br><span class="line">            attach(cameraId, useCase);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   useCaseGroupLifecycleController.notifyState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UseCaseGroupLifecycleController"><a href="#UseCaseGroupLifecycleController" class="headerlink" title="UseCaseGroupLifecycleController"></a>UseCaseGroupLifecycleController</h3><p>创建 UseCaseGroupLifecycleController，UseCaseGroup控制器，通过Lifecycle组件进行 start 和 stop 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UseCaseGroupLifecycleController</span> <span class="variable">useCaseGroupLifecycleController</span> <span class="operator">=</span></span><br><span class="line">            INSTANCE.getOrCreateUseCaseGroup(lifecycleOwner);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> UseCaseGroupLifecycleController <span class="title function_">getOrCreateUseCaseGroup</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> mUseCaseGroupRepository.getOrCreateUseCaseGroup(</span><br><span class="line">            lifecycleOwner, <span class="keyword">new</span> <span class="title class_">UseCaseGroupRepository</span>.UseCaseGroupSetup() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UseCaseGroup useCaseGroup)</span> &#123;</span><br><span class="line">                  useCaseGroup.setListener(mCameraRepository);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过UseCaseGroupRepository创建UseCaseGroupLifecycleController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">UseCaseGroupLifecycleController <span class="title function_">getOrCreateUseCaseGroup</span><span class="params">(</span></span><br><span class="line"><span class="params">            LifecycleOwner lifecycleOwner, UseCaseGroupSetup groupSetup)</span> &#123;</span><br><span class="line">   UseCaseGroupLifecycleController useCaseGroupLifecycleController;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCasesLock) &#123;</span><br><span class="line">      <span class="comment">//如果有缓存，则直接返回，否则进行创建</span></span><br><span class="line">      useCaseGroupLifecycleController = mLifecycleToUseCaseGroupControllerMap.get(</span><br><span class="line">               lifecycleOwner);</span><br><span class="line">      <span class="keyword">if</span> (useCaseGroupLifecycleController == <span class="literal">null</span>) &#123;</span><br><span class="line">            useCaseGroupLifecycleController = createUseCaseGroup(lifecycleOwner);</span><br><span class="line">            groupSetup.setup(useCaseGroupLifecycleController.getUseCaseGroup());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> useCaseGroupLifecycleController;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">private</span> UseCaseGroupLifecycleController <span class="title function_">createUseCaseGroup</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Need to add observer before creating UseCaseGroupLifecycleController to make sure</span></span><br><span class="line">   <span class="comment">// UseCaseGroups can be stopped before the latest active one is started.</span></span><br><span class="line">   lifecycleOwner.getLifecycle().addObserver(createLifecycleObserver());</span><br><span class="line">   <span class="type">UseCaseGroupLifecycleController</span> <span class="variable">useCaseGroupLifecycleController</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UseCaseGroupLifecycleController</span>(lifecycleOwner.getLifecycle());</span><br><span class="line">   <span class="comment">//创建后，放入 map 缓存</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCasesLock) &#123;</span><br><span class="line">      mLifecycleToUseCaseGroupControllerMap.put(lifecycleOwner,</span><br><span class="line">               useCaseGroupLifecycleController);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> useCaseGroupLifecycleController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建UseCaseGroupLifecycleController，并增加Lifecycle生命周期控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">UseCaseGroupLifecycleController(Lifecycle lifecycle) &#123;</span><br><span class="line">   <span class="built_in">this</span>(lifecycle, <span class="keyword">new</span> <span class="title class_">UseCaseGroup</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wraps an existing &#123;<span class="doctag">@link</span> UseCaseGroup&#125; so it is controlled by lifecycle transitions. */</span></span><br><span class="line">UseCaseGroupLifecycleController(Lifecycle lifecycle, UseCaseGroup useCaseGroup) &#123;</span><br><span class="line">   <span class="built_in">this</span>.mUseCaseGroup = useCaseGroup;</span><br><span class="line">   <span class="built_in">this</span>.mLifecycle = lifecycle;</span><br><span class="line">   <span class="comment">//绑定Lifecycle</span></span><br><span class="line">   lifecycle.addObserver(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCaseGroupLock) &#123;</span><br><span class="line">      mUseCaseGroup.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCaseGroupLock) &#123;</span><br><span class="line">      mUseCaseGroup.stop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCaseGroupLock) &#123;</span><br><span class="line">      mUseCaseGroup.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，增加了<code>ON_START</code>，<code>ON_STOP</code>，<code>ON_DESTROY</code>的生命周期监听  </p><h3 id="calculateSuggestedResolutions"><a href="#calculateSuggestedResolutions" class="headerlink" title="calculateSuggestedResolutions"></a>calculateSuggestedResolutions</h3><p>根据传入的配置，生成各个UseCase的最佳解决方案。后面的代码会以<code>Preview</code>这个 UseCase 展开，其他 UseCase 代码逻辑类似。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calculateSuggestedResolutions</span><span class="params">(LifecycleOwner lifecycleOwner,</span></span><br><span class="line"><span class="params">            UseCase... useCases)</span> &#123;</span><br><span class="line">   <span class="comment">// There will only one lifecycleOwner active. Therefore, only collect use cases belong to</span></span><br><span class="line">   <span class="comment">// same lifecycleOwner and calculate the suggested resolutions.</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Collect new use cases for different camera devices</span></span><br><span class="line">   <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">cameraId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            cameraId = getCameraWithCameraDeviceConfig(</span><br><span class="line">                  (CameraDeviceConfig) useCase.getUseCaseConfig());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraInfoUnavailableException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                  <span class="string">&quot;Unable to get camera id for the camera device config.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Get suggested resolutions and update the use case session configuration</span></span><br><span class="line">   <span class="keyword">for</span> (String cameraId : newCameraIdUseCaseMap.keySet()) &#123;</span><br><span class="line">      Map&lt;UseCase, Size&gt; suggestResolutionsMap =</span><br><span class="line">               getSurfaceManager()</span><br><span class="line">                        .getSuggestedResolutions(</span><br><span class="line">                              cameraId,</span><br><span class="line">                              originalCameraIdUseCaseMap.get(cameraId),</span><br><span class="line">                              newCameraIdUseCaseMap.get(cameraId));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (UseCase useCase : newCameraIdUseCaseMap.get(cameraId)) &#123;</span><br><span class="line">            <span class="type">Size</span> <span class="variable">resolution</span> <span class="operator">=</span> suggestResolutionsMap.get(useCase);</span><br><span class="line">            Map&lt;String, Size&gt; suggestedCameraSurfaceResolutionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            suggestedCameraSurfaceResolutionMap.put(cameraId, resolution);</span><br><span class="line">            <span class="comment">//更新配置</span></span><br><span class="line">            useCase.updateSuggestedResolution(suggestedCameraSurfaceResolutionMap);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 UseCase 会去更新对应配置 updateSuggestedResolution-&gt;onSuggestedResolutionUpdated</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateSuggestedResolution</span><span class="params">(Map&lt;String, Size&gt; suggestedResolutionMap)</span> &#123;</span><br><span class="line">   Map&lt;String, Size&gt; resolutionMap = onSuggestedResolutionUpdated(suggestedResolutionMap);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onSuggestedResolutionUpdated针对不同的 UseCase 有不同的实现，这里以<code>Preview</code>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Map&lt;String, Size&gt; <span class="title function_">onSuggestedResolutionUpdated</span><span class="params">(</span></span><br><span class="line"><span class="params">            Map&lt;String, Size&gt; suggestedResolutionMap)</span> &#123;</span><br><span class="line">   <span class="comment">//获取前面配置的 config</span></span><br><span class="line">   <span class="type">PreviewConfig</span> <span class="variable">config</span> <span class="operator">=</span> (PreviewConfig) getUseCaseConfig();</span><br><span class="line">   <span class="type">String</span> <span class="variable">cameraId</span> <span class="operator">=</span> getCameraIdUnchecked(config);</span><br><span class="line">   <span class="type">Size</span> <span class="variable">resolution</span> <span class="operator">=</span> suggestedResolutionMap.get(cameraId);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//设置 config</span></span><br><span class="line">   updateConfigAndOutput(config, resolution);</span><br><span class="line">   <span class="keyword">return</span> suggestedResolutionMap;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigAndOutput</span><span class="params">(PreviewConfig config, Size resolution)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">cameraId</span> <span class="operator">=</span> getCameraIdUnchecked(config);</span><br><span class="line">   <span class="comment">//初始化pipeline</span></span><br><span class="line">   mSessionConfigBuilder = createPipeline(config, resolution);</span><br><span class="line">   attachToCamera(cameraId, mSessionConfigBuilder.build());</span><br><span class="line">   updateOutput(mSurfaceTextureHolder.getSurfaceTexture(), resolution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preview-createPipeline"><a href="#Preview-createPipeline" class="headerlink" title="Preview.createPipeline"></a>Preview.createPipeline</h3><p>创建Preview管道，通过 PreviewConfig 的配置，创建对应的显示Surface和SessionConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SessionConfig.Builder <span class="title function_">createPipeline</span><span class="params">(PreviewConfig config, Size resolution)</span> &#123;</span><br><span class="line">   Threads.checkMainThread();</span><br><span class="line">   SessionConfig.<span class="type">Builder</span> <span class="variable">sessionConfigBuilder</span> <span class="operator">=</span> SessionConfig.Builder.createFrom(config);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="type">CaptureProcessor</span> <span class="variable">captureProcessor</span> <span class="operator">=</span> config.getCaptureProcessor(<span class="literal">null</span>);</span><br><span class="line">   <span class="comment">//扩展的 extensions实现</span></span><br><span class="line">   <span class="keyword">if</span> (captureProcessor != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">CaptureStage</span> <span class="variable">captureStage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaptureStage</span>.DefaultCaptureStage();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> To allow user to use an Executor for the processing.</span></span><br><span class="line">      ...</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ImageInfoProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> config.getImageInfoProcessor(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (processor != <span class="literal">null</span>) &#123;</span><br><span class="line">            sessionConfigBuilder.addCameraCaptureCallback(<span class="keyword">new</span> <span class="title class_">CameraCaptureCallback</span>() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureCompleted</span><span class="params">(</span></span><br><span class="line"><span class="params">                        <span class="meta">@NonNull</span> CameraCaptureResult cameraCaptureResult)</span> &#123;</span><br><span class="line">                  <span class="built_in">super</span>.onCaptureCompleted(cameraCaptureResult);</span><br><span class="line">                  <span class="keyword">if</span> (processor.process(</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">CameraCaptureResultImageInfo</span>(cameraCaptureResult))) &#123;</span><br><span class="line">                        notifyUpdated();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//默认的 Surface</span></span><br><span class="line">      <span class="type">CheckedSurfaceTexture</span> <span class="variable">checkedSurfaceTexture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckedSurfaceTexture</span>(resolution);</span><br><span class="line"></span><br><span class="line">      mSurfaceTextureHolder = checkedSurfaceTexture;</span><br><span class="line">      sessionConfigBuilder.addSurface(checkedSurfaceTexture);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以看到我们熟悉的味道，在Camera2中 用到的<code>Surface</code>，<code>Session</code>相关配置，后面会用到相关配置。<br>在<code>CheckedSurfaceTexture</code>中会创建<code>FixedSizeSurfaceTexture</code>用来显示图像。  </p><h3 id="Preview-updateOutput"><a href="#Preview-updateOutput" class="headerlink" title="Preview.updateOutput"></a>Preview.updateOutput</h3><p>增加数据的监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">updateOutput</span><span class="params">(SurfaceTexture surfaceTexture, Size resolution)</span> &#123;</span><br><span class="line">   <span class="type">PreviewConfig</span> <span class="variable">useCaseConfig</span> <span class="operator">=</span> (PreviewConfig) getUseCaseConfig();</span><br><span class="line">   ...</span><br><span class="line">   <span class="type">PreviewOutput</span> <span class="variable">newOutput</span> <span class="operator">=</span></span><br><span class="line">            PreviewOutput.create(surfaceTexture, resolution, relativeRotation);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Only update the output if something has changed</span></span><br><span class="line">   <span class="keyword">if</span> (!Objects.equals(mLatestPreviewOutput, newOutput)) &#123;</span><br><span class="line">      <span class="type">SurfaceTexture</span> <span class="variable">oldTexture</span> <span class="operator">=</span></span><br><span class="line">               (mLatestPreviewOutput == <span class="literal">null</span>)</span><br><span class="line">                        ? <span class="literal">null</span></span><br><span class="line">                        : mLatestPreviewOutput.getSurfaceTexture();</span><br><span class="line">      <span class="type">OnPreviewOutputUpdateListener</span> <span class="variable">outputListener</span> <span class="operator">=</span> getOnPreviewOutputUpdateListener();</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (outputListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            mSurfaceDispatched = <span class="literal">true</span>;</span><br><span class="line">            updateListener(outputListener, newOutput);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Preview设置的setOnPreviewOutputUpdateListener，获取到对应的Listener，通过<code>updateListener</code>方法回调数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateListener</span><span class="params">(OnPreviewOutputUpdateListener listener, PreviewOutput output)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   mOutputUpdateExecutor.execute(() -&gt; listener.onUpdated(output));</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notifyState"><a href="#notifyState" class="headerlink" title="notifyState"></a>notifyState</h3><p>调用UseCaseGroupLifecycleController的notifyState，激活 UseCase 状态，在UseCaseGroupLifecycleController中有增加生命周期的监听，在<code>ON_START</code>状态会调用<code>mUseCaseGroup.start</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">notifyState</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCaseGroupLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mLifecycle.getCurrentState().isAtLeast(State.STARTED)) &#123;</span><br><span class="line">            mUseCaseGroup.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (UseCase useCase : mUseCaseGroup.getUseCases()) &#123;</span><br><span class="line">            useCase.notifyState();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UseCaseGroup-start"><a href="#UseCaseGroup-start" class="headerlink" title="UseCaseGroup.start"></a>UseCaseGroup.start</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mListenerLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            mListener.onGroupActive(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      mIsActive = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 start 状态，调用<code>CameraRepository</code>的<code>onGroupActive</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onGroupActive</span><span class="params">(UseCaseGroup useCaseGroup)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mCamerasLock) &#123;</span><br><span class="line">      Map&lt;String, Set&lt;UseCase&gt;&gt; cameraIdToUseCaseMap = useCaseGroup.getCameraIdToUseCaseMap();</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;UseCase&gt;&gt; cameraUseCaseEntry :</span><br><span class="line">               cameraIdToUseCaseMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">BaseCamera</span> <span class="variable">camera</span> <span class="operator">=</span> getCamera(cameraUseCaseEntry.getKey());</span><br><span class="line">            attachUseCasesToCamera(camera, cameraUseCaseEntry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attachUseCasesToCamera</span><span class="params">(BaseCamera camera, Set&lt;UseCase&gt; useCases)</span> &#123;</span><br><span class="line">   camera.addOnlineUseCase(useCases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>camera.addOnlineUseCase</code>关联UseCase 和 Camera。</p><h3 id="Camera-addOnlineUseCase"><a href="#Camera-addOnlineUseCase" class="headerlink" title="Camera.addOnlineUseCase"></a>Camera.addOnlineUseCase</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOnlineUseCase</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Collection&lt;UseCase&gt; useCases)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (useCases.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Attaches the surfaces of use case to the Camera (prevent from surface abandon crash)</span></span><br><span class="line">   <span class="comment">// addOnlineUseCase could be called with duplicate use case, so we need to filter out</span></span><br><span class="line">   <span class="comment">// use cases that are either pending for addOnline or are already online.</span></span><br><span class="line">   <span class="comment">// It&#x27;s ok for two thread to run here, since it‘ll do nothing if use case is already</span></span><br><span class="line">   <span class="comment">// pending.</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mPendingLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isOnline</span> <span class="operator">=</span> isUseCaseOnline(useCase);</span><br><span class="line">            <span class="keyword">if</span> (mPendingForAddOnline.contains(useCase) || isOnline) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notifyAttachToUseCaseSurfaces(useCase);</span><br><span class="line">            mPendingForAddOnline.add(useCase);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   updateCaptureSessionConfig();</span><br><span class="line">   resetCaptureSession(<span class="comment">/*abortInFlightCaptures=*/</span><span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mState == InternalState.OPENED) &#123;</span><br><span class="line">      openCaptureSession();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      open();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   updateCameraControlPreviewAspectRatio(useCases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在addOnlineUseCase方法中，open会去打开Camera设备。</p><h3 id="Camera-open"><a href="#Camera-open" class="headerlink" title="Camera.open"></a>Camera.open</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">            openCameraDevice();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CLOSING:</span><br><span class="line">            setState(InternalState.REOPENING);</span><br><span class="line">            <span class="comment">// If session close has not yet completed, then the camera is still open. We</span></span><br><span class="line">            <span class="comment">// can move directly back into an OPENED state.</span></span><br><span class="line">            <span class="comment">// If session close is already complete, then the camera is closing. We&#x27;ll reopen</span></span><br><span class="line">            <span class="comment">// the camera in the camera state callback.</span></span><br><span class="line">            <span class="comment">// If the camera device is currently in an error state, we need to close the</span></span><br><span class="line">            <span class="comment">// camera before reopening, so we cannot directly reopen.</span></span><br><span class="line">            <span class="keyword">if</span> (!isSessionCloseComplete() &amp;&amp; mCameraDeviceError == ERROR_NONE) &#123;</span><br><span class="line">               Preconditions.checkState(mCameraDevice != <span class="literal">null</span>,</span><br><span class="line">                        <span class="string">&quot;Camera Device should be open if session close is not complete&quot;</span>);</span><br><span class="line">               setState(InternalState.OPENED);</span><br><span class="line">               openCaptureSession();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;open() ignored due to being in state: &quot;</span> + mState);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">openCameraDevice</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Check that we have an available camera to open here before attempting</span></span><br><span class="line">   <span class="comment">// to open the camera again.</span></span><br><span class="line">   <span class="keyword">if</span> (!mCameraAvailability.isCameraAvailable()) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;No cameras available. Waiting for available camera before opening camera: &quot;</span></span><br><span class="line">               + mCameraId);</span><br><span class="line">      setState(InternalState.PENDING_OPEN);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setState(InternalState.OPENING);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//真正打开相机</span></span><br><span class="line">   mCameraManager.openCamera(mCameraId, mExecutor, createDeviceStateCallback());</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是Camera2的预览流程</p><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><p>CameraX封装了Camera2的标准预览流程，这些类都是在 CameraX 库中<br><img src="https://s1.ax1x.com/2020/04/13/GXLFRP.png" alt="GXLFRP.png"></p><h3 id="CameraDevice-StateCallback"><a href="#CameraDevice-StateCallback" class="headerlink" title="CameraDevice.StateCallback"></a>CameraDevice.StateCallback</h3><p><code>openCameraDevice</code>的stateCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StateCallback</span> <span class="keyword">extends</span> <span class="title class_">CameraDevice</span>.StateCallback &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(CameraDevice cameraDevice)</span> &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;CameraDevice.onOpened(): &quot;</span> + cameraDevice.getId());</span><br><span class="line">      mCameraDevice = cameraDevice;</span><br><span class="line">      mCameraDeviceError = ERROR_NONE;</span><br><span class="line">      <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> CLOSING:</span><br><span class="line">            <span class="keyword">case</span> RELEASING:</span><br><span class="line">               <span class="comment">// No session should have yet been opened, so close camera directly here.</span></span><br><span class="line">               Preconditions.checkState(isSessionCloseComplete());</span><br><span class="line">               mCameraDevice.close();</span><br><span class="line">               mCameraDevice = <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OPENING:</span><br><span class="line">            <span class="keyword">case</span> REOPENING:</span><br><span class="line">               setState(InternalState.OPENED);</span><br><span class="line">               openCaptureSession();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;onOpened() should not be possible from state: &quot;</span> + mState);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">openCaptureSession</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   mCaptureSession.open(validatingBuilder.build(), mCameraDevice);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CaptureSession-open"><a href="#CaptureSession-open" class="headerlink" title="CaptureSession.open"></a>CaptureSession.open</h3><p>创建CaptureSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">open</span><span class="params">(SessionConfig sessionConfig, CameraDevice cameraDevice)</span></span><br><span class="line">      <span class="keyword">throws</span> CameraAccessException, DeferrableSurface.SurfaceClosedException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mStateLock) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> UNINITIALIZED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;open() should not be possible in state: &quot;</span> + mState);</span><br><span class="line">            <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">               <span class="comment">//Camera中传入的essionConfig，默认有TEMPLATE_PREVIEW的 surface 实现</span></span><br><span class="line">               List&lt;DeferrableSurface&gt; surfaces = sessionConfig.getSurfaces();</span><br><span class="line">               ...</span><br><span class="line">               <span class="comment">//状态更新</span></span><br><span class="line">               notifySurfaceAttached();</span><br><span class="line">               mState = State.OPENING;</span><br><span class="line">               ...</span><br><span class="line">               <span class="type">SessionConfigurationCompat</span> <span class="variable">sessionConfigCompat</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SessionConfigurationCompat</span>(</span><br><span class="line">                              SessionConfigurationCompat.SESSION_REGULAR,</span><br><span class="line">                              outputConfigList,</span><br><span class="line">                              getExecutor(),</span><br><span class="line">                              comboCallback);</span><br><span class="line"></span><br><span class="line">               <span class="type">CaptureRequest</span> <span class="variable">captureRequest</span> <span class="operator">=</span></span><br><span class="line">                        Camera2CaptureRequestBuilder.buildWithoutTarget(</span><br><span class="line">                              captureConfigBuilder.build(),</span><br><span class="line">                              cameraDevice);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (captureRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">                  sessionConfigCompat.setSessionParameters(captureRequest);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//创建CaptureSession，CameraDeviceCompat根据 Android 版本有不同的实现</span></span><br><span class="line">               CameraDeviceCompat.createCaptureSession(cameraDevice, sessionConfigCompat);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在Camera2的使用中，CameraDevice的createCaptureSession可以创建预览画面，CameraX的CaptureSession很好的封装了这些实现。<br>在<code>CaptureSession.open</code>传入的SessionConfig，是在<code>Camera2AppConfig.create</code>创建的时候生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AppConfig <span class="title function_">create</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   <span class="comment">// Create the camera factory for creating Camera2 camera objects</span></span><br><span class="line">   <span class="type">CameraFactory</span> <span class="variable">cameraFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera2CameraFactory</span>(context);</span><br><span class="line">   <span class="comment">// PreviewConfig 配置</span></span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            PreviewConfig.class, <span class="keyword">new</span> <span class="title class_">PreviewConfigProvider</span>(cameraFactory, context));</span><br><span class="line"></span><br><span class="line">   AppConfig.<span class="type">Builder</span> <span class="variable">appConfigBuilder</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AppConfig</span>.Builder()</span><br><span class="line">                  .setCameraFactory(cameraFactory)</span><br><span class="line">                  .setDeviceSurfaceManager(surfaceManager)</span><br><span class="line">                  .setUseCaseConfigFactory(configFactory);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> appConfigBuilder.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PreviewConfigProvider配置getConfig</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PreviewConfig <span class="title function_">getConfig</span><span class="params">(LensFacing lensFacing)</span> &#123;</span><br><span class="line">   PreviewConfig.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span></span><br><span class="line">            PreviewConfig.Builder.fromConfig(Preview.DEFAULT_CONFIG.getConfig(lensFacing));</span><br><span class="line">   <span class="comment">// SessionConfig containing all intrinsic properties needed for Preview</span></span><br><span class="line">   SessionConfig.<span class="type">Builder</span> <span class="variable">sessionBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SessionConfig</span>.Builder();</span><br><span class="line">   <span class="comment">// createCaptureSession中的 preview 设置</span></span><br><span class="line">   sessionBuilder.setTemplateType(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add options to UseCaseConfig</span></span><br><span class="line">   builder.setDefaultSessionConfig(sessionBuilder.build());</span><br><span class="line">   builder.setSessionOptionUnpacker(Camera2SessionOptionUnpacker.INSTANCE);</span><br><span class="line"></span><br><span class="line">   CaptureConfig.<span class="type">Builder</span> <span class="variable">captureBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaptureConfig</span>.Builder();</span><br><span class="line">   captureBuilder.setTemplateType(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">   builder.setDefaultCaptureConfig(captureBuilder.build());</span><br><span class="line">   builder.setCaptureOptionUnpacker(Camera2CaptureOptionUnpacker.INSTANCE);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CameraDeviceCompat.createCaptureSession</code>的CameraCaptureSession回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StateCallback</span> <span class="keyword">extends</span> <span class="title class_">CameraCaptureSession</span>.StateCallback &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigured</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mStateLock) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">               <span class="keyword">case</span> UNINITIALIZED:</span><br><span class="line">               <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">               <span class="keyword">case</span> OPENED:</span><br><span class="line">               <span class="keyword">case</span> RELEASED:</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                           <span class="string">&quot;onConfigured() should not be possible in state: &quot;</span> + mState);</span><br><span class="line">               <span class="keyword">case</span> OPENING:</span><br><span class="line">                  ...</span><br><span class="line">                  <span class="comment">// Issue capture request of enableSession if exists.</span></span><br><span class="line">                  <span class="keyword">if</span> (mSessionConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">Config</span> <span class="variable">implOptions</span> <span class="operator">=</span> mSessionConfig.getImplementationOptions();</span><br><span class="line">                        <span class="type">CameraEventCallbacks</span> <span class="variable">eventCallbacks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera2Config</span>(</span><br><span class="line">                              implOptions).getCameraEventCallback(</span><br><span class="line">                              CameraEventCallbacks.createEmptyCallback());</span><br><span class="line">                              <span class="comment">//可配置CameraEventCallback的EnableSession回调</span></span><br><span class="line">                        List&lt;CaptureConfig&gt; list =</span><br><span class="line">                              eventCallbacks.createComboCallback().onEnableSession();</span><br><span class="line">                        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">                           issueCaptureRequests(setupConfiguredSurface(list));</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//</span></span><br><span class="line">                  issueRepeatingCaptureRequests();</span><br><span class="line">                  issueBurstCaptureRequest();</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CaptureSession-issueRepeatingCaptureRequests"><a href="#CaptureSession-issueRepeatingCaptureRequests" class="headerlink" title="CaptureSession.issueRepeatingCaptureRequests"></a>CaptureSession.issueRepeatingCaptureRequests</h3><p>开启Camera预览</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">issueRepeatingCaptureRequests</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="type">CaptureConfig</span> <span class="variable">captureConfig</span> <span class="operator">=</span> mSessionConfig.getRepeatingCaptureConfig();</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// The override priority for implementation options</span></span><br><span class="line">   <span class="comment">// P1 CameraEventCallback onRepeating options</span></span><br><span class="line">   <span class="comment">// P2 SessionConfig options</span></span><br><span class="line">   CaptureConfig.<span class="type">Builder</span> <span class="variable">captureConfigBuilder</span> <span class="operator">=</span> CaptureConfig.Builder.from(captureConfig);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建CaptureRequest</span></span><br><span class="line">   <span class="type">CaptureRequest</span> <span class="variable">captureRequest</span> <span class="operator">=</span> Camera2CaptureRequestBuilder.build(</span><br><span class="line">            captureConfigBuilder.build(), mCameraCaptureSession.getDevice(),</span><br><span class="line">            mConfiguredSurfaceMap);</span><br><span class="line">   <span class="keyword">if</span> (captureRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">         Log.d(TAG, <span class="string">&quot;Skipping issuing empty request for session.&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置Capture回调</span></span><br><span class="line">   CameraCaptureSession.<span class="type">CaptureCallback</span> <span class="variable">comboCaptureCallback</span> <span class="operator">=</span></span><br><span class="line">            createCamera2CaptureCallback(</span><br><span class="line">                     captureConfig.getCameraCaptureCallbacks(),</span><br><span class="line">                     mCaptureCallback);</span><br><span class="line"></span><br><span class="line">   CameraCaptureSessionCompat.setSingleRepeatingRequest(mCameraCaptureSession,</span><br><span class="line">            captureRequest, mExecutor, comboCaptureCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraCaptureSessionCompat.setSingleRepeatingRequest 也是区分 Android 版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CameraCaptureSessionCompatImpl <span class="title function_">chooseImplementation</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">28</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CameraCaptureSessionCompatApi28Impl</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CameraCaptureSessionCompatBaseImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CameraCaptureSessionCompatBaseImpl，和平时使用的一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setSingleRepeatingRequest</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession captureSession,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> CaptureRequest request, <span class="meta">@NonNull</span> Executor executor,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> CameraCaptureSession.CaptureCallback listener)</span> <span class="keyword">throws</span> CameraAccessException &#123;</span><br><span class="line">   Preconditions.checkNotNull(captureSession);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Wrap the executor in the callback</span></span><br><span class="line">   CameraCaptureSession.<span class="type">CaptureCallback</span> <span class="variable">cb</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CameraCaptureSessionCompat</span>.CaptureCallbackExecutorWrapper(executor, listener);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> captureSession.setRepeatingRequest(</span><br><span class="line">            request, cb, MainThreadAsyncHandler.getInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CameraCaptureSessionCompatApi28Impl，新版本 API 有些变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setSingleRepeatingRequest</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession captureSession,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> CaptureRequest request, <span class="meta">@NonNull</span> Executor executor,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> CameraCaptureSession.CaptureCallback listener)</span> <span class="keyword">throws</span> CameraAccessException &#123;</span><br><span class="line">   Preconditions.checkNotNull(captureSession);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Call through directly to executor API</span></span><br><span class="line">   <span class="keyword">return</span> captureSession.setSingleRepeatingRequest(request, executor, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Camera的开启到预览，以及读取各种配置，整个过程到此就完成了，接下来介绍如何拍照，这个流程相对来说比较简单</p><h2 id="ImageCapture-takePicture"><a href="#ImageCapture-takePicture" class="headerlink" title="ImageCapture.takePicture"></a>ImageCapture.takePicture</h2><p>拍照的流程：<br><img src="https://s1.ax1x.com/2020/04/17/JZ52bd.png" alt="JZ52bd.png"></p><h3 id="sendImageCaptureRequest"><a href="#sendImageCaptureRequest" class="headerlink" title="sendImageCaptureRequest"></a>sendImageCaptureRequest</h3><p>创建 ImageCaptureRequest，设置cameraId、targetRatio、回调等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendImageCaptureRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Executor listenerExecutor, OnImageCapturedListener listener)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">cameraId</span> <span class="operator">=</span> getCameraIdUnchecked(mConfig);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get the relative rotation or default to 0 if the camera info is unavailable</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">relativeRotation</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">CameraInfoInternal</span> <span class="variable">cameraInfoInternal</span> <span class="operator">=</span> CameraX.getCameraInfo(cameraId);</span><br><span class="line">      relativeRotation =</span><br><span class="line">               cameraInfoInternal.getSensorRotationDegrees(</span><br><span class="line">                        mConfig.getTargetRotation(Surface.ROTATION_0));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraInfoUnavailableException e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Unable to retrieve camera sensor orientation.&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">Rational</span> <span class="variable">targetRatio</span> <span class="operator">=</span> mConfig.getTargetAspectRatioCustom(<span class="literal">null</span>);</span><br><span class="line">   targetRatio = ImageUtil.rotate(targetRatio, relativeRotation);</span><br><span class="line"></span><br><span class="line">   mImageCaptureRequests.offer(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ImageCaptureRequest</span>(relativeRotation, targetRatio, listenerExecutor, listener));</span><br><span class="line">   <span class="keyword">if</span> (mImageCaptureRequests.size() == <span class="number">1</span>) &#123;</span><br><span class="line">      issueImageCaptureRequests();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="takePictureInternal"><a href="#takePictureInternal" class="headerlink" title="takePictureInternal"></a>takePictureInternal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">issueImageCaptureRequests</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mImageCaptureRequests.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   takePictureInternal();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//拍照流程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">takePictureInternal</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//自定义 Future 调用链</span></span><br><span class="line">   FutureChain.from(preTakePicture(state))</span><br><span class="line">      .transformAsync&#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">return</span> ImageCapture.<span class="built_in">this</span>.issueTakePicture(state);</span><br><span class="line">      &#125;)</span><br><span class="line">      .transformAsync&#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">return</span> ImageCapture.<span class="built_in">this</span>.postTakePicture(state);</span><br><span class="line">      &#125;)</span><br><span class="line">      .addCallback(</span><br><span class="line">         ...</span><br><span class="line">         onTakePictureFinish(<span class="literal">null</span>);</span><br><span class="line">      )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义了整个拍照工作流，通过<code>issueTakePicture</code>进行拍照，<code>postTakePicture</code>是拍照成功，释放资源，取消3A。下面重点看下<code>issueTakePicture</code>流程</p><h3 id="issueTakePicture"><a href="#issueTakePicture" class="headerlink" title="issueTakePicture"></a>issueTakePicture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;Void&gt; <span class="title function_">issueTakePicture</span><span class="params">(TakePictureState state)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   getCurrentCameraControl().submitCaptureRequests(captureConfigs);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>CameraControl</code>提交Capture 请求，<code>CameraControl</code>具体实现是<code>Camera2CameraControl</code>。</p><h3 id="submitCaptureRequests"><a href="#submitCaptureRequests" class="headerlink" title="submitCaptureRequests"></a>submitCaptureRequests</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitCaptureRequests</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> List&lt;CaptureConfig&gt; captureConfigs)</span> &#123;</span><br><span class="line">   mExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            submitCaptureRequestsInternal(captureConfigs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">submitCaptureRequestsInternal</span><span class="params">(<span class="keyword">final</span> List&lt;CaptureConfig&gt; captureConfigs)</span> &#123;</span><br><span class="line">   mControlUpdateListener.onCameraControlCaptureRequests(captureConfigs);</span><br><span class="line">   <span class="comment">//mControlUpdateListener是Camera 的回调，onCameraControlCaptureRequests 真正实现在 Camera 中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Camera.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCameraControlUpdateSessionConfig</span><span class="params">(<span class="meta">@NonNull</span> SessionConfig sessionConfig)</span> &#123;</span><br><span class="line">   mCameraControlSessionConfig = sessionConfig;</span><br><span class="line">   updateCaptureSessionConfig();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateCaptureSessionConfig</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">         <span class="type">SessionConfig</span> <span class="variable">sessionConfig</span> <span class="operator">=</span> validatingBuilder.build();</span><br><span class="line">         mCaptureSession.setSessionConfig(sessionConfig);</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Camera 获取 Capture的SessionConfig，通过`CaptureSession`进行状态控制</span><br></pre></td></tr></table></figure><h3 id="CaptureSession-setSessionConfig"><a href="#CaptureSession-setSessionConfig" class="headerlink" title="CaptureSession.setSessionConfig"></a>CaptureSession.setSessionConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setSessionConfig</span><span class="params">(SessionConfig sessionConfig)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mStateLock) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> UNINITIALIZED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;setSessionConfig() should not be possible in state: &quot;</span> + mState);</span><br><span class="line">            <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">            <span class="keyword">case</span> OPENING:</span><br><span class="line">               mSessionConfig = sessionConfig;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OPENED:</span><br><span class="line">               mSessionConfig = sessionConfig;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!mConfiguredSurfaceMap.keySet().containsAll(sessionConfig.getSurfaces())) &#123;</span><br><span class="line">                  Log.e(TAG, <span class="string">&quot;Does not have the proper configured lists&quot;</span>);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Log.d(TAG, <span class="string">&quot;Attempting to submit CaptureRequest after setting&quot;</span>);</span><br><span class="line">               issueRepeatingCaptureRequests();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSED:</span><br><span class="line">            <span class="keyword">case</span> RELEASING:</span><br><span class="line">            <span class="keyword">case</span> RELEASED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;Session configuration cannot be set on a closed/released session.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Camera的OPENED状态，则进行拍照流程</p><h3 id="issueRepeatingCaptureRequests"><a href="#issueRepeatingCaptureRequests" class="headerlink" title="issueRepeatingCaptureRequests"></a>issueRepeatingCaptureRequests</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">issueRepeatingCaptureRequests</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   CameraCaptureSession.<span class="type">CaptureCallback</span> <span class="variable">comboCaptureCallback</span> <span class="operator">=</span></span><br><span class="line">                    createCamera2CaptureCallback(</span><br><span class="line">                            captureConfig.getCameraCaptureCallbacks(),</span><br><span class="line">                            mCaptureCallback);</span><br><span class="line"></span><br><span class="line">   CameraCaptureSessionCompat.setSingleRepeatingRequest(mCameraCaptureSession,</span><br><span class="line">                    captureRequest, mExecutor, comboCaptureCallback);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CameraCaptureSessionCompat</code>根据 Android 版本有<code>CameraCaptureSessionCompatBaseImpl</code>和<code>CameraCaptureSessionCompatApi28Impl</code>两种实现，最终通过<code>CameraCaptureSession</code>实现真正的拍照。<br>拍照完成后，通过最开始设置的 Listener 进行回调</p><h3 id="ImageCapture-createPipeline"><a href="#ImageCapture-createPipeline" class="headerlink" title="ImageCapture.createPipeline"></a>ImageCapture.createPipeline</h3><p>在 Preview 那小节，讲解过 bindToLifecycle 流程，这里的<code>ImageCapture</code>也是一个<code>UseCase</code>。在CameraX中的<code>calculateSuggestedResolutions</code>方法，最终会调用到各个<code>UseCase</code>的<code>onSuggestedResolutionUpdated</code>方法。在<code>ImageCapture</code>的<code>onSuggestedResolutionUpdated</code>方法，通过<code>createPipeline</code>创建了拍照数据的回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SessionConfig.Builder <span class="title function_">createPipeline</span><span class="params">(ImageCaptureConfig config,  Size resolution)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//和 Camera2的流程一致</span></span><br><span class="line">   mProcessingImageResultThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;OnImageAvailableHandlerThread&quot;</span>);</span><br><span class="line">   mProcessingImageResultThread.start();</span><br><span class="line">   mProcessingImageResultHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mProcessingImageResultThread.getLooper());</span><br><span class="line">   ...</span><br><span class="line">   mImageReader.setOnImageAvailableListener(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageReaderProxy</span>.OnImageAvailableListener() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onImageAvailable</span><span class="params">(ImageReaderProxy imageReader)</span> &#123;</span><br><span class="line">            <span class="type">ImageProxy</span> <span class="variable">image</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                  image = imageReader.acquireLatestImage();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">                  Log.e(TAG, <span class="string">&quot;Failed to acquire latest image.&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (image != <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// Call the head request listener to process the captured image.</span></span><br><span class="line">                     ImageCaptureRequest imageCaptureRequest;</span><br><span class="line">                     <span class="keyword">if</span> ((imageCaptureRequest = mImageCaptureRequests.peek()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">SingleCloseImageProxy</span> <span class="variable">wrappedImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleCloseImageProxy</span>(</span><br><span class="line">                                 image);</span><br><span class="line">                        wrappedImage.addOnImageCloseListener(mOnImageCloseListener);</span><br><span class="line">                        <span class="comment">//ImageCaptureRequest设置 Listener</span></span><br><span class="line">                        imageCaptureRequest.dispatchImage(wrappedImage);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Discard the image if we have no requests.</span></span><br><span class="line">                        image.close();</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      mProcessingImageResultHandler);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImageReader设置了 Camera 数据会调用，并通过<code>ImageCaptureRequest</code>的<code>dispatchImage</code>方法进行分发</p><h3 id="ImageCaptureRequest-dispatchImage"><a href="#ImageCaptureRequest-dispatchImage" class="headerlink" title="ImageCaptureRequest.dispatchImage"></a>ImageCaptureRequest.dispatchImage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchImage</span><span class="params">(<span class="keyword">final</span> ImageProxy image)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">         mListenerExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="type">Size</span> <span class="variable">sourceSize</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(image.getWidth(), image.getHeight());</span><br><span class="line">               <span class="keyword">if</span> (ImageUtil.isAspectRatioValid(sourceSize, mTargetRatio)) &#123;</span><br><span class="line">                     image.setCropRect(</span><br><span class="line">                           ImageUtil.computeCropRectFromAspectRatio(sourceSize,</span><br><span class="line">                                    mTargetRatio));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//真正的回调</span></span><br><span class="line">               mListener.onCaptureSuccess(image, mRotationDegrees);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">         Log.e(TAG, <span class="string">&quot;Unable to post to the supplied executor.&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Unable to execute on the supplied executor, close the image.</span></span><br><span class="line">         image.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mListener</code>是一个封装Listener，在<code>ImageCapture</code>中实现</p><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener的关系图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">|                       |</span><br><span class="line">|ImageCapture.          |</span><br><span class="line">|OnImageCapturedListener|</span><br><span class="line">|                       |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">+-----------v-----------+      +----------------------+</span><br><span class="line">|                       |      |                      |</span><br><span class="line">| ImageSaver.           |      | ImageCapture.        |</span><br><span class="line">| OnImageSavedListener  +------&gt; OnImageSavedListener |</span><br><span class="line">|                       |      |                      |</span><br><span class="line">+-----------------------+      +----------------------+</span><br></pre></td></tr></table></figure><p><code>OnImageCapturedListener</code>的实现，其中通过<code>ImageSaver</code>设置的<code>OnImageSavedListener</code>回调到最上层的<code>OnImageSavedListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OnImageCapturedListener</span> <span class="variable">imageCaptureCallbackWrapper</span> <span class="operator">=</span></span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">OnImageCapturedListener</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureSuccess</span><span class="params">(ImageProxy image, <span class="type">int</span> rotationDegrees)</span> &#123;</span><br><span class="line">         CameraXExecutors.ioExecutor()</span><br><span class="line">                  .execute(</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">ImageSaver</span>(</span><br><span class="line">                                 image,</span><br><span class="line">                                 saveLocation,</span><br><span class="line">                                 rotationDegrees,</span><br><span class="line">                                 metadata.isReversedHorizontal,</span><br><span class="line">                                 metadata.isReversedVertical,</span><br><span class="line">                                 metadata.location,</span><br><span class="line">                                 executor,</span><br><span class="line">                                 imageSavedListenerWrapper));</span><br><span class="line">      &#125;</span><br><span class="line">   ...</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">// ImageSaver是一个 Runnable，主要 run 的实现</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImageSaver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//图像处理</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (saveError != <span class="literal">null</span>) &#123;</span><br><span class="line">         postError(saveError, errorMessage, exception);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         postSuccess();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">      mExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//最外层回调</span></span><br><span class="line">            mListener.onImageSaved(mFile);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个拍照流程和数据回调就讲解完毕了。<br>通过对 CameraX的 Preview 和 ImageCapture的分析，CameraX对Camera2进行完整的封装，统一参数配置，自动计算Resolution，简化Camera2的开发，并增加了生命周期控制，对外只暴露了简单接口。<br>使用该库，只需要简单的几行代码就可以实现以前Camera2复杂的操作。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/training/camerax/architecture">CameraX 架构</a></li><li><a href="https://medium.com/androiddevelopers/core-principles-behind-camerax-jetpack-library-8e8380f7604c">Core Principles Behind CameraX Jetpack Library</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面一篇文章中，已经介绍了如何使用 CameraX，这篇文章就分析下 CameraX 主要流程的源码。&lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="CameraX" scheme="http://yeungeek.github.io/tags/CameraX/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-CameraView源码分析</title>
    <link href="http://yeungeek.github.io/2020/01/29/AndroidCamera-CameraViewAnalysis/"/>
    <id>http://yeungeek.github.io/2020/01/29/AndroidCamera-CameraViewAnalysis/</id>
    <published>2020-01-29T15:54:31.000Z</published>
    <updated>2025-02-18T02:37:18.914Z</updated>
    
    <content type="html"><![CDATA[<p>在前面文章中已经介绍了如何使用 <a href="https://github.com/google/cameraview">CameraView</a>，这是 Google 官方提供的库，并有相关 demo，因为 Android 的碎片化太严重，官方也是考虑到这些，才提供了<a href="https://github.com/google/cameraview">CameraView</a>供大家学习和参考。     </p><span id="more"></span><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><a href="https://imgchr.com/i/1WWkn0"><img src="https://s2.ax1x.com/2020/02/08/1WWkn0.png" alt="源码结构"></a><br>根据官方的说明： </p><table><thead><tr><th align="center">API Level</th><th>Camera API</th><th>Preview View</th></tr></thead><tbody><tr><td align="center">9-13</td><td>Camera1</td><td>SurfaceView</td></tr><tr><td align="center">14-20</td><td>Camera1</td><td>TextureView</td></tr><tr><td align="center">21-23</td><td>Camera2</td><td>TextureView</td></tr><tr><td align="center">24</td><td>Camera2</td><td>SurfaceView</td></tr></tbody></table><p>具体的实现都在<a href="https://github.com/google/cameraview/blob/master/library/src/main/java/com/google/android/cameraview/CameraView.java">CameraView类</a>中。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>源码中涉及到的主要类之间的关系，是从最新的源码中查看到(跟官网的表格不太一样，最新的源码sdk最低版本为14)：<br><img src="https://s2.ax1x.com/2020/02/13/1OoPpD.png" alt="CameraView"></p><ul><li>Camera 区分：Android5.0(21)以下使用 Camera1，以上使用 Camera2</li><li>Preview View：Android6.0(23)以上使用SurfaceView(SurfaceView在Android7.0上增加了新特性(平移、旋转等))，这里应该是 Android7.0以上(&gt;23)使用SurfaceView，其他都使用TextureView，最新的源码sdk最低版本要求14。</li></ul><h2 id="CameraView"><a href="#CameraView" class="headerlink" title="CameraView"></a>CameraView</h2><p>CameraView使用非常简单，在 CameraView 使用那篇文章已经做过详细说明。 </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.cameraview.CameraView</span><br><span class="line">    android:id=<span class="string">&quot;@+id/camera&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:keepScreenOn=<span class="string">&quot;true&quot;</span></span><br><span class="line">    android:adjustViewBounds=<span class="string">&quot;true&quot;</span></span><br><span class="line">    app:autoFocus=<span class="string">&quot;true&quot;</span></span><br><span class="line">    app:aspectRatio=<span class="string">&quot;4:3&quot;</span></span><br><span class="line">    app:facing=<span class="string">&quot;back&quot;</span></span><br><span class="line">    app:flash=<span class="string">&quot;auto&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>直接看下<code>CameraView</code>的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CameraView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Internal setup</span></span><br><span class="line">   <span class="comment">// 1.创建预览视图</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">PreviewImpl</span> <span class="variable">preview</span> <span class="operator">=</span> createPreviewImpl(context);</span><br><span class="line">   mCallbacks = <span class="keyword">new</span> <span class="title class_">CallbackBridge</span>();</span><br><span class="line">   <span class="comment">// 2.根据 Android SDK 版本选择不同的 Camera</span></span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">21</span>) &#123;</span><br><span class="line">      mImpl = <span class="keyword">new</span> <span class="title class_">Camera1</span>(mCallbacks, preview);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">23</span>) &#123;</span><br><span class="line">      mImpl = <span class="keyword">new</span> <span class="title class_">Camera2</span>(mCallbacks, preview, context);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mImpl = <span class="keyword">new</span> <span class="title class_">Camera2Api23</span>(mCallbacks, preview, context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Attributes</span></span><br><span class="line">   <span class="comment">// 3. 读取自定义 View 属性, 设置相机摄像头位置、预览画面比例、对焦方式、闪光灯</span></span><br><span class="line">   <span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, R.styleable.CameraView, defStyleAttr,</span><br><span class="line">            R.style.Widget_CameraView);</span><br><span class="line">   mAdjustViewBounds = a.getBoolean(R.styleable.CameraView_android_adjustViewBounds, <span class="literal">false</span>);</span><br><span class="line">   setFacing(a.getInt(R.styleable.CameraView_facing, FACING_BACK));</span><br><span class="line">   <span class="type">String</span> <span class="variable">aspectRatio</span> <span class="operator">=</span> a.getString(R.styleable.CameraView_aspectRatio);</span><br><span class="line">   <span class="keyword">if</span> (aspectRatio != <span class="literal">null</span>) &#123;</span><br><span class="line">      setAspectRatio(AspectRatio.parse(aspectRatio));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setAspectRatio(Constants.DEFAULT_ASPECT_RATIO);</span><br><span class="line">   &#125;</span><br><span class="line">   setAutoFocus(a.getBoolean(R.styleable.CameraView_autoFocus, <span class="literal">true</span>));</span><br><span class="line">   setFlash(a.getInt(R.styleable.CameraView_flash, Constants.FLASH_AUTO));</span><br><span class="line">   a.recycle();</span><br><span class="line">   <span class="comment">// Display orientation detector</span></span><br><span class="line">   <span class="comment">// 4. 增加旋转方向监听，设置相机的旋转方向</span></span><br><span class="line">   mDisplayOrientationDetector = <span class="keyword">new</span> <span class="title class_">DisplayOrientationDetector</span>(context) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisplayOrientationChanged</span><span class="params">(<span class="type">int</span> displayOrientation)</span> &#123;</span><br><span class="line">            mImpl.setDisplayOrientation(displayOrientation);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createPreviewImpl</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PreviewImpl <span class="title function_">createPreviewImpl</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   PreviewImpl preview;</span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">      preview = <span class="keyword">new</span> <span class="title class_">SurfaceViewPreview</span>(context, <span class="built_in">this</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      preview = <span class="keyword">new</span> <span class="title class_">TextureViewPreview</span>(context, <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> preview;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要代码角度看下CameraView版本选择策略，在最开始的已经说明。<br>Camera的选择：api &lt;21的，使用Camera1，&gt;&#x3D;21使用 Camera2，这里完全没有问题。<br>Camera Preview的选择，存在几个疑问，api &gt;&#x3D;23使用SurfaceView，不过api 24的时候使用SurfaceView才是官方推荐的。  </p><blockquote><p>Starting in platform version N, SurfaceView’s window position is updated synchronously with other View rendering. This means that translating and scaling a SurfaceView on screen will not cause rendering artifacts. Such artifacts may occur on previous versions of the platform when its window is positioned asynchronously.</p></blockquote><p>这里应该 api &gt;23使用SurfaceView，其他情况使用TextureView，因为在工程中 定义了<code>minSdkVersion = 14</code>，api 14-23使用TextureView，表格可以更新为：</p><table><thead><tr><th align="center">API Level</th><th>Camera API</th><th>Preview View</th></tr></thead><tbody><tr><td align="center">14-20</td><td>Camera1</td><td>TextureView</td></tr><tr><td align="center">21-23</td><td>Camera2</td><td>TextureView</td></tr><tr><td align="center">24</td><td>Camera2</td><td>SurfaceView</td></tr></tbody></table><h3 id="Preview定义"><a href="#Preview定义" class="headerlink" title="Preview定义"></a>Preview定义</h3><p><code>PreviewImpl</code>封装了预览控件的操作方法，<code>SurfaceViewPreview</code>和<code>TextureViewPreview</code>分别对应<code>SurfaceView</code>和<code>TextureView</code>的<code>PreviewImpl</code>实现。  </p><h4 id="SurfaceViewPreview"><a href="#SurfaceViewPreview" class="headerlink" title="SurfaceViewPreview"></a>SurfaceViewPreview</h4><p>实现很简单，直接加载有<code>SurfaceView</code>控件的布局，并封装了<code>SurfaceHolder</code>操作</p><h4 id="TextureViewPreview"><a href="#TextureViewPreview" class="headerlink" title="TextureViewPreview"></a>TextureViewPreview</h4><p>直接加载有<code>TextureView</code>控件布局，并监听<code>TextureView.SurfaceTextureListener</code>。</p><h3 id="Camera定义"><a href="#Camera定义" class="headerlink" title="Camera定义"></a>Camera定义</h3><p><code>CameraViewImpl</code>定义了相机的各种操作，<code>Camera1</code>、<code>Camera2</code>、<code>Camera2Api23</code>都是<code>CameraViewImpl</code>的具体实现。<br>看下它们的构造函数:<br><code>Camera1</code>   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Camera1(Callback callback, PreviewImpl preview) &#123;</span><br><span class="line">   <span class="built_in">super</span>(callback, preview);</span><br><span class="line">   preview.setCallback(<span class="keyword">new</span> <span class="title class_">PreviewImpl</span>.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">               setUpPreview();</span><br><span class="line">               adjustCameraParameters();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了 Callback，当SurfaceChanged的时候，设置预览和 Camera 参数。<br><code>Camera2</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Camera2(Callback callback, PreviewImpl preview, Context context) &#123;</span><br><span class="line">   <span class="built_in">super</span>(callback, preview);</span><br><span class="line">   mCameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">   mPreview.setCallback(<span class="keyword">new</span> <span class="title class_">PreviewImpl</span>.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">()</span> &#123;</span><br><span class="line">            startCaptureSession();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.初始化了<code>CameraManager</code><br>2.增加Callback，当SurfaceChanged的时候，对CaptureSession进行设置  </p><p><code>Camera2Api23</code>继承了<code>Camera2</code>，重用了<code>Camera2</code>的构造。<br>Camera1和 Camera2的实现和使用流程，可以参考前面的几篇文章，接下来介绍<code>CameraView</code>的几个重要方法的实现。</p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!mImpl.start()) &#123;</span><br><span class="line">      <span class="comment">//store the state ,and restore this state after fall back o Camera1</span></span><br><span class="line">      <span class="type">Parcelable</span> <span class="variable">state</span> <span class="operator">=</span> onSaveInstanceState();</span><br><span class="line">      <span class="comment">// Camera2 uses legacy hardware layer; fall back to Camera1</span></span><br><span class="line">      mImpl = <span class="keyword">new</span> <span class="title class_">Camera1</span>(mCallbacks, createPreviewImpl(getContext()));</span><br><span class="line">      onRestoreInstanceState(state);</span><br><span class="line">      mImpl.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启相机，首先判断是否可以开启，如果不能开启，默认会使用 Camera1。</p><h4 id="Camera1-start"><a href="#Camera1-start" class="headerlink" title="Camera1.start"></a>Camera1.start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1. 选择摄像头</span></span><br><span class="line">   chooseCamera();</span><br><span class="line">   <span class="comment">//2. 打开摄像头</span></span><br><span class="line">   openCamera();</span><br><span class="line">   <span class="comment">//3. 设置预览</span></span><br><span class="line">   <span class="keyword">if</span> (mPreview.isReady()) &#123;</span><br><span class="line">      setUpPreview();</span><br><span class="line">   &#125;</span><br><span class="line">   mShowingPreview = <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">//4. 开始预览</span></span><br><span class="line">   mCamera.startPreview();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的流程，可以参考<a href="/2020/01/17/AndroidCamera-UsingCamera1/">Camera1使用</a>，这里介绍几个重要的方法。<br>1.<code>chooseCamera</code>会遍历所有摄像头，然后根据<code>CameraView</code>初始化时传入的值进行对比，默认是<code>FACING_BACK</code>后置摄像头。<br>2.<code>openCamera</code>方法，这里具体展开介绍下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">openCamera</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">      releaseCamera();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1. 打开摄像头</span></span><br><span class="line">   mCamera = Camera.open(mCameraId);</span><br><span class="line">   mCameraParameters = mCamera.getParameters();</span><br><span class="line">   <span class="comment">// Supported preview sizes</span></span><br><span class="line">   mPreviewSizes.clear();</span><br><span class="line">   <span class="comment">//2. 获取所有支持的预览尺寸</span></span><br><span class="line">   <span class="keyword">for</span> (Camera.Size size : mCameraParameters.getSupportedPreviewSizes()) &#123;</span><br><span class="line">      Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;###### SupportedPreviewSizes: width=&quot;</span> + size.width + <span class="string">&quot;, height=&quot;</span></span><br><span class="line">               + size.height);</span><br><span class="line">      mPreviewSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.width, size.height));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Supported picture sizes;</span></span><br><span class="line">   mPictureSizes.clear();</span><br><span class="line">   <span class="comment">//3. 获取所有支持的拍照尺寸</span></span><br><span class="line">   <span class="keyword">for</span> (Camera.Size size : mCameraParameters.getSupportedPictureSizes()) &#123;</span><br><span class="line">      Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;###### SupportedPictureSizes: width=&quot;</span> + size.width + <span class="string">&quot;, height=&quot;</span></span><br><span class="line">               + size.height);</span><br><span class="line">      mPictureSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.width, size.height));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// AspectRatio</span></span><br><span class="line">   <span class="keyword">if</span> (mAspectRatio == <span class="literal">null</span>) &#123;</span><br><span class="line">      mAspectRatio = Constants.DEFAULT_ASPECT_RATIO;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4. 设置预览比例</span></span><br><span class="line">   adjustCameraParameters();</span><br><span class="line">   mCamera.setDisplayOrientation(calcDisplayOrientation(mDisplayOrientation));</span><br><span class="line">   mCallback.onCameraOpened();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>setUpPreview</code>设置预览</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setUpPreview</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mPreview.getOutputClass() == SurfaceHolder.class) &#123;</span><br><span class="line">            mCamera.setPreviewDisplay(mPreview.getSurfaceHolder());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mCamera.setPreviewTexture((SurfaceTexture) mPreview.getSurfaceTexture());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据mPreview类型的不同，使用<code>SurfaceView</code>预览或者<code>TextureView</code>预览。<br>4.<code>mCamera.startPreview()</code>开启预览</p><h4 id="Camera2-start"><a href="#Camera2-start" class="headerlink" title="Camera2.start"></a>Camera2.start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1. 选择摄像头，默认后置摄像头</span></span><br><span class="line">   <span class="keyword">if</span> (!chooseCameraIdByFacing()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2. 设置预览尺寸，预览尺寸比例，拍照尺寸，其他相关设置</span></span><br><span class="line">   collectCameraInfo();</span><br><span class="line">   <span class="comment">//3. 初始化 ImageReader，并设置回调</span></span><br><span class="line">   prepareImageReader();</span><br><span class="line">   <span class="comment">//4. 打开摄像头</span></span><br><span class="line">   startOpeningCamera();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程可以参考<a href="/2020/01/19/AndroidCamera-UsingCamera2/">Camera2使用</a>，这里只介绍重要方法说明。<br>1.<code>chooseCameraIdByFacing</code>遍历支持的摄像头列表，根据条件筛选获取到指定的摄像头，默认后置摄像头。<br>2.<code>collectCameraInfo</code>方法，获取所有支持预览尺寸，和拍照尺寸，并获取支持的预览尺寸比例<br>3.<code>prepareImageReader</code>方法，初始化ImageReader  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareImageReader</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mImageReader != <span class="literal">null</span>) &#123;</span><br><span class="line">      mImageReader.close();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Size</span> <span class="variable">largest</span> <span class="operator">=</span> mPictureSizes.sizes(mAspectRatio).last();</span><br><span class="line">   mImageReader = ImageReader.newInstance(largest.getWidth(), largest.getHeight(),</span><br><span class="line">            ImageFormat.JPEG, <span class="comment">/* maxImages */</span> <span class="number">2</span>);</span><br><span class="line">   mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置输出格式为 JPEG，并增加<code>ImageAvailableListener</code>回调监听。<br>4.<code>startOpeningCamera</code>方法，打开摄像头，并设置<code>CameraDevice.StateCallback</code>监听  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOpeningCamera</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mCameraManager.openCamera(mCameraId, mCameraDeviceCallback, <span class="literal">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to open camera: &quot;</span> + mCameraId, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraDevice.<span class="type">StateCallback</span> <span class="variable">mCameraDeviceCallback</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraDevice</span>.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">      mCamera = camera;</span><br><span class="line">      mCallback.onCameraOpened();</span><br><span class="line">      <span class="comment">//相机打开，开启预览画面</span></span><br><span class="line">      startCaptureSession();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosed</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">      mCallback.onCameraClosed();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisconnected</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">      mCamera = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera, <span class="type">int</span> error)</span> &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;onError: &quot;</span> + camera.getId() + <span class="string">&quot; (&quot;</span> + error + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">      mCamera = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>监听相机打开后，开启预览画面，<code>startCaptureSession</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">startCaptureSession</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isCameraOpened() || !mPreview.isReady() || mImageReader == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1. 选择最合适的预览尺寸</span></span><br><span class="line">   <span class="type">Size</span> <span class="variable">previewSize</span> <span class="operator">=</span> chooseOptimalSize();</span><br><span class="line">   mPreview.setBufferSize(previewSize.getWidth(), previewSize.getHeight());</span><br><span class="line">   <span class="type">Surface</span> <span class="variable">surface</span> <span class="operator">=</span> mPreview.getSurface();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//2. 创建预览请求</span></span><br><span class="line">      mPreviewRequestBuilder = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">      <span class="comment">//3. 请求管理 target surface</span></span><br><span class="line">      mPreviewRequestBuilder.addTarget(surface);</span><br><span class="line">      <span class="comment">//4. 创建CaptureSession，并增加Session监听</span></span><br><span class="line">      mCamera.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),</span><br><span class="line">               mSessionCallback, <span class="literal">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to start camera session&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听<code>CameraCaptureSession</code>状态的回调声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraCaptureSession.<span class="type">StateCallback</span> <span class="variable">mSessionCallback</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraCaptureSession</span>.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigured</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mCaptureSession = session;</span><br><span class="line">      updateAutoFocus();</span><br><span class="line">      updateFlash();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//1. 开启预览，并设置监听回调</span></span><br><span class="line">            mCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(),</span><br><span class="line">                  mCaptureCallback, <span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to start camera preview because it couldn&#x27;t access camera&quot;</span>, e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to start camera preview.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigureFailed</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Failed to configure capture session.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosed</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCaptureSession != <span class="literal">null</span> &amp;&amp; mCaptureSession.equals(session)) &#123;</span><br><span class="line">            mCaptureSession = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="takePicture"><a href="#takePicture" class="headerlink" title="takePicture"></a>takePicture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePicture</span><span class="params">()</span> &#123;</span><br><span class="line">   mImpl.takePicture();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 api 选择不同的实现</p><h4 id="Camera1-takePicture"><a href="#Camera1-takePicture" class="headerlink" title="Camera1.takePicture"></a>Camera1.takePicture</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">takePicture</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isCameraOpened()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Camera is not ready. Call start() before takePicture().&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1. 判断是否自动对焦</span></span><br><span class="line">   <span class="keyword">if</span> (getAutoFocus()) &#123;</span><br><span class="line">      mCamera.cancelAutoFocus();</span><br><span class="line">      mCamera.autoFocus(<span class="keyword">new</span> <span class="title class_">Camera</span>.AutoFocusCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAutoFocus</span><span class="params">(<span class="type">boolean</span> success, Camera camera)</span> &#123;</span><br><span class="line">               <span class="comment">//2. 拍照</span></span><br><span class="line">               takePictureInternal();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2.拍照</span></span><br><span class="line">      takePictureInternal();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正执行拍照的方法<code>takePictureInternal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">takePictureInternal</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isPictureCaptureInProgress.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="comment">//1. 拍照增加回调</span></span><br><span class="line">      mCamera.takePicture(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Camera</span>.PictureCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPictureTaken</span><span class="params">(<span class="type">byte</span>[] data, Camera camera)</span> &#123;</span><br><span class="line">               isPictureCaptureInProgress.set(<span class="literal">false</span>);</span><br><span class="line">               <span class="comment">//2. 把 data 传到上层的回调</span></span><br><span class="line">               mCallback.onPictureTaken(data);</span><br><span class="line">               camera.cancelAutoFocus();</span><br><span class="line">               camera.startPreview();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>takePicture</code>中增加的 jpeg 的<code>PictureCallback</code>回调，返回的data通过callback回调到上层</p><h4 id="Camera2-takePicture"><a href="#Camera2-takePicture" class="headerlink" title="Camera2.takePicture"></a>Camera2.takePicture</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">takePicture</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1.判断自动对焦</span></span><br><span class="line">   <span class="keyword">if</span> (mAutoFocus) &#123;</span><br><span class="line">      lockFocus();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2. 拍照请求</span></span><br><span class="line">      captureStillPicture();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置对焦</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lockFocus</span><span class="params">()</span> &#123;</span><br><span class="line">   mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">            CaptureRequest.CONTROL_AF_TRIGGER_START);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mCaptureCallback.setState(PictureCaptureCallback.STATE_LOCKING);</span><br><span class="line">      mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, <span class="literal">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Failed to lock focus.&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PictureCaptureCallback</span></span><br><span class="line"><span class="type">PictureCaptureCallback</span> <span class="variable">mCaptureCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PictureCaptureCallback</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPrecaptureRequired</span><span class="params">()</span> &#123;</span><br><span class="line">      mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,</span><br><span class="line">               CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);</span><br><span class="line">      setState(STATE_PRECAPTURE);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            mCaptureSession.capture(mPreviewRequestBuilder.build(), <span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,</span><br><span class="line">                  CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to run precapture sequence.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReady</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//2. 拍照请求</span></span><br><span class="line">      captureStillPicture();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>判断是否自动对焦，最后调用<code>captureStillPicture</code>方法进行拍照请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">captureStillPicture</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1. 创建TEMPLATE_STILL_CAPTURE的Capture请求</span></span><br><span class="line">      CaptureRequest.<span class="type">Builder</span> <span class="variable">captureRequestBuilder</span> <span class="operator">=</span> mCamera.createCaptureRequest(</span><br><span class="line">               CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">      <span class="comment">//2. 添加target</span></span><br><span class="line">      captureRequestBuilder.addTarget(mImageReader.getSurface());</span><br><span class="line">      <span class="comment">//3. 设置 AF mode</span></span><br><span class="line">      captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">               mPreviewRequestBuilder.get(CaptureRequest.CONTROL_AF_MODE));</span><br><span class="line">      <span class="comment">//4.flash模式设置</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// Calculate JPEG orientation.</span></span><br><span class="line">      <span class="comment">//5. 计算拍照图片的方向</span></span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;ConstantConditions&quot;)</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">sensorOrientation</span> <span class="operator">=</span> mCameraCharacteristics.get(</span><br><span class="line">               CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line">      captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION,</span><br><span class="line">               (sensorOrientation +</span><br><span class="line">                        mDisplayOrientation * (mFacing == Constants.FACING_FRONT ? <span class="number">1</span> : -<span class="number">1</span>) +</span><br><span class="line">                        <span class="number">360</span>) % <span class="number">360</span>);</span><br><span class="line">      <span class="comment">// Stop preview and capture a still picture.</span></span><br><span class="line">      <span class="comment">//6. 停止预览</span></span><br><span class="line">      mCaptureSession.stopRepeating();</span><br><span class="line">      <span class="comment">//7. 拍照</span></span><br><span class="line">      mCaptureSession.capture(captureRequestBuilder.build(),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">CameraCaptureSession</span>.CaptureCallback() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureCompleted</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session,</span></span><br><span class="line"><span class="params">                           <span class="meta">@NonNull</span> CaptureRequest request,</span></span><br><span class="line"><span class="params">                           <span class="meta">@NonNull</span> TotalCaptureResult result)</span> &#123;</span><br><span class="line">                        <span class="comment">//8. 取消对焦</span></span><br><span class="line">                        unlockFocus();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, <span class="literal">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Cannot capture a still picture.&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消对焦，重新设置预览</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlockFocus</span><span class="params">()</span> &#123;</span><br><span class="line">   mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">            CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, <span class="literal">null</span>);</span><br><span class="line">      updateAutoFocus();</span><br><span class="line">      updateFlash();</span><br><span class="line">      mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">               CaptureRequest.CONTROL_AF_TRIGGER_IDLE);</span><br><span class="line">      mCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(), mCaptureCallback,</span><br><span class="line">               <span class="literal">null</span>);</span><br><span class="line">      mCaptureCallback.setState(PictureCaptureCallback.STATE_PREVIEW);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Failed to restart camera preview.&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拍照后真正的数据回调，是在初始化 ImageReader 的<code>OnImageAvailableListener</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageReader.<span class="type">OnImageAvailableListener</span> <span class="variable">mOnImageAvailableListener</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageReader</span>.OnImageAvailableListener() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onImageAvailable</span><span class="params">(ImageReader reader)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> (<span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> reader.acquireNextImage()) &#123;</span><br><span class="line">            Image.Plane[] planes = image.getPlanes();</span><br><span class="line">            <span class="keyword">if</span> (planes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> planes[<span class="number">0</span>].getBuffer();</span><br><span class="line">               <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.remaining()];</span><br><span class="line">               buffer.get(data);</span><br><span class="line">               <span class="comment">//1. 数据回调到上层</span></span><br><span class="line">               mCallback.onPictureTaken(data);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>如果不用拍照，或者退出应用，调用 stop 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">   mImpl.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Camera1-stop"><a href="#Camera1-stop" class="headerlink" title="Camera1.stop"></a>Camera1.stop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//1. 停止预览</span></span><br><span class="line">      mCamera.stopPreview();</span><br><span class="line">   &#125;</span><br><span class="line">   mShowingPreview = <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">//2. 释放相机资源</span></span><br><span class="line">   releaseCamera();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放相机资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">releaseCamera</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">      mCamera.release();</span><br><span class="line">      mCamera = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">//1. 回调上层</span></span><br><span class="line">      mCallback.onCameraClosed();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Camera2-stop"><a href="#Camera2-stop" class="headerlink" title="Camera2.stop"></a>Camera2.stop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1. 关闭 session</span></span><br><span class="line">   <span class="keyword">if</span> (mCaptureSession != <span class="literal">null</span>) &#123;</span><br><span class="line">      mCaptureSession.close();</span><br><span class="line">      mCaptureSession = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2. 关闭 Camera</span></span><br><span class="line">   <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">      mCamera.close();</span><br><span class="line">      mCamera = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3. 关闭 ImageReader</span></span><br><span class="line">   <span class="keyword">if</span> (mImageReader != <span class="literal">null</span>) &#123;</span><br><span class="line">      mImageReader.close();</span><br><span class="line">      mImageReader = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraView源码相关的分析就结束了，该库很好的封装了 Camera1和 Camera2的使用，本篇文章对其中的重点方法进行了分析，讲解了它的实现原理，希望对大家有所帮助。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://www.jianshu.com/p/0ac7234dcefc">Android相机开发——CameraView源码解析</a></li><li><a href="https://www.jianshu.com/p/f63f296a920b">Android Camera 编程从入门到精通</a></li><li><a href="https://blog.csdn.net/shanshui911587154/article/details/90290535">Android——谷歌cameraview详解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面文章中已经介绍了如何使用 &lt;a href=&quot;https://github.com/google/cameraview&quot;&gt;CameraView&lt;/a&gt;，这是 Google 官方提供的库，并有相关 demo，因为 Android 的碎片化太严重，官方也是考虑到这些，才提供了&lt;a href=&quot;https://github.com/google/cameraview&quot;&gt;CameraView&lt;/a&gt;供大家学习和参考。     &lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="SurfaceView" scheme="http://yeungeek.github.io/tags/SurfaceView/"/>
    
    <category term="TextureView" scheme="http://yeungeek.github.io/tags/TextureView/"/>
    
    <category term="CameraView" scheme="http://yeungeek.github.io/tags/CameraView/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-相机尺寸、方向和图像数据</title>
    <link href="http://yeungeek.github.io/2020/01/24/AndroidCamera-Orientation/"/>
    <id>http://yeungeek.github.io/2020/01/24/AndroidCamera-Orientation/</id>
    <published>2020-01-24T00:14:31.000Z</published>
    <updated>2025-02-18T02:37:18.914Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇文章介绍了Camera1，Camera2，CameraView和CameraX的使用，对各个API的使用，应该问题不大，不过在真正开发过程中，也会遇到各种不同的问题，本篇文章继续介绍相机开发过程中遇到的问题，主要是相机预览、拍照尺寸，方向，以及图像数据的处理。</p><span id="more"></span><h1 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h1><p>这里的尺寸，主要是预览尺寸、拍照尺寸和显示预览画面的View大小。  </p><h2 id="预览尺寸"><a href="#预览尺寸" class="headerlink" title="预览尺寸"></a>预览尺寸</h2><p>如何获取预览尺寸?我们可以从<a href="https://github.com/google/cameraview">cameraview</a>的源码中获取到，分为了Camera1和Camera2。   </p><h3 id="Camera1"><a href="#Camera1" class="headerlink" title="Camera1"></a>Camera1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mCameraParameters = mCamera.getParameters();</span><br><span class="line"><span class="comment">// Supported preview sizes</span></span><br><span class="line">mPreviewSizes.clear();</span><br><span class="line"><span class="keyword">for</span> (Camera.Size size : mCameraParameters.getSupportedPreviewSizes()) &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;###### SupportedPreviewSizes: width=&quot;</span> + size.width + <span class="string">&quot;, height=&quot;</span></span><br><span class="line">            + size.height);</span><br><span class="line">    mPreviewSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.width, size.height));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mPreviewSizes.clear();</span><br><span class="line"><span class="keyword">for</span> (android.util.Size size : map.getOutputSizes(mPreview.getOutputClass())) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> size.getWidth();</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> size.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (width &lt;= MAX_PREVIEW_WIDTH &amp;&amp; height &lt;= MAX_PREVIEW_HEIGHT) &#123;</span><br><span class="line">        mPreviewSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(width, height));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的厂商和系统所支持的预览尺寸是不一样，下面是红米Note 5A手机上支持的所有预览尺寸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SupportedPreviewSizes: width=<span class="number">1280</span>, height=<span class="number">720</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">960</span>, height=<span class="number">720</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">864</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">800</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">768</span>, height=<span class="number">432</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">720</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">640</span>, height=<span class="number">640</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">640</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">480</span>, height=<span class="number">640</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">640</span>, height=<span class="number">360</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">576</span>, height=<span class="number">432</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">480</span>, height=<span class="number">360</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">480</span>, height=<span class="number">320</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">384</span>, height=<span class="number">288</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">352</span>, height=<span class="number">288</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">320</span>, height=<span class="number">240</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">240</span>, height=<span class="number">320</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">240</span>, height=<span class="number">160</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">176</span>, height=<span class="number">144</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">144</span>, height=<span class="number">176</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">160</span>, height=<span class="number">120</span></span><br></pre></td></tr></table></figure><p>这里尺寸的比例一般都是4:3、16:9，其他比例是在此基础上裁剪出来的</p><h2 id="选取预览尺寸"><a href="#选取预览尺寸" class="headerlink" title="选取预览尺寸"></a>选取预览尺寸</h2><p>在相同宽高比下，选择最接近View的宽高，避免过大的预览尺寸, 造成性能损耗, 引起预览卡顿。<br>在<a href="https://github.com/google/cameraview">cameraview</a>源码中，默认定义的宽高比<code>AspectRatio DEFAULT_ASPECT_RATIO = AspectRatio.of(4, 3)</code></p><h3 id="Camera1-1"><a href="#Camera1-1" class="headerlink" title="Camera1"></a>Camera1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Size <span class="title function_">chooseOptimalSize</span><span class="params">(SortedSet&lt;Size&gt; sizes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPreview.isReady()) &#123; <span class="comment">// Not yet laid out</span></span><br><span class="line">        <span class="keyword">return</span> sizes.first(); <span class="comment">// Return the smallest size</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> desiredWidth;</span><br><span class="line">    <span class="type">int</span> desiredHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">surfaceWidth</span> <span class="operator">=</span> mPreview.getWidth();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">surfaceHeight</span> <span class="operator">=</span> mPreview.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (isLandscape(mDisplayOrientation)) &#123;</span><br><span class="line">        desiredWidth = surfaceHeight;</span><br><span class="line">        desiredHeight = surfaceWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        desiredWidth = surfaceWidth;</span><br><span class="line">        desiredHeight = surfaceHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Size</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Size size : sizes) &#123; <span class="comment">// Iterate from small to large</span></span><br><span class="line">        <span class="keyword">if</span> (desiredWidth &lt;= size.getWidth() &amp;&amp; desiredHeight &lt;= size.getHeight()) &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区分了横竖屏，然后得到尺寸中宽和高等于或者大于View的宽高的尺寸。</p><h3 id="Camera2-1"><a href="#Camera2-1" class="headerlink" title="Camera2"></a>Camera2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Size <span class="title function_">chooseOptimalSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> surfaceLonger, surfaceShorter;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">surfaceWidth</span> <span class="operator">=</span> mPreview.getWidth();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">surfaceHeight</span> <span class="operator">=</span> mPreview.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (surfaceWidth &lt; surfaceHeight) &#123;</span><br><span class="line">        surfaceLonger = surfaceHeight;</span><br><span class="line">        surfaceShorter = surfaceWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        surfaceLonger = surfaceWidth;</span><br><span class="line">        surfaceShorter = surfaceHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    SortedSet&lt;Size&gt; candidates = mPreviewSizes.sizes(mAspectRatio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the smallest of those big enough</span></span><br><span class="line">    <span class="keyword">for</span> (Size size : candidates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size.getWidth() &gt;= surfaceLonger &amp;&amp; size.getHeight() &gt;= surfaceShorter) &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If no size is big enough, pick the largest one.</span></span><br><span class="line">    <span class="keyword">return</span> candidates.last();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断View宽高，区分其中较大值和较小值，然后再得到尺寸中宽和高大于或者等于View的较大值和较小值的尺寸。</p><h2 id="拍照尺寸"><a href="#拍照尺寸" class="headerlink" title="拍照尺寸"></a>拍照尺寸</h2><p>代码也是从<a href="https://github.com/google/cameraview">cameraview</a>中截取出来的</p><h3 id="Camera1-2"><a href="#Camera1-2" class="headerlink" title="Camera1"></a>Camera1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mPictureSizes.clear();</span><br><span class="line"><span class="keyword">for</span> (Camera.Size size : mCameraParameters.getSupportedPictureSizes()) &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;###### SupportedPictureSizes: width=&quot;</span> + size.width + <span class="string">&quot;, height=&quot;</span></span><br><span class="line">            + size.height);</span><br><span class="line">    mPictureSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.width, size.height));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Camera2-2"><a href="#Camera2-2" class="headerlink" title="Camera2"></a>Camera2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collectPictureSizes</span><span class="params">(SizeMap sizes, StreamConfigurationMap map)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (android.util.Size size : map.getOutputSizes(ImageFormat.JPEG)) &#123;</span><br><span class="line">        mPictureSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.getWidth(), size.getHeight()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在红米Note 5A手机支持的拍照尺寸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SupportedPictureSizes: width=<span class="number">4160</span>, height=<span class="number">3120</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">4160</span>, height=<span class="number">2340</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">4096</span>, height=<span class="number">3072</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">4096</span>, height=<span class="number">2304</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">4000</span>, height=<span class="number">3000</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">3840</span>, height=<span class="number">2160</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">3264</span>, height=<span class="number">2448</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">3200</span>, height=<span class="number">2400</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2976</span>, height=<span class="number">2976</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2592</span>, height=<span class="number">1944</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2592</span>, height=<span class="number">1458</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2688</span>, height=<span class="number">1512</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2304</span>, height=<span class="number">1728</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2048</span>, height=<span class="number">1536</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2336</span>, height=<span class="number">1314</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1920</span>, height=<span class="number">1080</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1600</span>, height=<span class="number">1200</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1440</span>, height=<span class="number">1080</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1280</span>, height=<span class="number">960</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1280</span>, height=<span class="number">768</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1280</span>, height=<span class="number">720</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1200</span>, height=<span class="number">1200</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1024</span>, height=<span class="number">768</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">800</span>, height=<span class="number">600</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">864</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">800</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">720</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">640</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">640</span>, height=<span class="number">360</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">480</span>, height=<span class="number">640</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">480</span>, height=<span class="number">360</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">480</span>, height=<span class="number">320</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">352</span>, height=<span class="number">288</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">320</span>, height=<span class="number">240</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">240</span>, height=<span class="number">320</span></span><br></pre></td></tr></table></figure><p>这里尺寸的比例一般也是4:3、16:9</p><h2 id="选取拍照尺寸"><a href="#选取拍照尺寸" class="headerlink" title="选取拍照尺寸"></a>选取拍照尺寸</h2><p>Camaer1和Camera2都是一样的逻辑，选取固定宽高比例中的最大尺寸，这样拍摄的图片最清晰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">largest</span> <span class="operator">=</span> mPictureSizes.sizes(mAspectRatio).last();</span><br></pre></td></tr></table></figure><h1 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h1><p>这里的设置方向有两种：图像预览方向和拍照方向。在这之前，需要先介绍几个概念：</p><ul><li>屏幕坐标方向</li><li>设备自然方向</li><li>摄像头传感器方向</li><li>相机预览方向</li></ul><h2 id="屏幕坐标方向"><a href="#屏幕坐标方向" class="headerlink" title="屏幕坐标方向"></a>屏幕坐标方向</h2><p>在Android系统中，以屏幕左上角为坐标系统的原点(0,0)坐标，该坐标系是固定不变的，不会因为设备方向的变化而改变。<br><img src="https://s2.ax1x.com/2020/01/31/11sOYQ.png" alt="屏幕坐标方向"></p><h2 id="屏幕自然方向"><a href="#屏幕自然方向" class="headerlink" title="屏幕自然方向"></a>屏幕自然方向</h2><p>每个设备都有一个自然方向，手机和平板自然方向不一样，如图所示，这里盗个图：<br><a href="https://imgchr.com/i/11ySO0"><img src="https://s2.ax1x.com/2020/01/31/11ySO0.md.png" alt="设备自然方向"></a><br>默认情况下，平板的自然方向是横屏，而手机的自然方向是竖屏方向。Android系统可以通过View的<code>OrientationEventListener</code>监听设备方向，回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOrientationChanged</span><span class="params">(<span class="type">int</span> orientation)</span>;</span><br></pre></td></tr></table></figure><p><code>onOrientationChanged</code>返回0到359的角度，其中0表示自然方向。</p><h2 id="摄像头传感器方向"><a href="#摄像头传感器方向" class="headerlink" title="摄像头传感器方向"></a>摄像头传感器方向</h2><p><a href="https://imgchr.com/i/11sXWj"><img src="https://s2.ax1x.com/2020/01/31/11sXWj.md.png" alt="摄像头传感器方向"></a><br>手机相机的图像数据都是来自于摄像头硬件的图像传感器，这个传感器在被固定到手机上后有一个默认的取景方向，方向一般是和手机横屏方向一致，如上图所示。  </p><h2 id="相机预览方向"><a href="#相机预览方向" class="headerlink" title="相机预览方向"></a>相机预览方向</h2><p>将摄像头传感器捕获的图像，显示在屏幕上的方向，就是相机预览方向。默认情况下，和摄像头传感器方向一致，可以通过Camera API进行改变。<br>Camaer1可以使用<code>setDisplayOrientation</code>设置预览方向，Camera2则可以通过TextureView来实现。<br>不同的摄像头位置，<code>orientation</code>是不一样的，orientation就是摄像头传感器方向顺时针旋转到屏幕自然方向的角度。</p><h3 id="后置"><a href="#后置" class="headerlink" title="后置"></a>后置</h3><p>后置的<code>orientation</code>90<br><a href="https://imgchr.com/i/18NuGt"><img src="https://s2.ax1x.com/2020/02/01/18NuGt.md.jpg" alt="后置"></a><br>对横屏来说，屏幕的自然方向和相机的摄像头传感器方向一致的。<br>对竖屏来说，看到的图像逆时针旋转了90度，因此预览方向需要顺时针旋转90度，才能与屏幕的自然方向保持一致。</p><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>前置的<code>orientation</code>270，收集到图像后(没有经过镜像处理)，但是要显示到屏幕上，就要按照屏幕自然方向的坐标系来进行显示，需要顺时针旋转270度，才能和设备自然方向一致。预览的时候，做了镜像处理，所以只需要顺时针旋转90度，就能和设置自然方向一致。<br>那么Camera1和Camera2具体设置预览方向的代码，来自<a href="https://github.com/google/cameraview">cameraview</a>：   </p><p><strong>Camera1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcDisplayOrientation</span><span class="params">(<span class="type">int</span> screenOrientationDegrees)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">360</span> - (mCameraInfo.orientation + screenOrientationDegrees) % <span class="number">360</span>) % <span class="number">360</span>;    <span class="comment">// compensate the mirror</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// back-facing</span></span><br><span class="line">        <span class="keyword">return</span> (mCameraInfo.orientation - screenOrientationDegrees + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中区分了前置和后置摄像头。   </p><ul><li>后置：<code>(mCameraInfo.orientation - screenOrientationDegrees + 360) % 360</code>，恢复到自然方向需要顺时针旋转，而屏幕逆时针旋转正好抵掉了摄像头的旋转，两者差值+360取模。</li><li>前置：<code>(mCameraInfo.orientation + screenOrientationDegrees) % 360</code>，屏幕竖直方向看到的是一个镜像，360-<code>(mCameraInfo.orientation + screenOrientationDegrees) % 360</code>，顺时针旋转这个差值可以到自然方向，只不过这是个镜像，左右翻转了</li></ul><p><strong>Camera2</strong><br>使用的TextureView的setTransform进行旋转，并有区分横竖屏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Configures the transform matrix for TextureView based on &#123;<span class="doctag">@link</span> #mDisplayOrientation&#125; and</span></span><br><span class="line"><span class="comment">* the surface size.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">configureTransform</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">    <span class="keyword">if</span> (mDisplayOrientation % <span class="number">180</span> == <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> getWidth();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> getHeight();</span><br><span class="line">        <span class="comment">// Rotate the camera preview when the screen is landscape.</span></span><br><span class="line">        matrix.setPolyToPoly(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">float</span>[]&#123;</span><br><span class="line">                        <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="comment">// top left</span></span><br><span class="line">                        width, <span class="number">0.f</span>, <span class="comment">// top right</span></span><br><span class="line">                        <span class="number">0.f</span>, height, <span class="comment">// bottom left</span></span><br><span class="line">                        width, height, <span class="comment">// bottom right</span></span><br><span class="line">                &#125;, <span class="number">0</span>,</span><br><span class="line">                mDisplayOrientation == <span class="number">90</span> ?</span><br><span class="line">                        <span class="comment">// Clockwise</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">float</span>[]&#123;</span><br><span class="line">                                <span class="number">0.f</span>, height, <span class="comment">// top left</span></span><br><span class="line">                                <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="comment">// top right</span></span><br><span class="line">                                width, height, <span class="comment">// bottom left</span></span><br><span class="line">                                width, <span class="number">0.f</span>, <span class="comment">// bottom right</span></span><br><span class="line">                        &#125; : <span class="comment">// mDisplayOrientation == 270</span></span><br><span class="line">                        <span class="comment">// Counter-clockwise</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">float</span>[]&#123;</span><br><span class="line">                                width, <span class="number">0.f</span>, <span class="comment">// top left</span></span><br><span class="line">                                width, height, <span class="comment">// top right</span></span><br><span class="line">                                <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="comment">// bottom left</span></span><br><span class="line">                                <span class="number">0.f</span>, height, <span class="comment">// bottom right</span></span><br><span class="line">                        &#125;, <span class="number">0</span>,</span><br><span class="line">                <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDisplayOrientation == <span class="number">180</span>) &#123;</span><br><span class="line">        matrix.postRotate(<span class="number">180</span>, getWidth() / <span class="number">2</span>, getHeight() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mTextureView.setTransform(matrix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拍照方向"><a href="#拍照方向" class="headerlink" title="拍照方向"></a>拍照方向</h2><p>设置预览方向并不会改变拍出照片的方向。<br>对于后置相机，相机采集到的图像和相机预览的图像是一样的，只需要旋转后置相机orientation度。<br>对于前置相机来说，相机预览的图像和相机采集到的图像是镜像关系。<br>采集的图像：顺时针旋转270度后，与屏幕自然方向一致。<br>预览的图像：顺时针旋转90度后，与屏幕自然方向一致。<br>最后盗用一张图来说明：<br><img src="https://s2.ax1x.com/2020/02/01/18NlM8.jpg" alt="拍照方向"></p><h3 id="Camera1-3"><a href="#Camera1-3" class="headerlink" title="Camera1"></a>Camera1</h3><p>使用<code>mCameraParameters.setRotation()</code>设置拍照后图像方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mCameraParameters.setRotation(calcCameraRotation(displayOrientation));</span><br><span class="line">......</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calculate camera rotation</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This calculation is applied to the output JPEG either via Exif Orientation tag</span></span><br><span class="line"><span class="comment">* or by actually transforming the bitmap. (Determined by vendor camera API implementation)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note: This is not the same calculation as the display orientation</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> screenOrientationDegrees Screen orientation in degrees</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> Number of degrees to rotate image in order for it to view correctly.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcCameraRotation</span><span class="params">(<span class="type">int</span> screenOrientationDegrees)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">        <span class="keyword">return</span> (mCameraInfo.orientation + screenOrientationDegrees) % <span class="number">360</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// back-facing</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">landscapeFlip</span> <span class="operator">=</span> isLandscape(screenOrientationDegrees) ? <span class="number">180</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (mCameraInfo.orientation + screenOrientationDegrees + landscapeFlip) % <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相机采集到的图像，只需要旋转相机orientation度。</p><h3 id="Camera2-3"><a href="#Camera2-3" class="headerlink" title="Camera2"></a>Camera2</h3><p>根据<code>CameraCharacteristics.SENSOR_ORIENTATION</code>，使用<code>captureRequest</code>设置了JPEG图像的旋转方向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculate JPEG orientation.</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;ConstantConditions&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sensorOrientation</span> <span class="operator">=</span> mCameraCharacteristics.get(</span><br><span class="line">        CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line">captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION,</span><br><span class="line">        (sensorOrientation +</span><br><span class="line">                mDisplayOrientation * (mFacing == Constants.FACING_FRONT ? <span class="number">1</span> : -<span class="number">1</span>) +</span><br><span class="line">                <span class="number">360</span>) % <span class="number">360</span>);</span><br></pre></td></tr></table></figure><h1 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h1><p>Android Camera默认返回的数据格式是NV21。Camera1通过<code>mParameters.setPreviewFormat()</code>设置，Camera2通过<code>ImageReader.newInstance()</code>设置。<br>ImageFormat枚举了很多种图片格式，其中ImageFormat.NV21和ImageFormat.YV12是官方推荐的格式，NV21、YV12格式都属于 YUV 格式，也可以表示为YCbCr，Cb、Cr的含义等同于U、V。   </p><h3 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3><p>YUV是一种颜色编码方法，和它类似的还有RGB颜色编码方法，主要应用于电视系统和模拟视频领域。其中YUV代表三个分量，Y 代表明亮度，U 和 V 表示的是色度，色度又定义了颜色的两个方面：色调和饱和度。将Y与UV分离，没有UV信息一样可以显示完整的图像，但是只能显示灰度图。   </p><h3 id="YUV采样格式"><a href="#YUV采样格式" class="headerlink" title="YUV采样格式"></a>YUV采样格式</h3><p>YUV 图像的主流采样方式有如下三种：</p><ul><li>YUV 4:4:4 采样：每一个Y对应一组UV分量</li><li>YUV 4:2:2 采样：每两个Y共用一组UV分量</li><li>YUV 4:2:0 采样：每四个Y共用一组UV分量</li></ul><p>盗个图说明比较清晰，黑点表示采样该像素点的Y分量，空心圆圈表示采用该像素点的UV分量<br><a href="https://imgchr.com/i/1G8a5t"><img src="https://s2.ax1x.com/2020/02/01/1G8a5t.md.jpg" alt="YUV"></a></p><h3 id="YUV存储格式"><a href="#YUV存储格式" class="headerlink" title="YUV存储格式"></a>YUV存储格式</h3><p>有两种存储格式，planar和packed。</p><ul><li>planar：先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V</li><li>packed：每个像素点的Y,U,V是连续交替存储</li></ul><p>YUV格式信息可以参考：<a href="https://www.fourcc.org/yuv.php">YUV pixel formats</a><br>根据采样方式和存储格式的不同，形成了多种YUV格式，常见的YUV格式：</p><table><thead><tr><th align="center">采样&#x2F;格式</th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="center">YUV422</td><td>YUVY 格式</td><td>UYVY 格式</td><td>YUV422P 格式</td></tr><tr><td align="center">YUV420</td><td>YUV420P<br>(YV12、YU12格式)</td><td>YUV420P<br>(NV12、NV21格式)</td><td></td></tr></tbody></table><h4 id="YUVY格式"><a href="#YUVY格式" class="headerlink" title="YUVY格式"></a>YUVY格式</h4><p>YUVY格式属于packed存储格式，相邻的两个Y共用其相邻的两个U、V</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y0 UO Y1 V0 Y2 U2 Y3 V2</span><br></pre></td></tr></table></figure><p>Y0、Y1共用 U0、V0<br>Y2、Y3共用 U2、V2</p><h4 id="UYVY格式"><a href="#UYVY格式" class="headerlink" title="UYVY格式"></a>UYVY格式</h4><p>UYVY格式也属于packed存储格式，与YUYV格式不同的是UV的排列顺序不一样而已</p><h4 id="YUV422P格式"><a href="#YUV422P格式" class="headerlink" title="YUV422P格式"></a>YUV422P格式</h4><p>YUV422P格式属于planar存储格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V</p><h4 id="YV12、YU12格式"><a href="#YV12、YU12格式" class="headerlink" title="YV12、YU12格式"></a>YV12、YU12格式</h4><p>YU12和YV12格式都属于YUV420P格式，YUV420P是planar存储格式。先存储所有Y，然后在存储U、V。<br>YU12和YV12的区别在于YU12是先Y再U后V，而YV12是先Y再V后U。</p><h4 id="NV12、NV21格式"><a href="#NV12、NV21格式" class="headerlink" title="NV12、NV21格式"></a>NV12、NV21格式</h4><p>NV12、NV21格式YUV420SP格式，YUV420SP也是planar存储格式。先存储所有Y，然后按照UV或者VU的交替顺序进行存储。<br>NV12格式先存储Y，然后UV再进行交替存储。<br>NV21格式则是先存储Y，然后VU再进行交替存储。<br>最后盗用一个数据格式的总结：   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YV21: YYYYYYYY UU VV =&gt; YUV420P   </span><br><span class="line">YV12: YYYYYYYY VV UU =&gt; YUV420P   </span><br><span class="line">NV12: YYYYYYYY UV UV =&gt; YUV420SP   </span><br><span class="line">NV21: YYYYYYYY VU VU =&gt; YUV420SP</span><br></pre></td></tr></table></figure><p>Android Camera 默认数据格式是 NV21，Camera1直接设置<code>mParameters.setPreviewFormat(ImageFormat.NV21)</code>，然后拍照回调中的 raw data 数据返回就是 NV21的。<br>Camera2通过<code>ImageReader.newInstance()</code>设置，但是不能直接设置格式<code>ImageFormat.NV21</code>，在源码中有段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (format == ImageFormat.NV21) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">            <span class="string">&quot;NV21 format is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最新的<code>ImageFormat.NV21</code>上有说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YCrCb format used <span class="keyword">for</span> images, which uses the NV21 encoding format.   </span><br><span class="line">This is the <span class="keyword">default</span> format <span class="keyword">for</span> android.hardware.Camera preview images,</span><br><span class="line">when not otherwise set with android.hardware.Camera.Parameters.setPreviewFormat(<span class="type">int</span>).</span><br><span class="line">For the android.hardware.camera2 API, the YUV_420_888 format is recommended <span class="keyword">for</span> YUV output instead.</span><br></pre></td></tr></table></figure><p>Camera2建议使用<code>YUV_420_888</code>来替代，所以要得到NV21的数据需要进行数据转化，具体可以参考<a href="https://www.polarxiong.com/archives/Android-Image%E7%B1%BB%E6%B5%85%E6%9E%90-%E7%BB%93%E5%90%88YUV_420_888.html">Image类浅析(结合YUV_420_888)</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/xx326664162/article/details/53350551">Android相机开发和遇到的坑</a></li><li><a href="https://www.jianshu.com/p/067889611ae7">Android Camera2 教程 · 第三章 · 预览</a></li><li><a href="https://glumes.com/post/android/android-camera-aspect-ratio-and-orientation/">Android 相机开发中的尺寸和方向问题</a></li><li><a href="https://blog.csdn.net/tencent_bugly/article/details/53375311">【腾讯优测干货分享】Android 相机预览方向及其适配探索</a></li><li><a href="https://juejin.im/post/5ce497285188252dd500c304">一文读懂 YUV 的采样与格式</a></li><li><a href="https://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html">图文详解YUV420数据格式</a></li><li><a href="https://www.polarxiong.com/archives/Android-Image%E7%B1%BB%E6%B5%85%E6%9E%90-%E7%BB%93%E5%90%88YUV_420_888.html">Image类浅析(结合YUV_420_888)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面几篇文章介绍了Camera1，Camera2，CameraView和CameraX的使用，对各个API的使用，应该问题不大，不过在真正开发过程中，也会遇到各种不同的问题，本篇文章继续介绍相机开发过程中遇到的问题，主要是相机预览、拍照尺寸，方向，以及图像数据的处理。&lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="Orientation" scheme="http://yeungeek.github.io/tags/Orientation/"/>
    
  </entry>
  
</feed>
