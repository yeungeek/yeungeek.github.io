<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yeungeek</title>
  <icon>https://www.gravatar.com/avatar/0a7bd4cded6dbbd2a98de3e1269895c0</icon>
  <subtitle>技术沉思录</subtitle>
  <link href="http://yeungeek.github.io/atom.xml" rel="self"/>
  
  <link href="http://yeungeek.github.io/"/>
  <updated>2023-09-27T11:45:23.482Z</updated>
  <id>http://yeungeek.github.io/</id>
  
  <author>
    <name>Yeungeek</name>
    <email>yeungeek@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenGLES 3.0 - 简介和基础绘制流程</title>
    <link href="http://yeungeek.github.io/2023/08/02/OpenGL-Intro/"/>
    <id>http://yeungeek.github.io/2023/08/02/OpenGL-Intro/</id>
    <published>2023-08-02T11:15:53.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><p><img src="https://s1.ax1x.com/2023/08/13/pPK8x4P.jpg" alt="pPK8x4P.jpg"><br><a href="https://www.opengl.org/">OpenGL(Open Graphics Library,开放图形库)</a>，是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口规范。<br>它本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范（Specification）。它的实现由显示设备厂商提供，并且非常依赖该厂商提供的硬件。<br>当你使用Apple系统的时候，OpenGL库是由Apple维护的。在Windows上，OpenGL库可能是Direct3D接口的一个封装(Wrapper)。表面上调用OpenGL接口，实际上是间接调用了Direct3D接口。</p><span id="more"></span><p>像现在非常火爆的GPU生产商Nvidia，会提供满足OpenGL规范的实现，它们负责将OpenGL定义的API命令翻译为GPU指令。<br>OpenGL应用场景广泛，通常用于CAD、科学可视化、游戏开发等，像游戏开发引擎Unity,Unreal底层渲染引擎都是基于OpenGL，当然也支持Vulkan。</p><h2 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h2><p><img src="https://s1.ax1x.com/2023/08/13/pPKULDS.png"><br><a href="https://www.khronos.org/opengles">OpenGL ES(OpenGL for Embedded Systems)</a>，是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。本系列文章介绍OpenGL版本基于OpenGL ES3.0， 是OpenGLES 2.0的扩展版本，向下兼容OpenGLES 2.0 ，但不兼容OpenGLES 1.0。</p><h3 id="3-0主要新特性"><a href="#3-0主要新特性" class="headerlink" title="3.0主要新特性"></a>3.0主要新特性</h3><h4 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h4><ul><li>sRGB 纹理和帧缓冲区 - 允许应用程序执行伽玛校正渲染</li><li>2D纹理数组 - 存储2D纹理数组的纹理目标</li><li>3D纹理 - OpenGL ES 3.0中作为强制功能</li><li>深度纹理和阴影比较 - 允许将深度缓冲区存储在纹理中</li><li>无缝立方体贴图 - 在OpenGL ES 2.0中，使用立方体贴图进行渲染可能会在立方体贴图面之间的边界处产生伪影。在OpenGL ES 3.0中，可以对立方体贴图进行采样，以便过滤使用来自相邻面的数据并消除接缝伪影</li><li>浮点纹理 - OpenGL ES 3.0极大地扩展了支持的纹理格式</li><li>ETC2&#x2F;EAC 纹理压缩</li><li>整数纹理 - OpenGL ES 3.0引入了渲染和提取存储为非标准化有符号或无符号8位、16位和32位整数纹理的纹理的功能</li><li>其他纹理格式</li><li>纹理混合 - 引入了新的纹理对象状态，以允许独立控制纹理数据的每个通道（R、G、B 和 A）在着色器中映射到的位置</li><li>不可变纹理 — 为应用程序提供一种机制，在加载数据之前指定纹理的格式和大小</li><li>增加了最小尺寸 - OpenGL ES 3.0 最小2D纹理尺寸为2048</li></ul><h4 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h4><ul><li>程序二进制文件 - 在 OpenGL ES 3.0中，整个链接程序二进制文件（包含顶点和片段着色器）可以以离线二进制格式存储，运行时无需链接步骤</li><li>强制在线编译器</li><li>非方阵 - 支持方阵以外的新矩阵类型，并且将关联的统一调用添加到API中以支持加载它们</li><li>完整整数支持</li><li>质心采样</li><li>平面&#x2F;平滑插值程序</li><li>统一变量块 - 统一变量值可以组合为统一变量块。统一变量块可以更高效地加载，也可在多个着色器程序间共享</li><li>布局限定符</li><li>实例和顶点ID</li><li>片段深度 - 片段着色器可以显式控制当前片段的深度值，而不是依赖于其深度值的插值</li><li>新的内置函数</li><li>放宽限制 - OpenGL ES 3.0放宽了对着色器的限制。着色器不再受指令长度限制，完全支持变量循环和分支，并支持数组索引</li></ul><h4 id="几何形状"><a href="#几何形状" class="headerlink" title="几何形状"></a>几何形状</h4><ul><li>变换反馈 - 允许在缓冲区对象中捕获顶点着色器的输出</li><li>布尔遮挡查询</li><li>实例化渲染 - 高效渲染包含相似几何图形但属性（例如变换矩阵、颜色或大小）不同的对象</li><li>图元重新启动</li><li>新的顶点格式 - 新的顶点格式，包括10-10-10-2有符号和无符号标准化顶点属性</li></ul><h4 id="缓冲区对象"><a href="#缓冲区对象" class="headerlink" title="缓冲区对象"></a>缓冲区对象</h4><ul><li>统一缓冲区对象 - 提供存储&#x2F;绑定大块统一的有效方法</li><li>顶点数组对象 - 提供一种有效的方法来绑定和切换顶点数组状态</li><li>采样器对象 - 将采样器状态（纹理环绕模式和过滤）与纹理对象分开</li><li>同步对象 - 为应用程序提供一种机制来检查一组 OpenGL ES 操作是否已在GPU上完成执行</li><li>像素缓冲区对象 - 使应用程序能够执行数据到像素操作和纹理传输操作的异步传输</li><li>缓冲区子范围映射 - 允许应用程序映射缓冲区的子区域以供CPU访问</li><li>缓冲区对象间拷贝</li></ul><h4 id="帧缓冲区"><a href="#帧缓冲区" class="headerlink" title="帧缓冲区"></a>帧缓冲区</h4><ul><li>多个渲染目标(MRT) — 允许应用程序一次同时渲染到多个颜色缓冲区</li><li>多重采样渲染缓冲区 - 使应用程序能够通过多重采样抗锯齿渲染到离屏帧缓冲区</li><li>帧缓冲区失效提示 </li><li>新的混合方程 - OpenGL ES 3.0支持最小&#x2F;最大函数作为混合方程</li></ul><h1 id="OpenGL绘制流程"><a href="#OpenGL绘制流程" class="headerlink" title="OpenGL绘制流程"></a>OpenGL绘制流程</h1><p>本系列是基于Android的OpenGL，绘制使用了GLSurfaceView，具体的渲染实现使用JNI实现。<br>使用GLSurfaceView，需要设置一个Renderer，整个渲染流程是由Renderer实现，主要实现三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">open <span class="keyword">class</span> <span class="title class_">ShaderRenderer</span>(sample: Sample) : Renderer &#123;</span><br><span class="line">    <span class="keyword">private</span> val nativeRender: ShaderNativeRender</span><br><span class="line">    <span class="keyword">private</span> val mSample:Sample</span><br><span class="line">    init &#123;</span><br><span class="line">        nativeRender = ShaderNativeRender()</span><br><span class="line">        mSample = sample</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onSurfaceCreated</span><span class="params">(gl: GL10?, config: EGLConfig?)</span> &#123;</span><br><span class="line">        <span class="comment">// GLSurfaceView视图创建时候调用</span></span><br><span class="line">        nativeRender.native_OnSurfaceCreated()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onSurfaceChanged</span><span class="params">(gl: GL10?, width: Int, height: Int)</span> &#123;</span><br><span class="line">        <span class="comment">// GLSurfaceView视图改变时调用</span></span><br><span class="line">        nativeRender.native_OnSurfaceChanged(width,height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onDrawFrame</span><span class="params">(gl: GL10?)</span> &#123;</span><br><span class="line">        <span class="comment">// 每帧调用</span></span><br><span class="line">        nativeRender.native_OnDrawFrame()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        nativeRender.native_Init(mSample.id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        nativeRender.native_UnInit()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Native，JNI的声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShaderNativeRender</span>() &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        init &#123;</span><br><span class="line">            System.loadLibrary(<span class="string">&quot;shader-render&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_Init</span><span class="params">(id:Int)</span></span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_UnInit</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_OnSurfaceCreated</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_OnSurfaceChanged</span><span class="params">(width: Int, height: Int)</span></span><br><span class="line"></span><br><span class="line">    external fun <span class="title function_">native_OnDrawFrame</span><span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNI层的部分实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderContext::OnSurfaceCreated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;###### ShaderContext OnSurfaceCreated&quot;</span>);</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderContext::OnSurfaceChanged</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;###### ShaderContext OnSurfaceChanged,w=%d,h=%d&quot;</span>, width, height);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderContext::OnDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p>学习OpenGL，渲染流程是非常重要的，下图是图形渲染管线每个阶段的抽象展示<br><img src="/2023/08/02/OpenGL-Intro/pipeline.png"><br>开始绘制之前，需要提供给OpenGL一些顶点数据，作为顶点输入，接下来就是图形渲染管线的第一部分 - 顶点着色器。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器(Vertex Shader)是几个可编程着色器中的一个，主要作用是<code>确定绘制图形的形状</code>。<br>定义一个着色器程序，需要通过GLSL(OpenGL Shading Language)语言来编写，下面这段是非常典型的顶点着色器源码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>in</code>关键字定义输入顶点属性，把位置数据赋值给预定义的<code>gl_Position</code>变量，设置的值会成为该顶点着色器的输出。</p><h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>输入的数据，就是上一个阶段顶点着色器输出的所有顶点，并将输入的数据装配成指定图元的形状。图元的类型：点、线、三角形，其他复杂的图形都是由这三种基本的图形组成。</p><h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>几何着色器把图元形式的一系列顶点的集合作为输入，通过对输入的顶点进行处理，会决定输出的图元类型和个数。</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>这个阶段会把图元映射为最终屏幕上的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>主要目的是计算一个像素的最终颜色，这是另外一个可编程的着色器。</p><h3 id="测试与混合"><a href="#测试与混合" class="headerlink" title="测试与混合"></a>测试与混合</h3><p>这个阶段检测片段的深度，判断像素和其他物体的前后关系，确定是否丢弃，检查Alpha值并对物体进行混合。</p><p>可以看到渲染管线是非常复杂的，包含了很多可配置的部分。其中顶点着色器和片段着色器是可编程，也是我们需要关注的。几何着色器是可选，一般使用默认即可。</p><h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><h3 id="定义着色器"><a href="#定义着色器" class="headerlink" title="定义着色器"></a>定义着色器</h3><p>顶点着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec4</span> vPosition;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = vPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> fragColor;</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fragColor = <span class="type">vec4</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编译OpenGL程序"><a href="#编译OpenGL程序" class="headerlink" title="编译OpenGL程序"></a>编译OpenGL程序</h3><p>根据顶点和片段着色器类型，创建和编译着色器程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据不同的类型创建着色器ID</span></span><br><span class="line">GLuint shader = <span class="built_in">glCreateShader</span>(shaderType);</span><br><span class="line"><span class="keyword">if</span> (shader) &#123;</span><br><span class="line">    <span class="comment">//将着色器ID和内容连接</span></span><br><span class="line">    <span class="built_in">glShaderSource</span>(shader, <span class="number">1</span>, &amp;source, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//编译着色器</span></span><br><span class="line">    <span class="built_in">glCompileShader</span>(shader);</span><br><span class="line"></span><br><span class="line">    GLint compiled = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//检查是否编译成功</span></span><br><span class="line">    <span class="built_in">glGetShaderiv</span>(shader, GL_COMPILE_STATUS, &amp;compiled);</span><br><span class="line">    <span class="keyword">if</span> (!compiled) &#123;</span><br><span class="line">        GLint infoLen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">glGetShaderiv</span>(shader, GL_INFO_LOG_LENGTH, &amp;infoLen);</span><br><span class="line">        <span class="keyword">if</span> (infoLen) &#123;</span><br><span class="line">            <span class="type">char</span> *buf = (<span class="type">char</span> *) <span class="built_in">malloc</span>((<span class="type">size_t</span>) infoLen);</span><br><span class="line">            <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">                <span class="comment">//获取错误消息</span></span><br><span class="line">                <span class="built_in">glGetShaderInfoLog</span>(shader, infoLen, <span class="literal">NULL</span>, buf);</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="string">&quot;###### LoadShader compiled error %d, \n%s&quot;</span>, shaderType, buf);</span><br><span class="line">                <span class="built_in">free</span>(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">glDeleteShader</span>(shader);</span><br><span class="line">            shader = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GLuint glCreateShader(GLenum shaderType)：根据不同的类型创建着色器ID</li><li>void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)：<br>将着色器ID和内容连接</li><li>void glCompileShader(GLuint shader)：编译着色器</li><li>void glGetShaderiv(GLuint shader, GLenum pname, GLint *params)：检查编译是否成功</li><li>void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog)：<br>获取错误消息</li></ul><h3 id="创建OpenGL程序和链接着色器"><a href="#创建OpenGL程序和链接着色器" class="headerlink" title="创建OpenGL程序和链接着色器"></a>创建OpenGL程序和链接着色器</h3><p>接下来就是创建OpenGL程序，并链接着色器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line"><span class="built_in">LOGD</span>(<span class="string">&quot;###### Create Program Result: %d&quot;</span>, program);</span><br><span class="line"><span class="keyword">if</span> (program) &#123;</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, vertexShaderId);</span><br><span class="line">    <span class="built_in">CheckGLError</span>(<span class="string">&quot;glAttachShader&quot;</span>);</span><br><span class="line">    <span class="built_in">glAttachShader</span>(program, fragmentShaderId);</span><br><span class="line">    <span class="built_in">CheckGLError</span>(<span class="string">&quot;glAttachShader&quot;</span>);</span><br><span class="line">    <span class="comment">//链接OpenGL程序</span></span><br><span class="line">    <span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">    GLint linkResult = GL_FALSE;</span><br><span class="line">    <span class="built_in">glGetProgramiv</span>(program, GL_LINK_STATUS, &amp;linkResult);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GLuint glCreateProgram(void)：创建程序</li><li>void glAttachShader(GLuint program, GLuint shader)：将指定的shader附着到指定的program对象上</li><li>void glLinkProgram(GLuint program)：链接OpenGL程序</li></ul><h3 id="使用OpenGL程序"><a href="#使用OpenGL程序" class="headerlink" title="使用OpenGL程序"></a>使用OpenGL程序</h3><p>接着调用<code>glUseProgram</code>，创建的程序对象作为它的参数，之后每个着色器调用和渲染调用都会使用这个程序对象。</p><ul><li>void glUseProgram(GLuint program)：使用OpenGL程序</li></ul><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>最后一步就是绘制流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (mProgram == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear</span></span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//load vertex data</span></span><br><span class="line"><span class="comment">//设置顶点属性数据</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, stride, mVertices);</span><br><span class="line"><span class="comment">//启用顶点属性</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//draw</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glDisableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer)：<br>定义通用顶点属性数据<ul><li>index：配置的顶点属性，opengl3.0在顶点着色器定义的<code>layout(location=0)</code>表示位置为0</li><li>size：顶点属性的大小，顶点属性vec3，这个值就是3</li><li>type：数据的类型，<code>GL_FLOAT</code>表示是浮点数值</li><li>normalized：是否归一化</li><li>stride：步长，连续的顶点属性组之间的间隔。设置为0，则是让OpenGL决定具体的步长</li><li>pointer：表示位置数据在缓冲中起始位置的偏移量(Offset)</li></ul></li><li>void glEnableVertexAttribArray(GLuint index)：启用通用顶点属性数组，允许顶点着色器读取GPU数据</li><li>void glDrawArrays(GLenum mode, GLint first, GLsizei count)：绘制图形<ul><li>mode：绘制类型，包含<code>GL_POINTS</code>、<code>GL_LENS</code>、<code>GL_TRIANGLE</code>等</li></ul></li></ul><p><img src="/2023/08/02/OpenGL-Intro/draw_mode.jpeg"><br>这个就是OpenGL的整体绘制流程，遵循了GPU的渲染管线流程。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.opengl.org/">OpenGL</a></li><li><a href="https://www.khronos.org/opengles/">OpenGL ES</a></li><li><a href="https://learnopengl-cn.github.io/">Learn OpenGL</a></li><li><a href="https://juejin.cn/post/7119135465302654984">一看就懂的OpenGL ES教程——图形渲染管线的那些事</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;OpenGL&quot;&gt;&lt;a href=&quot;#OpenGL&quot; class=&quot;headerlink&quot; title=&quot;OpenGL&quot;&gt;&lt;/a&gt;OpenGL&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/08/13/pPK8x4P.jpg&quot; alt=&quot;pPK8x4P.jpg&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://www.opengl.org/&quot;&gt;OpenGL(Open Graphics Library,开放图形库)&lt;/a&gt;，是用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口规范。&lt;br&gt;它本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范（Specification）。它的实现由显示设备厂商提供，并且非常依赖该厂商提供的硬件。&lt;br&gt;当你使用Apple系统的时候，OpenGL库是由Apple维护的。在Windows上，OpenGL库可能是Direct3D接口的一个封装(Wrapper)。表面上调用OpenGL接口，实际上是间接调用了Direct3D接口。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL教程</title>
    <link href="http://yeungeek.github.io/2023/08/02/OpenGL-Tutorials/"/>
    <id>http://yeungeek.github.io/2023/08/02/OpenGL-Tutorials/</id>
    <published>2023-08-02T10:25:45.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL的概念，相信大家都听说过，应用场景非常广泛，音视频、图形渲染、游戏等等。学习OpenGL是有一定的门槛，期间也看过很多其他OpenGL教程，有些写的是非常不错的，例如<a href="https://learnopengl.com/">LearnOpenGL</a>，能够系统性的学习OpenGL概念和应用。本系列教程，主要会从Android OpenGL ES入手，系统性的介绍图形学渲染技术，结合音视频进行相关应用，并分析两个教科书级别的项目，更加巩固OpenGL技术。</p><span id="more"></span><p><strong>本系列教程：</strong></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol><li><a href="/2023/08/02/OpenGL-Intro/">OpenGLES 3.0 - 简介和基础绘制流程</a></li><li>OpenGLES 3.0 - 基本形状的绘制</li><li>OpenGLES 3.0 - 着色器语言GLSL</li><li>OpenGLES 3.0 - 纹理映射</li><li>OpenGLES 3.0 - 坐标系统</li><li>OpenGLES 3.0 - EGL详解</li><li>OpenGLES 3.0 - VBO、EBO 和 VAO</li><li>OpenGLES 3.0 - FBO离屏渲染</li><li>OpenGLES 3.0 - PBO</li><li>OpenGLES 3.0 - UBO和TBO</li><li>OpenGLES 3.0 - 相机预览</li><li>OpenGLES 3.0 - 相机基础滤镜</li><li>OpenGLES 3.0 - 3D模型</li><li>OpenGLES 3.0 - 3D模型加载和渲染</li></ol><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><ol><li>AudioVideoRecording源码分析</li><li>Grafika源码分析</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s/26BywT1MbM20zybeWD12mw">全网最全的 Android 音视频和 OpenGL ES 干货</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4MjU1MDk3Ng==&action=getalbum&album_id=1337181710408302593&scene=173&from_msgid=2451526136&from_itemidx=1&count=3&nolastread=1#wechat_redirect">OpenGL专题</a></li><li><a href="https://cstsinghua.github.io/2018/07/12/openGL%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/">OpenGL学习路径</a></li><li><a href="https://zhuanlan.zhihu.com/p/553509106">图形渲染学习路线</a></li><li><a href="https://glumes.com/android-av-beginner-resource/">推荐几个堪称教科书级别的 Android 音视频入门项目</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;OpenGL的概念，相信大家都听说过，应用场景非常广泛，音视频、图形渲染、游戏等等。学习OpenGL是有一定的门槛，期间也看过很多其他OpenGL教程，有些写的是非常不错的，例如&lt;a href=&quot;https://learnopengl.com/&quot;&gt;LearnOpenGL&lt;/a&gt;，能够系统性的学习OpenGL概念和应用。本系列教程，主要会从Android OpenGL ES入手，系统性的介绍图形学渲染技术，结合音视频进行相关应用，并分析两个教科书级别的项目，更加巩固OpenGL技术。&lt;/p&gt;</summary>
    
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/categories/OpenGL/"/>
    
    
    <category term="OpenGL" scheme="http://yeungeek.github.io/tags/OpenGL/"/>
    
    <category term="OpenGLES" scheme="http://yeungeek.github.io/tags/OpenGLES/"/>
    
    <category term="Video" scheme="http://yeungeek.github.io/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>Android知识体系</title>
    <link href="http://yeungeek.github.io/2020/05/09/Android-Knowledge-System/"/>
    <id>http://yeungeek.github.io/2020/05/09/Android-Knowledge-System/</id>
    <published>2020-05-09T10:13:46.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>建立一套比较完整的 Android 知识体系，对Android开发或者面试都有裨益，以及后面对某个垂直领域的深入，或者成为该领域的技术专家，甚至是架构师，也有一定的路线指导作用。<br>夯实基础是重中之重，深入某个垂直领域，都是根据当前的业务需求，一步步深入，从而成为该领域专家。<br>下面列表的内容，都是经过实例验证，做到真正掌握才会写到自己的博客里。比较完整的提纲是在最后的思维导图中，提纲中的内容，如果经过了自己验证，就会更新到博客里(持续更新)。 </p><span id="more"></span><h1 id="Android基础"><a href="#Android基础" class="headerlink" title="Android基础"></a>Android基础</h1><h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h2 id="View体系"><a href="#View体系" class="headerlink" title="View体系"></a>View体系</h2><h2 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h2><ul><li><a href="/2019/08/21/AndroidNDK-DeepUnderstandJNI/">Android NDK-深入理解JNI</a></li></ul><h1 id="Android框架层-Framework"><a href="#Android框架层-Framework" class="headerlink" title="Android框架层(Framework)"></a>Android框架层(Framework)</h1><h1 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><ul><li><a href="/2019/07/17/Network-OKHttp/">Android网络编程-OKHttp源码角度分析Http</a></li></ul><h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><ul><li><a href="/2019/07/25/Network-Retrofit/">Android网络编程-Retrofit源码角度分析Http</a></li></ul><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h1 id="推荐资源"><a href="#推荐资源" class="headerlink" title="推荐资源"></a>推荐资源</h1><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li><a href="https://item.jd.com/11760209.html">《Android开发艺术探索》</a></li><li><a href="https://item.jd.com/12438713.html">《Android进阶解密》</a></li></ul><h2 id="在线课程"><a href="#在线课程" class="headerlink" title="在线课程"></a>在线课程</h2><ul><li><a href="https://time.geekbang.org/column/intro/142">Android开发高手课</a></li><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=67">Android 工程师进阶 34 讲</a></li><li><a href="https://time.geekbang.org/column/intro/100010301">深入拆解Java虚拟机</a></li></ul><h1 id="Android知识体系"><a href="#Android知识体系" class="headerlink" title="Android知识体系"></a>Android知识体系</h1><p>思维导图的内容并不是需要全部掌握，根据当前的业务需求，在某些领域进行深入，不过基础是必须掌握的。<br><img src="https://s1.ax1x.com/2020/05/10/Y8cqc8.png" alt="Y8cqc8.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/henrymorgen/android-knowledge-system">Android应用开发原创知识体系</a></li><li><a href="https://blog.csdn.net/carson_ho/article/details/89838873">请收好这一份全面 &amp; 详细的Android学习指南</a></li><li><a href="https://mp.weixin.qq.com/s/rJkxRDlor1ZUfdmfwvqwNg">这些年“崛起”的Android技术博主们</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;建立一套比较完整的 Android 知识体系，对Android开发或者面试都有裨益，以及后面对某个垂直领域的深入，或者成为该领域的技术专家，甚至是架构师，也有一定的路线指导作用。&lt;br&gt;夯实基础是重中之重，深入某个垂直领域，都是根据当前的业务需求，一步步深入，从而成为该领域专家。&lt;br&gt;下面列表的内容，都是经过实例验证，做到真正掌握才会写到自己的博客里。比较完整的提纲是在最后的思维导图中，提纲中的内容，如果经过了自己验证，就会更新到博客里(持续更新)。 &lt;/p&gt;</summary>
    
    
    
    <category term="Android框架层" scheme="http://yeungeek.github.io/categories/Android%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
    
    <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-CameraX源码分析</title>
    <link href="http://yeungeek.github.io/2020/02/28/AndroidCamera-CameraXSource/"/>
    <id>http://yeungeek.github.io/2020/02/28/AndroidCamera-CameraXSource/</id>
    <published>2020-02-28T21:35:11.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>在前面一篇文章中，已经介绍了如何使用 CameraX，这篇文章就分析下 CameraX 主要流程的源码。</p><span id="more"></span><p>本篇分析的源码版本是1.0.0-alpha06，目前最新的 CameraX 版本是<a href="https://developer.android.com/jetpack/androidx/releases/camera">1.0.0-alpha10</a>。  </p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>在 build.gradle 中声明</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> camerax_version = <span class="string">&quot;1.0.0-alpha06&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-core:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-camera2:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> camerax_view_version = <span class="string">&quot;1.0.0-alpha03&quot;</span></span><br><span class="line"><span class="keyword">def</span> camerax_ext_version = <span class="string">&quot;1.0.0-alpha03&quot;</span></span><br><span class="line"><span class="comment">//other</span></span><br><span class="line"><span class="comment">// If you to use the Camera View class</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-view:$camerax_view_version&quot;</span></span><br><span class="line"><span class="comment">// If you to use Camera Extensions</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-extensions:$camerax_ext_version&quot;</span></span><br></pre></td></tr></table></figure><ul><li>camera-core：Camera核心库，设计架构的实现</li><li>camera-camera2：Camera2的配置和操作封装</li><li>camera-view：自定义的 CameraView 组件</li><li>camera-extensions：Camera的扩展，用于访问设备专属供应商效果（例如散景、HDR 及其他功能）的 API</li></ul><p>其中<code>camera-core</code>和<code>camera-camera2</code>是必须使用的库，使用该库，可以轻松地使用Camera2 API的功能</p><h1 id="CameraX结构"><a href="#CameraX结构" class="headerlink" title="CameraX结构"></a>CameraX结构</h1><p>首先看下 CameraX 的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CameraX</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraX</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">CameraRepository</span> <span class="variable">mCameraRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraRepository</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicBoolean</span> <span class="variable">mInitialized</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">UseCaseGroupRepository</span> <span class="variable">mUseCaseGroupRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UseCaseGroupRepository</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ErrorHandler</span> <span class="variable">mErrorHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorHandler</span>();</span><br><span class="line"><span class="keyword">private</span> CameraFactory mCameraFactory;</span><br><span class="line"><span class="keyword">private</span> CameraDeviceSurfaceManager mSurfaceManager;</span><br><span class="line"><span class="keyword">private</span> UseCaseConfigFactory mDefaultConfigFactory;</span><br><span class="line"><span class="keyword">private</span> Context mContext;</span><br></pre></td></tr></table></figure><p>主要看其中几个重要属性： </p><ul><li>CameraRepository：Camera仓库，保存可用 Camera 的列表</li><li>UseCaseGroupRepository：UseCaseGroupLifecycleController实例仓库，每个UseCaseGroupLifecycleController都与一个LifecycleOwner相关联，该LifecycleOwner调节组中所有用例共享的通用生命周期</li><li>CameraFactory：Camera抽象工厂，Camera2CameraFactory是具体的实现类</li><li>CameraDeviceSurfaceManager：Camera设备与对应数据流管理，具体实现是Camera2DeviceSurfaceManager</li><li>UseCaseConfigFactory：UseCase配置工厂</li></ul><p>CameraX主要使用<code>UseCase</code>的概念与相机设备进行交互，目前提供的<code>UseCase</code>：</p><ul><li>预览(Preview)</li><li>图片拍摄(ImageCapture)</li><li>图片分析(ImageAnalysis)</li></ul><h2 id="CameraX初始化"><a href="#CameraX初始化" class="headerlink" title="CameraX初始化"></a>CameraX初始化</h2><p><img src="https://s1.ax1x.com/2020/04/13/GXwNU1.png" alt="GXwNU1.png"></p><h3 id="Camera2Initializer"><a href="#Camera2Initializer" class="headerlink" title="Camera2Initializer"></a>Camera2Initializer</h3><p>CameraX初始化方法：init</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context, <span class="meta">@NonNull</span> AppConfig appConfig)</span> &#123;</span><br><span class="line">   INSTANCE.initInternal(context, appConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init 是通过ContentProvier配置初始化，具体实现类<code>Camera2Initializer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Camera2Initializer</span> <span class="keyword">extends</span> <span class="title class_">ContentProvider</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;Camera2Initializer&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;CameraX initializing with Camera2 ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CameraX.init(getContext(), Camera2AppConfig.create(getContext()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AndroidMainifest.xml</code>会自动生成provider配置，ContentProvider的OnCreate调用比Applicantion的 onCreate调用更早。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;androidx.camera.camera2.impl.Camera2Initializer&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:multiprocess</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:authorities</span>=<span class="string">&quot;$&#123;applicationId&#125;.camerax-init&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:initOrder</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Camera2AppConfig"><a href="#Camera2AppConfig" class="headerlink" title="Camera2AppConfig"></a>Camera2AppConfig</h3><p>init 方法传入的 AppConfig 的 create：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AppConfig <span class="title function_">create</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   <span class="comment">// Create the camera factory for creating Camera2 camera objects</span></span><br><span class="line">   <span class="type">CameraFactory</span> <span class="variable">cameraFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera2CameraFactory</span>(context);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create the DeviceSurfaceManager for Camera2</span></span><br><span class="line">   <span class="type">CameraDeviceSurfaceManager</span> <span class="variable">surfaceManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera2DeviceSurfaceManager</span>(context);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create default configuration factory</span></span><br><span class="line">   <span class="type">ExtendableUseCaseConfigFactory</span> <span class="variable">configFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExtendableUseCaseConfigFactory</span>();</span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            ImageAnalysisConfig.class, <span class="keyword">new</span> <span class="title class_">ImageAnalysisConfigProvider</span>(cameraFactory, context));</span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            ImageCaptureConfig.class, <span class="keyword">new</span> <span class="title class_">ImageCaptureConfigProvider</span>(cameraFactory, context));</span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            VideoCaptureConfig.class, <span class="keyword">new</span> <span class="title class_">VideoCaptureConfigProvider</span>(cameraFactory, context));</span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            PreviewConfig.class, <span class="keyword">new</span> <span class="title class_">PreviewConfigProvider</span>(cameraFactory, context));</span><br><span class="line"></span><br><span class="line">   AppConfig.<span class="type">Builder</span> <span class="variable">appConfigBuilder</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AppConfig</span>.Builder()</span><br><span class="line">                  .setCameraFactory(cameraFactory)</span><br><span class="line">                  .setDeviceSurfaceManager(surfaceManager)</span><br><span class="line">                  .setUseCaseConfigFactory(configFactory);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> appConfigBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 AppConfig.Builder 进行构建，CameraX中的默认属性都在这里初始化。后面具体讲到某个 UseCase 的时候，详细分析下具体的ConfigProvider</p><h3 id="CameraX-initInternal"><a href="#CameraX-initInternal" class="headerlink" title="CameraX.initInternal"></a>CameraX.initInternal</h3><p>CameraX真正初始化方法：<code>initInternal</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initInternal</span><span class="params">(Context context, AppConfig appConfig)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mInitialized.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mContext = context.getApplicationContext();</span><br><span class="line">   mCameraFactory = appConfig.getCameraFactory(<span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (mCameraFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Invalid app configuration provided. Missing CameraFactory.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mSurfaceManager = appConfig.getDeviceSurfaceManager(<span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (mSurfaceManager == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Invalid app configuration provided. Missing CameraDeviceSurfaceManager.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mDefaultConfigFactory = appConfig.getUseCaseConfigRepository(<span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (mDefaultConfigFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Invalid app configuration provided. Missing UseCaseConfigFactory.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   mCameraRepository.init(mCameraFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接从 AppConfig 中获取到具体实例，mCameraFactory对应的实例是<code>Camera2CameraFactory</code>，mCameraRepository.init(mCameraFactory)进行 Camera 相关的初始化</p><h3 id="CameraRepository-init"><a href="#CameraRepository-init" class="headerlink" title="CameraRepository.init"></a>CameraRepository.init</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(CameraFactory cameraFactory)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mCamerasLock) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            Set&lt;String&gt; camerasList = cameraFactory.getAvailableCameraIds();</span><br><span class="line">            <span class="keyword">for</span> (String id : camerasList) &#123;</span><br><span class="line">               Log.d(TAG, <span class="string">&quot;Added camera: &quot;</span> + id);</span><br><span class="line">               mCameras.put(id, cameraFactory.getCamera(id));</span><br><span class="line">            &#125;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getAvailableCameraIds</code>获取可用 Camera Id列表，Camera2CameraFactory的<code>getCamera</code>真正初始化Camera</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BaseCamera <span class="title function_">getCamera</span><span class="params">(<span class="meta">@NonNull</span> String cameraId)</span> &#123;</span><br><span class="line">   <span class="type">Camera</span> <span class="variable">camera</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>(mCameraManager, cameraId,</span><br><span class="line">            mAvailabilityRegistry.getAvailableCameraCount(), sHandler);</span><br><span class="line">   mAvailabilityRegistry.registerCamera(camera);</span><br><span class="line">   <span class="keyword">return</span> camera;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>CameraAvailabilityRegistry</code>的<code>registerCamera</code>方法进行Camera注册<br>到此为止，CameraX 相关属性就初始化完成了</p><h2 id="bindToLifecycle"><a href="#bindToLifecycle" class="headerlink" title="bindToLifecycle"></a>bindToLifecycle</h2><p>从第一个<code>UseCase</code>预览(preview)来讲解CameraX 生命周期过程，以及数据传输流程。<br>前面一篇文章已经讲解过 CameraX 的使用，其中预览(preivew)，会先声明<code>PreviewConfig</code>,通过 config 生成<code>Preivew</code>，<code>preview.setOnPreviewOutputUpdateListener</code>设置监听Camera数据流。这一系列流程能够实现，主要通过<code>CameraX.bindToLifecycle</code>实现<br>具体流程：<br><img src="https://s1.ax1x.com/2020/04/13/GXRjuq.png" alt="GXRjuq.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindToLifecycle</span><span class="params">(LifecycleOwner lifecycleOwner, UseCase... useCases)</span> &#123;</span><br><span class="line">   Threads.checkMainThread();</span><br><span class="line">   <span class="type">UseCaseGroupLifecycleController</span> <span class="variable">useCaseGroupLifecycleController</span> <span class="operator">=</span></span><br><span class="line">            INSTANCE.getOrCreateUseCaseGroup(lifecycleOwner);</span><br><span class="line">   <span class="type">UseCaseGroup</span> <span class="variable">useCaseGroupToBind</span> <span class="operator">=</span> useCaseGroupLifecycleController.getUseCaseGroup();</span><br><span class="line"></span><br><span class="line">   Collection&lt;UseCaseGroupLifecycleController&gt; controllers =</span><br><span class="line">            INSTANCE.mUseCaseGroupRepository.getUseCaseGroups();</span><br><span class="line">   <span class="comment">//检查UseCase 只能在一个lifecycle上</span></span><br><span class="line">   <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">      <span class="keyword">for</span> (UseCaseGroupLifecycleController controller : controllers) &#123;</span><br><span class="line">            <span class="type">UseCaseGroup</span> <span class="variable">useCaseGroup</span> <span class="operator">=</span> controller.getUseCaseGroup();</span><br><span class="line">            <span class="keyword">if</span> (useCaseGroup.contains(useCase) &amp;&amp; useCaseGroup != useCaseGroupToBind) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        String.format(</span><br><span class="line">                              <span class="string">&quot;Use case %s already bound to a different lifecycle.&quot;</span>,</span><br><span class="line">                              useCase));</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//onBind监听回调</span></span><br><span class="line">   <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">      useCase.onBind();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   calculateSuggestedResolutions(lifecycleOwner, useCases);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">      useCaseGroupToBind.addUseCase(useCase);</span><br><span class="line">      <span class="keyword">for</span> (String cameraId : useCase.getAttachedCameraIds()) &#123;</span><br><span class="line">            attach(cameraId, useCase);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   useCaseGroupLifecycleController.notifyState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UseCaseGroupLifecycleController"><a href="#UseCaseGroupLifecycleController" class="headerlink" title="UseCaseGroupLifecycleController"></a>UseCaseGroupLifecycleController</h3><p>创建 UseCaseGroupLifecycleController，UseCaseGroup控制器，通过Lifecycle组件进行 start 和 stop 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UseCaseGroupLifecycleController</span> <span class="variable">useCaseGroupLifecycleController</span> <span class="operator">=</span></span><br><span class="line">            INSTANCE.getOrCreateUseCaseGroup(lifecycleOwner);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> UseCaseGroupLifecycleController <span class="title function_">getOrCreateUseCaseGroup</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> mUseCaseGroupRepository.getOrCreateUseCaseGroup(</span><br><span class="line">            lifecycleOwner, <span class="keyword">new</span> <span class="title class_">UseCaseGroupRepository</span>.UseCaseGroupSetup() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">(UseCaseGroup useCaseGroup)</span> &#123;</span><br><span class="line">                  useCaseGroup.setListener(mCameraRepository);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过UseCaseGroupRepository创建UseCaseGroupLifecycleController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">UseCaseGroupLifecycleController <span class="title function_">getOrCreateUseCaseGroup</span><span class="params">(</span></span><br><span class="line"><span class="params">            LifecycleOwner lifecycleOwner, UseCaseGroupSetup groupSetup)</span> &#123;</span><br><span class="line">   UseCaseGroupLifecycleController useCaseGroupLifecycleController;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCasesLock) &#123;</span><br><span class="line">      <span class="comment">//如果有缓存，则直接返回，否则进行创建</span></span><br><span class="line">      useCaseGroupLifecycleController = mLifecycleToUseCaseGroupControllerMap.get(</span><br><span class="line">               lifecycleOwner);</span><br><span class="line">      <span class="keyword">if</span> (useCaseGroupLifecycleController == <span class="literal">null</span>) &#123;</span><br><span class="line">            useCaseGroupLifecycleController = createUseCaseGroup(lifecycleOwner);</span><br><span class="line">            groupSetup.setup(useCaseGroupLifecycleController.getUseCaseGroup());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> useCaseGroupLifecycleController;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">private</span> UseCaseGroupLifecycleController <span class="title function_">createUseCaseGroup</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Need to add observer before creating UseCaseGroupLifecycleController to make sure</span></span><br><span class="line">   <span class="comment">// UseCaseGroups can be stopped before the latest active one is started.</span></span><br><span class="line">   lifecycleOwner.getLifecycle().addObserver(createLifecycleObserver());</span><br><span class="line">   <span class="type">UseCaseGroupLifecycleController</span> <span class="variable">useCaseGroupLifecycleController</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UseCaseGroupLifecycleController</span>(lifecycleOwner.getLifecycle());</span><br><span class="line">   <span class="comment">//创建后，放入 map 缓存</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCasesLock) &#123;</span><br><span class="line">      mLifecycleToUseCaseGroupControllerMap.put(lifecycleOwner,</span><br><span class="line">               useCaseGroupLifecycleController);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> useCaseGroupLifecycleController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建UseCaseGroupLifecycleController，并增加Lifecycle生命周期控制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">UseCaseGroupLifecycleController(Lifecycle lifecycle) &#123;</span><br><span class="line">   <span class="built_in">this</span>(lifecycle, <span class="keyword">new</span> <span class="title class_">UseCaseGroup</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wraps an existing &#123;<span class="doctag">@link</span> UseCaseGroup&#125; so it is controlled by lifecycle transitions. */</span></span><br><span class="line">UseCaseGroupLifecycleController(Lifecycle lifecycle, UseCaseGroup useCaseGroup) &#123;</span><br><span class="line">   <span class="built_in">this</span>.mUseCaseGroup = useCaseGroup;</span><br><span class="line">   <span class="built_in">this</span>.mLifecycle = lifecycle;</span><br><span class="line">   <span class="comment">//绑定Lifecycle</span></span><br><span class="line">   lifecycle.addObserver(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCaseGroupLock) &#123;</span><br><span class="line">      mUseCaseGroup.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCaseGroupLock) &#123;</span><br><span class="line">      mUseCaseGroup.stop();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">(LifecycleOwner lifecycleOwner)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCaseGroupLock) &#123;</span><br><span class="line">      mUseCaseGroup.clear();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，增加了<code>ON_START</code>，<code>ON_STOP</code>，<code>ON_DESTROY</code>的生命周期监听  </p><h3 id="calculateSuggestedResolutions"><a href="#calculateSuggestedResolutions" class="headerlink" title="calculateSuggestedResolutions"></a>calculateSuggestedResolutions</h3><p>根据传入的配置，生成各个UseCase的最佳解决方案。后面的代码会以<code>Preview</code>这个 UseCase 展开，其他 UseCase 代码逻辑类似。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">calculateSuggestedResolutions</span><span class="params">(LifecycleOwner lifecycleOwner,</span></span><br><span class="line"><span class="params">            UseCase... useCases)</span> &#123;</span><br><span class="line">   <span class="comment">// There will only one lifecycleOwner active. Therefore, only collect use cases belong to</span></span><br><span class="line">   <span class="comment">// same lifecycleOwner and calculate the suggested resolutions.</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Collect new use cases for different camera devices</span></span><br><span class="line">   <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">cameraId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            cameraId = getCameraWithCameraDeviceConfig(</span><br><span class="line">                  (CameraDeviceConfig) useCase.getUseCaseConfig());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraInfoUnavailableException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                  <span class="string">&quot;Unable to get camera id for the camera device config.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Get suggested resolutions and update the use case session configuration</span></span><br><span class="line">   <span class="keyword">for</span> (String cameraId : newCameraIdUseCaseMap.keySet()) &#123;</span><br><span class="line">      Map&lt;UseCase, Size&gt; suggestResolutionsMap =</span><br><span class="line">               getSurfaceManager()</span><br><span class="line">                        .getSuggestedResolutions(</span><br><span class="line">                              cameraId,</span><br><span class="line">                              originalCameraIdUseCaseMap.get(cameraId),</span><br><span class="line">                              newCameraIdUseCaseMap.get(cameraId));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (UseCase useCase : newCameraIdUseCaseMap.get(cameraId)) &#123;</span><br><span class="line">            <span class="type">Size</span> <span class="variable">resolution</span> <span class="operator">=</span> suggestResolutionsMap.get(useCase);</span><br><span class="line">            Map&lt;String, Size&gt; suggestedCameraSurfaceResolutionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            suggestedCameraSurfaceResolutionMap.put(cameraId, resolution);</span><br><span class="line">            <span class="comment">//更新配置</span></span><br><span class="line">            useCase.updateSuggestedResolution(suggestedCameraSurfaceResolutionMap);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 UseCase 会去更新对应配置 updateSuggestedResolution-&gt;onSuggestedResolutionUpdated</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateSuggestedResolution</span><span class="params">(Map&lt;String, Size&gt; suggestedResolutionMap)</span> &#123;</span><br><span class="line">   Map&lt;String, Size&gt; resolutionMap = onSuggestedResolutionUpdated(suggestedResolutionMap);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onSuggestedResolutionUpdated针对不同的 UseCase 有不同的实现，这里以<code>Preview</code>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Map&lt;String, Size&gt; <span class="title function_">onSuggestedResolutionUpdated</span><span class="params">(</span></span><br><span class="line"><span class="params">            Map&lt;String, Size&gt; suggestedResolutionMap)</span> &#123;</span><br><span class="line">   <span class="comment">//获取前面配置的 config</span></span><br><span class="line">   <span class="type">PreviewConfig</span> <span class="variable">config</span> <span class="operator">=</span> (PreviewConfig) getUseCaseConfig();</span><br><span class="line">   <span class="type">String</span> <span class="variable">cameraId</span> <span class="operator">=</span> getCameraIdUnchecked(config);</span><br><span class="line">   <span class="type">Size</span> <span class="variable">resolution</span> <span class="operator">=</span> suggestedResolutionMap.get(cameraId);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//设置 config</span></span><br><span class="line">   updateConfigAndOutput(config, resolution);</span><br><span class="line">   <span class="keyword">return</span> suggestedResolutionMap;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigAndOutput</span><span class="params">(PreviewConfig config, Size resolution)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">cameraId</span> <span class="operator">=</span> getCameraIdUnchecked(config);</span><br><span class="line">   <span class="comment">//初始化pipeline</span></span><br><span class="line">   mSessionConfigBuilder = createPipeline(config, resolution);</span><br><span class="line">   attachToCamera(cameraId, mSessionConfigBuilder.build());</span><br><span class="line">   updateOutput(mSurfaceTextureHolder.getSurfaceTexture(), resolution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preview-createPipeline"><a href="#Preview-createPipeline" class="headerlink" title="Preview.createPipeline"></a>Preview.createPipeline</h3><p>创建Preview管道，通过 PreviewConfig 的配置，创建对应的显示Surface和SessionConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SessionConfig.Builder <span class="title function_">createPipeline</span><span class="params">(PreviewConfig config, Size resolution)</span> &#123;</span><br><span class="line">   Threads.checkMainThread();</span><br><span class="line">   SessionConfig.<span class="type">Builder</span> <span class="variable">sessionConfigBuilder</span> <span class="operator">=</span> SessionConfig.Builder.createFrom(config);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="type">CaptureProcessor</span> <span class="variable">captureProcessor</span> <span class="operator">=</span> config.getCaptureProcessor(<span class="literal">null</span>);</span><br><span class="line">   <span class="comment">//扩展的 extensions实现</span></span><br><span class="line">   <span class="keyword">if</span> (captureProcessor != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">CaptureStage</span> <span class="variable">captureStage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaptureStage</span>.DefaultCaptureStage();</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> To allow user to use an Executor for the processing.</span></span><br><span class="line">      ...</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ImageInfoProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> config.getImageInfoProcessor(<span class="literal">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (processor != <span class="literal">null</span>) &#123;</span><br><span class="line">            sessionConfigBuilder.addCameraCaptureCallback(<span class="keyword">new</span> <span class="title class_">CameraCaptureCallback</span>() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureCompleted</span><span class="params">(</span></span><br><span class="line"><span class="params">                        <span class="meta">@NonNull</span> CameraCaptureResult cameraCaptureResult)</span> &#123;</span><br><span class="line">                  <span class="built_in">super</span>.onCaptureCompleted(cameraCaptureResult);</span><br><span class="line">                  <span class="keyword">if</span> (processor.process(</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">CameraCaptureResultImageInfo</span>(cameraCaptureResult))) &#123;</span><br><span class="line">                        notifyUpdated();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//默认的 Surface</span></span><br><span class="line">      <span class="type">CheckedSurfaceTexture</span> <span class="variable">checkedSurfaceTexture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckedSurfaceTexture</span>(resolution);</span><br><span class="line"></span><br><span class="line">      mSurfaceTextureHolder = checkedSurfaceTexture;</span><br><span class="line">      sessionConfigBuilder.addSurface(checkedSurfaceTexture);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以看到我们熟悉的味道，在Camera2中 用到的<code>Surface</code>，<code>Session</code>相关配置，后面会用到相关配置。<br>在<code>CheckedSurfaceTexture</code>中会创建<code>FixedSizeSurfaceTexture</code>用来显示图像。  </p><h3 id="Preview-updateOutput"><a href="#Preview-updateOutput" class="headerlink" title="Preview.updateOutput"></a>Preview.updateOutput</h3><p>增加数据的监听</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">updateOutput</span><span class="params">(SurfaceTexture surfaceTexture, Size resolution)</span> &#123;</span><br><span class="line">   <span class="type">PreviewConfig</span> <span class="variable">useCaseConfig</span> <span class="operator">=</span> (PreviewConfig) getUseCaseConfig();</span><br><span class="line">   ...</span><br><span class="line">   <span class="type">PreviewOutput</span> <span class="variable">newOutput</span> <span class="operator">=</span></span><br><span class="line">            PreviewOutput.create(surfaceTexture, resolution, relativeRotation);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Only update the output if something has changed</span></span><br><span class="line">   <span class="keyword">if</span> (!Objects.equals(mLatestPreviewOutput, newOutput)) &#123;</span><br><span class="line">      <span class="type">SurfaceTexture</span> <span class="variable">oldTexture</span> <span class="operator">=</span></span><br><span class="line">               (mLatestPreviewOutput == <span class="literal">null</span>)</span><br><span class="line">                        ? <span class="literal">null</span></span><br><span class="line">                        : mLatestPreviewOutput.getSurfaceTexture();</span><br><span class="line">      <span class="type">OnPreviewOutputUpdateListener</span> <span class="variable">outputListener</span> <span class="operator">=</span> getOnPreviewOutputUpdateListener();</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (outputListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            mSurfaceDispatched = <span class="literal">true</span>;</span><br><span class="line">            updateListener(outputListener, newOutput);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Preview设置的setOnPreviewOutputUpdateListener，获取到对应的Listener，通过<code>updateListener</code>方法回调数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateListener</span><span class="params">(OnPreviewOutputUpdateListener listener, PreviewOutput output)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   mOutputUpdateExecutor.execute(() -&gt; listener.onUpdated(output));</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notifyState"><a href="#notifyState" class="headerlink" title="notifyState"></a>notifyState</h3><p>调用UseCaseGroupLifecycleController的notifyState，激活 UseCase 状态，在UseCaseGroupLifecycleController中有增加生命周期的监听，在<code>ON_START</code>状态会调用<code>mUseCaseGroup.start</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">notifyState</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mUseCaseGroupLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mLifecycle.getCurrentState().isAtLeast(State.STARTED)) &#123;</span><br><span class="line">            mUseCaseGroup.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (UseCase useCase : mUseCaseGroup.getUseCases()) &#123;</span><br><span class="line">            useCase.notifyState();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UseCaseGroup-start"><a href="#UseCaseGroup-start" class="headerlink" title="UseCaseGroup.start"></a>UseCaseGroup.start</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mListenerLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mListener != <span class="literal">null</span>) &#123;</span><br><span class="line">            mListener.onGroupActive(<span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      mIsActive = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 start 状态，调用<code>CameraRepository</code>的<code>onGroupActive</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onGroupActive</span><span class="params">(UseCaseGroup useCaseGroup)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mCamerasLock) &#123;</span><br><span class="line">      Map&lt;String, Set&lt;UseCase&gt;&gt; cameraIdToUseCaseMap = useCaseGroup.getCameraIdToUseCaseMap();</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;UseCase&gt;&gt; cameraUseCaseEntry :</span><br><span class="line">               cameraIdToUseCaseMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">BaseCamera</span> <span class="variable">camera</span> <span class="operator">=</span> getCamera(cameraUseCaseEntry.getKey());</span><br><span class="line">            attachUseCasesToCamera(camera, cameraUseCaseEntry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attachUseCasesToCamera</span><span class="params">(BaseCamera camera, Set&lt;UseCase&gt; useCases)</span> &#123;</span><br><span class="line">   camera.addOnlineUseCase(useCases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>camera.addOnlineUseCase</code>关联UseCase 和 Camera。</p><h3 id="Camera-addOnlineUseCase"><a href="#Camera-addOnlineUseCase" class="headerlink" title="Camera.addOnlineUseCase"></a>Camera.addOnlineUseCase</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOnlineUseCase</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Collection&lt;UseCase&gt; useCases)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (useCases.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Attaches the surfaces of use case to the Camera (prevent from surface abandon crash)</span></span><br><span class="line">   <span class="comment">// addOnlineUseCase could be called with duplicate use case, so we need to filter out</span></span><br><span class="line">   <span class="comment">// use cases that are either pending for addOnline or are already online.</span></span><br><span class="line">   <span class="comment">// It&#x27;s ok for two thread to run here, since it‘ll do nothing if use case is already</span></span><br><span class="line">   <span class="comment">// pending.</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mPendingLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (UseCase useCase : useCases) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isOnline</span> <span class="operator">=</span> isUseCaseOnline(useCase);</span><br><span class="line">            <span class="keyword">if</span> (mPendingForAddOnline.contains(useCase) || isOnline) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notifyAttachToUseCaseSurfaces(useCase);</span><br><span class="line">            mPendingForAddOnline.add(useCase);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   updateCaptureSessionConfig();</span><br><span class="line">   resetCaptureSession(<span class="comment">/*abortInFlightCaptures=*/</span><span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mState == InternalState.OPENED) &#123;</span><br><span class="line">      openCaptureSession();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      open();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   updateCameraControlPreviewAspectRatio(useCases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在addOnlineUseCase方法中，open会去打开Camera设备。</p><h3 id="Camera-open"><a href="#Camera-open" class="headerlink" title="Camera.open"></a>Camera.open</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">      <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">            openCameraDevice();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CLOSING:</span><br><span class="line">            setState(InternalState.REOPENING);</span><br><span class="line">            <span class="comment">// If session close has not yet completed, then the camera is still open. We</span></span><br><span class="line">            <span class="comment">// can move directly back into an OPENED state.</span></span><br><span class="line">            <span class="comment">// If session close is already complete, then the camera is closing. We&#x27;ll reopen</span></span><br><span class="line">            <span class="comment">// the camera in the camera state callback.</span></span><br><span class="line">            <span class="comment">// If the camera device is currently in an error state, we need to close the</span></span><br><span class="line">            <span class="comment">// camera before reopening, so we cannot directly reopen.</span></span><br><span class="line">            <span class="keyword">if</span> (!isSessionCloseComplete() &amp;&amp; mCameraDeviceError == ERROR_NONE) &#123;</span><br><span class="line">               Preconditions.checkState(mCameraDevice != <span class="literal">null</span>,</span><br><span class="line">                        <span class="string">&quot;Camera Device should be open if session close is not complete&quot;</span>);</span><br><span class="line">               setState(InternalState.OPENED);</span><br><span class="line">               openCaptureSession();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;open() ignored due to being in state: &quot;</span> + mState);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">openCameraDevice</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// Check that we have an available camera to open here before attempting</span></span><br><span class="line">   <span class="comment">// to open the camera again.</span></span><br><span class="line">   <span class="keyword">if</span> (!mCameraAvailability.isCameraAvailable()) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;No cameras available. Waiting for available camera before opening camera: &quot;</span></span><br><span class="line">               + mCameraId);</span><br><span class="line">      setState(InternalState.PENDING_OPEN);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setState(InternalState.OPENING);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//真正打开相机</span></span><br><span class="line">   mCameraManager.openCamera(mCameraId, mExecutor, createDeviceStateCallback());</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是Camera2的预览流程</p><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><p>CameraX封装了Camera2的标准预览流程，这些类都是在 CameraX 库中<br><img src="https://s1.ax1x.com/2020/04/13/GXLFRP.png" alt="GXLFRP.png"></p><h3 id="CameraDevice-StateCallback"><a href="#CameraDevice-StateCallback" class="headerlink" title="CameraDevice.StateCallback"></a>CameraDevice.StateCallback</h3><p><code>openCameraDevice</code>的stateCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StateCallback</span> <span class="keyword">extends</span> <span class="title class_">CameraDevice</span>.StateCallback &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(CameraDevice cameraDevice)</span> &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">&quot;CameraDevice.onOpened(): &quot;</span> + cameraDevice.getId());</span><br><span class="line">      mCameraDevice = cameraDevice;</span><br><span class="line">      mCameraDeviceError = ERROR_NONE;</span><br><span class="line">      <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> CLOSING:</span><br><span class="line">            <span class="keyword">case</span> RELEASING:</span><br><span class="line">               <span class="comment">// No session should have yet been opened, so close camera directly here.</span></span><br><span class="line">               Preconditions.checkState(isSessionCloseComplete());</span><br><span class="line">               mCameraDevice.close();</span><br><span class="line">               mCameraDevice = <span class="literal">null</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OPENING:</span><br><span class="line">            <span class="keyword">case</span> REOPENING:</span><br><span class="line">               setState(InternalState.OPENED);</span><br><span class="line">               openCaptureSession();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;onOpened() should not be possible from state: &quot;</span> + mState);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">openCaptureSession</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   mCaptureSession.open(validatingBuilder.build(), mCameraDevice);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CaptureSession-open"><a href="#CaptureSession-open" class="headerlink" title="CaptureSession.open"></a>CaptureSession.open</h3><p>创建CaptureSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">open</span><span class="params">(SessionConfig sessionConfig, CameraDevice cameraDevice)</span></span><br><span class="line">      <span class="keyword">throws</span> CameraAccessException, DeferrableSurface.SurfaceClosedException &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mStateLock) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> UNINITIALIZED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;open() should not be possible in state: &quot;</span> + mState);</span><br><span class="line">            <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">               <span class="comment">//Camera中传入的essionConfig，默认有TEMPLATE_PREVIEW的 surface 实现</span></span><br><span class="line">               List&lt;DeferrableSurface&gt; surfaces = sessionConfig.getSurfaces();</span><br><span class="line">               ...</span><br><span class="line">               <span class="comment">//状态更新</span></span><br><span class="line">               notifySurfaceAttached();</span><br><span class="line">               mState = State.OPENING;</span><br><span class="line">               ...</span><br><span class="line">               <span class="type">SessionConfigurationCompat</span> <span class="variable">sessionConfigCompat</span> <span class="operator">=</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">SessionConfigurationCompat</span>(</span><br><span class="line">                              SessionConfigurationCompat.SESSION_REGULAR,</span><br><span class="line">                              outputConfigList,</span><br><span class="line">                              getExecutor(),</span><br><span class="line">                              comboCallback);</span><br><span class="line"></span><br><span class="line">               <span class="type">CaptureRequest</span> <span class="variable">captureRequest</span> <span class="operator">=</span></span><br><span class="line">                        Camera2CaptureRequestBuilder.buildWithoutTarget(</span><br><span class="line">                              captureConfigBuilder.build(),</span><br><span class="line">                              cameraDevice);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (captureRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">                  sessionConfigCompat.setSessionParameters(captureRequest);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//创建CaptureSession，CameraDeviceCompat根据 Android 版本有不同的实现</span></span><br><span class="line">               CameraDeviceCompat.createCaptureSession(cameraDevice, sessionConfigCompat);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在Camera2的使用中，CameraDevice的createCaptureSession可以创建预览画面，CameraX的CaptureSession很好的封装了这些实现。<br>在<code>CaptureSession.open</code>传入的SessionConfig，是在<code>Camera2AppConfig.create</code>创建的时候生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AppConfig <span class="title function_">create</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   <span class="comment">// Create the camera factory for creating Camera2 camera objects</span></span><br><span class="line">   <span class="type">CameraFactory</span> <span class="variable">cameraFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera2CameraFactory</span>(context);</span><br><span class="line">   <span class="comment">// PreviewConfig 配置</span></span><br><span class="line">   configFactory.installDefaultProvider(</span><br><span class="line">            PreviewConfig.class, <span class="keyword">new</span> <span class="title class_">PreviewConfigProvider</span>(cameraFactory, context));</span><br><span class="line"></span><br><span class="line">   AppConfig.<span class="type">Builder</span> <span class="variable">appConfigBuilder</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AppConfig</span>.Builder()</span><br><span class="line">                  .setCameraFactory(cameraFactory)</span><br><span class="line">                  .setDeviceSurfaceManager(surfaceManager)</span><br><span class="line">                  .setUseCaseConfigFactory(configFactory);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> appConfigBuilder.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PreviewConfigProvider配置getConfig</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PreviewConfig <span class="title function_">getConfig</span><span class="params">(LensFacing lensFacing)</span> &#123;</span><br><span class="line">   PreviewConfig.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span></span><br><span class="line">            PreviewConfig.Builder.fromConfig(Preview.DEFAULT_CONFIG.getConfig(lensFacing));</span><br><span class="line">   <span class="comment">// SessionConfig containing all intrinsic properties needed for Preview</span></span><br><span class="line">   SessionConfig.<span class="type">Builder</span> <span class="variable">sessionBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SessionConfig</span>.Builder();</span><br><span class="line">   <span class="comment">// createCaptureSession中的 preview 设置</span></span><br><span class="line">   sessionBuilder.setTemplateType(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add options to UseCaseConfig</span></span><br><span class="line">   builder.setDefaultSessionConfig(sessionBuilder.build());</span><br><span class="line">   builder.setSessionOptionUnpacker(Camera2SessionOptionUnpacker.INSTANCE);</span><br><span class="line"></span><br><span class="line">   CaptureConfig.<span class="type">Builder</span> <span class="variable">captureBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaptureConfig</span>.Builder();</span><br><span class="line">   captureBuilder.setTemplateType(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">   builder.setDefaultCaptureConfig(captureBuilder.build());</span><br><span class="line">   builder.setCaptureOptionUnpacker(Camera2CaptureOptionUnpacker.INSTANCE);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CameraDeviceCompat.createCaptureSession</code>的CameraCaptureSession回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StateCallback</span> <span class="keyword">extends</span> <span class="title class_">CameraCaptureSession</span>.StateCallback &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigured</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mStateLock) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">               <span class="keyword">case</span> UNINITIALIZED:</span><br><span class="line">               <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">               <span class="keyword">case</span> OPENED:</span><br><span class="line">               <span class="keyword">case</span> RELEASED:</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                           <span class="string">&quot;onConfigured() should not be possible in state: &quot;</span> + mState);</span><br><span class="line">               <span class="keyword">case</span> OPENING:</span><br><span class="line">                  ...</span><br><span class="line">                  <span class="comment">// Issue capture request of enableSession if exists.</span></span><br><span class="line">                  <span class="keyword">if</span> (mSessionConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">Config</span> <span class="variable">implOptions</span> <span class="operator">=</span> mSessionConfig.getImplementationOptions();</span><br><span class="line">                        <span class="type">CameraEventCallbacks</span> <span class="variable">eventCallbacks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera2Config</span>(</span><br><span class="line">                              implOptions).getCameraEventCallback(</span><br><span class="line">                              CameraEventCallbacks.createEmptyCallback());</span><br><span class="line">                              <span class="comment">//可配置CameraEventCallback的EnableSession回调</span></span><br><span class="line">                        List&lt;CaptureConfig&gt; list =</span><br><span class="line">                              eventCallbacks.createComboCallback().onEnableSession();</span><br><span class="line">                        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">                           issueCaptureRequests(setupConfiguredSurface(list));</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//</span></span><br><span class="line">                  issueRepeatingCaptureRequests();</span><br><span class="line">                  issueBurstCaptureRequest();</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CaptureSession-issueRepeatingCaptureRequests"><a href="#CaptureSession-issueRepeatingCaptureRequests" class="headerlink" title="CaptureSession.issueRepeatingCaptureRequests"></a>CaptureSession.issueRepeatingCaptureRequests</h3><p>开启Camera预览</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">issueRepeatingCaptureRequests</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="type">CaptureConfig</span> <span class="variable">captureConfig</span> <span class="operator">=</span> mSessionConfig.getRepeatingCaptureConfig();</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// The override priority for implementation options</span></span><br><span class="line">   <span class="comment">// P1 CameraEventCallback onRepeating options</span></span><br><span class="line">   <span class="comment">// P2 SessionConfig options</span></span><br><span class="line">   CaptureConfig.<span class="type">Builder</span> <span class="variable">captureConfigBuilder</span> <span class="operator">=</span> CaptureConfig.Builder.from(captureConfig);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建CaptureRequest</span></span><br><span class="line">   <span class="type">CaptureRequest</span> <span class="variable">captureRequest</span> <span class="operator">=</span> Camera2CaptureRequestBuilder.build(</span><br><span class="line">            captureConfigBuilder.build(), mCameraCaptureSession.getDevice(),</span><br><span class="line">            mConfiguredSurfaceMap);</span><br><span class="line">   <span class="keyword">if</span> (captureRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">         Log.d(TAG, <span class="string">&quot;Skipping issuing empty request for session.&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//设置Capture回调</span></span><br><span class="line">   CameraCaptureSession.<span class="type">CaptureCallback</span> <span class="variable">comboCaptureCallback</span> <span class="operator">=</span></span><br><span class="line">            createCamera2CaptureCallback(</span><br><span class="line">                     captureConfig.getCameraCaptureCallbacks(),</span><br><span class="line">                     mCaptureCallback);</span><br><span class="line"></span><br><span class="line">   CameraCaptureSessionCompat.setSingleRepeatingRequest(mCameraCaptureSession,</span><br><span class="line">            captureRequest, mExecutor, comboCaptureCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraCaptureSessionCompat.setSingleRepeatingRequest 也是区分 Android 版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CameraCaptureSessionCompatImpl <span class="title function_">chooseImplementation</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">28</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CameraCaptureSessionCompatApi28Impl</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CameraCaptureSessionCompatBaseImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CameraCaptureSessionCompatBaseImpl，和平时使用的一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setSingleRepeatingRequest</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession captureSession,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> CaptureRequest request, <span class="meta">@NonNull</span> Executor executor,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> CameraCaptureSession.CaptureCallback listener)</span> <span class="keyword">throws</span> CameraAccessException &#123;</span><br><span class="line">   Preconditions.checkNotNull(captureSession);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Wrap the executor in the callback</span></span><br><span class="line">   CameraCaptureSession.<span class="type">CaptureCallback</span> <span class="variable">cb</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CameraCaptureSessionCompat</span>.CaptureCallbackExecutorWrapper(executor, listener);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> captureSession.setRepeatingRequest(</span><br><span class="line">            request, cb, MainThreadAsyncHandler.getInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CameraCaptureSessionCompatApi28Impl，新版本 API 有些变化</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setSingleRepeatingRequest</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession captureSession,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> CaptureRequest request, <span class="meta">@NonNull</span> Executor executor,</span></span><br><span class="line"><span class="params">      <span class="meta">@NonNull</span> CameraCaptureSession.CaptureCallback listener)</span> <span class="keyword">throws</span> CameraAccessException &#123;</span><br><span class="line">   Preconditions.checkNotNull(captureSession);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Call through directly to executor API</span></span><br><span class="line">   <span class="keyword">return</span> captureSession.setSingleRepeatingRequest(request, executor, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Camera的开启到预览，以及读取各种配置，整个过程到此就完成了，接下来介绍如何拍照，这个流程相对来说比较简单</p><h2 id="ImageCapture-takePicture"><a href="#ImageCapture-takePicture" class="headerlink" title="ImageCapture.takePicture"></a>ImageCapture.takePicture</h2><p>拍照的流程：<br><img src="https://s1.ax1x.com/2020/04/17/JZ52bd.png" alt="JZ52bd.png"></p><h3 id="sendImageCaptureRequest"><a href="#sendImageCaptureRequest" class="headerlink" title="sendImageCaptureRequest"></a>sendImageCaptureRequest</h3><p>创建 ImageCaptureRequest，设置cameraId、targetRatio、回调等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendImageCaptureRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Executor listenerExecutor, OnImageCapturedListener listener)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">cameraId</span> <span class="operator">=</span> getCameraIdUnchecked(mConfig);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get the relative rotation or default to 0 if the camera info is unavailable</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">relativeRotation</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">CameraInfoInternal</span> <span class="variable">cameraInfoInternal</span> <span class="operator">=</span> CameraX.getCameraInfo(cameraId);</span><br><span class="line">      relativeRotation =</span><br><span class="line">               cameraInfoInternal.getSensorRotationDegrees(</span><br><span class="line">                        mConfig.getTargetRotation(Surface.ROTATION_0));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraInfoUnavailableException e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Unable to retrieve camera sensor orientation.&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">Rational</span> <span class="variable">targetRatio</span> <span class="operator">=</span> mConfig.getTargetAspectRatioCustom(<span class="literal">null</span>);</span><br><span class="line">   targetRatio = ImageUtil.rotate(targetRatio, relativeRotation);</span><br><span class="line"></span><br><span class="line">   mImageCaptureRequests.offer(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ImageCaptureRequest</span>(relativeRotation, targetRatio, listenerExecutor, listener));</span><br><span class="line">   <span class="keyword">if</span> (mImageCaptureRequests.size() == <span class="number">1</span>) &#123;</span><br><span class="line">      issueImageCaptureRequests();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="takePictureInternal"><a href="#takePictureInternal" class="headerlink" title="takePictureInternal"></a>takePictureInternal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">issueImageCaptureRequests</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mImageCaptureRequests.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   takePictureInternal();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//拍照流程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">takePictureInternal</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//自定义 Future 调用链</span></span><br><span class="line">   FutureChain.from(preTakePicture(state))</span><br><span class="line">      .transformAsync&#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">return</span> ImageCapture.<span class="built_in">this</span>.issueTakePicture(state);</span><br><span class="line">      &#125;)</span><br><span class="line">      .transformAsync&#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">return</span> ImageCapture.<span class="built_in">this</span>.postTakePicture(state);</span><br><span class="line">      &#125;)</span><br><span class="line">      .addCallback(</span><br><span class="line">         ...</span><br><span class="line">         onTakePictureFinish(<span class="literal">null</span>);</span><br><span class="line">      )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义了整个拍照工作流，通过<code>issueTakePicture</code>进行拍照，<code>postTakePicture</code>是拍照成功，释放资源，取消3A。下面重点看下<code>issueTakePicture</code>流程</p><h3 id="issueTakePicture"><a href="#issueTakePicture" class="headerlink" title="issueTakePicture"></a>issueTakePicture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;Void&gt; <span class="title function_">issueTakePicture</span><span class="params">(TakePictureState state)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   getCurrentCameraControl().submitCaptureRequests(captureConfigs);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>CameraControl</code>提交Capture 请求，<code>CameraControl</code>具体实现是<code>Camera2CameraControl</code>。</p><h3 id="submitCaptureRequests"><a href="#submitCaptureRequests" class="headerlink" title="submitCaptureRequests"></a>submitCaptureRequests</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitCaptureRequests</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> List&lt;CaptureConfig&gt; captureConfigs)</span> &#123;</span><br><span class="line">   mExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            submitCaptureRequestsInternal(captureConfigs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">submitCaptureRequestsInternal</span><span class="params">(<span class="keyword">final</span> List&lt;CaptureConfig&gt; captureConfigs)</span> &#123;</span><br><span class="line">   mControlUpdateListener.onCameraControlCaptureRequests(captureConfigs);</span><br><span class="line">   <span class="comment">//mControlUpdateListener是Camera 的回调，onCameraControlCaptureRequests 真正实现在 Camera 中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Camera.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCameraControlUpdateSessionConfig</span><span class="params">(<span class="meta">@NonNull</span> SessionConfig sessionConfig)</span> &#123;</span><br><span class="line">   mCameraControlSessionConfig = sessionConfig;</span><br><span class="line">   updateCaptureSessionConfig();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateCaptureSessionConfig</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">         <span class="type">SessionConfig</span> <span class="variable">sessionConfig</span> <span class="operator">=</span> validatingBuilder.build();</span><br><span class="line">         mCaptureSession.setSessionConfig(sessionConfig);</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Camera 获取 Capture的SessionConfig，通过`CaptureSession`进行状态控制</span><br></pre></td></tr></table></figure><h3 id="CaptureSession-setSessionConfig"><a href="#CaptureSession-setSessionConfig" class="headerlink" title="CaptureSession.setSessionConfig"></a>CaptureSession.setSessionConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setSessionConfig</span><span class="params">(SessionConfig sessionConfig)</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mStateLock) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> UNINITIALIZED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;setSessionConfig() should not be possible in state: &quot;</span> + mState);</span><br><span class="line">            <span class="keyword">case</span> INITIALIZED:</span><br><span class="line">            <span class="keyword">case</span> OPENING:</span><br><span class="line">               mSessionConfig = sessionConfig;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OPENED:</span><br><span class="line">               mSessionConfig = sessionConfig;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!mConfiguredSurfaceMap.keySet().containsAll(sessionConfig.getSurfaces())) &#123;</span><br><span class="line">                  Log.e(TAG, <span class="string">&quot;Does not have the proper configured lists&quot;</span>);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Log.d(TAG, <span class="string">&quot;Attempting to submit CaptureRequest after setting&quot;</span>);</span><br><span class="line">               issueRepeatingCaptureRequests();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSED:</span><br><span class="line">            <span class="keyword">case</span> RELEASING:</span><br><span class="line">            <span class="keyword">case</span> RELEASED:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                        <span class="string">&quot;Session configuration cannot be set on a closed/released session.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Camera的OPENED状态，则进行拍照流程</p><h3 id="issueRepeatingCaptureRequests"><a href="#issueRepeatingCaptureRequests" class="headerlink" title="issueRepeatingCaptureRequests"></a>issueRepeatingCaptureRequests</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">issueRepeatingCaptureRequests</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   CameraCaptureSession.<span class="type">CaptureCallback</span> <span class="variable">comboCaptureCallback</span> <span class="operator">=</span></span><br><span class="line">                    createCamera2CaptureCallback(</span><br><span class="line">                            captureConfig.getCameraCaptureCallbacks(),</span><br><span class="line">                            mCaptureCallback);</span><br><span class="line"></span><br><span class="line">   CameraCaptureSessionCompat.setSingleRepeatingRequest(mCameraCaptureSession,</span><br><span class="line">                    captureRequest, mExecutor, comboCaptureCallback);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CameraCaptureSessionCompat</code>根据 Android 版本有<code>CameraCaptureSessionCompatBaseImpl</code>和<code>CameraCaptureSessionCompatApi28Impl</code>两种实现，最终通过<code>CameraCaptureSession</code>实现真正的拍照。<br>拍照完成后，通过最开始设置的 Listener 进行回调</p><h3 id="ImageCapture-createPipeline"><a href="#ImageCapture-createPipeline" class="headerlink" title="ImageCapture.createPipeline"></a>ImageCapture.createPipeline</h3><p>在 Preview 那小节，讲解过 bindToLifecycle 流程，这里的<code>ImageCapture</code>也是一个<code>UseCase</code>。在CameraX中的<code>calculateSuggestedResolutions</code>方法，最终会调用到各个<code>UseCase</code>的<code>onSuggestedResolutionUpdated</code>方法。在<code>ImageCapture</code>的<code>onSuggestedResolutionUpdated</code>方法，通过<code>createPipeline</code>创建了拍照数据的回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">SessionConfig.Builder <span class="title function_">createPipeline</span><span class="params">(ImageCaptureConfig config,  Size resolution)</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">//和 Camera2的流程一致</span></span><br><span class="line">   mProcessingImageResultThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;OnImageAvailableHandlerThread&quot;</span>);</span><br><span class="line">   mProcessingImageResultThread.start();</span><br><span class="line">   mProcessingImageResultHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mProcessingImageResultThread.getLooper());</span><br><span class="line">   ...</span><br><span class="line">   mImageReader.setOnImageAvailableListener(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ImageReaderProxy</span>.OnImageAvailableListener() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onImageAvailable</span><span class="params">(ImageReaderProxy imageReader)</span> &#123;</span><br><span class="line">            <span class="type">ImageProxy</span> <span class="variable">image</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                  image = imageReader.acquireLatestImage();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">                  Log.e(TAG, <span class="string">&quot;Failed to acquire latest image.&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (image != <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// Call the head request listener to process the captured image.</span></span><br><span class="line">                     ImageCaptureRequest imageCaptureRequest;</span><br><span class="line">                     <span class="keyword">if</span> ((imageCaptureRequest = mImageCaptureRequests.peek()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">SingleCloseImageProxy</span> <span class="variable">wrappedImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleCloseImageProxy</span>(</span><br><span class="line">                                 image);</span><br><span class="line">                        wrappedImage.addOnImageCloseListener(mOnImageCloseListener);</span><br><span class="line">                        <span class="comment">//ImageCaptureRequest设置 Listener</span></span><br><span class="line">                        imageCaptureRequest.dispatchImage(wrappedImage);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Discard the image if we have no requests.</span></span><br><span class="line">                        image.close();</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      mProcessingImageResultHandler);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImageReader设置了 Camera 数据会调用，并通过<code>ImageCaptureRequest</code>的<code>dispatchImage</code>方法进行分发</p><h3 id="ImageCaptureRequest-dispatchImage"><a href="#ImageCaptureRequest-dispatchImage" class="headerlink" title="ImageCaptureRequest.dispatchImage"></a>ImageCaptureRequest.dispatchImage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchImage</span><span class="params">(<span class="keyword">final</span> ImageProxy image)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">         mListenerExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="type">Size</span> <span class="variable">sourceSize</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Size</span>(image.getWidth(), image.getHeight());</span><br><span class="line">               <span class="keyword">if</span> (ImageUtil.isAspectRatioValid(sourceSize, mTargetRatio)) &#123;</span><br><span class="line">                     image.setCropRect(</span><br><span class="line">                           ImageUtil.computeCropRectFromAspectRatio(sourceSize,</span><br><span class="line">                                    mTargetRatio));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//真正的回调</span></span><br><span class="line">               mListener.onCaptureSuccess(image, mRotationDegrees);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">         Log.e(TAG, <span class="string">&quot;Unable to post to the supplied executor.&quot;</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Unable to execute on the supplied executor, close the image.</span></span><br><span class="line">         image.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mListener</code>是一个封装Listener，在<code>ImageCapture</code>中实现</p><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener的关系图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">|                       |</span><br><span class="line">|ImageCapture.          |</span><br><span class="line">|OnImageCapturedListener|</span><br><span class="line">|                       |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">+-----------v-----------+      +----------------------+</span><br><span class="line">|                       |      |                      |</span><br><span class="line">| ImageSaver.           |      | ImageCapture.        |</span><br><span class="line">| OnImageSavedListener  +------&gt; OnImageSavedListener |</span><br><span class="line">|                       |      |                      |</span><br><span class="line">+-----------------------+      +----------------------+</span><br></pre></td></tr></table></figure><p><code>OnImageCapturedListener</code>的实现，其中通过<code>ImageSaver</code>设置的<code>OnImageSavedListener</code>回调到最上层的<code>OnImageSavedListener</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OnImageCapturedListener</span> <span class="variable">imageCaptureCallbackWrapper</span> <span class="operator">=</span></span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">OnImageCapturedListener</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureSuccess</span><span class="params">(ImageProxy image, <span class="type">int</span> rotationDegrees)</span> &#123;</span><br><span class="line">         CameraXExecutors.ioExecutor()</span><br><span class="line">                  .execute(</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">ImageSaver</span>(</span><br><span class="line">                                 image,</span><br><span class="line">                                 saveLocation,</span><br><span class="line">                                 rotationDegrees,</span><br><span class="line">                                 metadata.isReversedHorizontal,</span><br><span class="line">                                 metadata.isReversedVertical,</span><br><span class="line">                                 metadata.location,</span><br><span class="line">                                 executor,</span><br><span class="line">                                 imageSavedListenerWrapper));</span><br><span class="line">      &#125;</span><br><span class="line">   ...</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="comment">// ImageSaver是一个 Runnable，主要 run 的实现</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImageSaver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//图像处理</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (saveError != <span class="literal">null</span>) &#123;</span><br><span class="line">         postError(saveError, errorMessage, exception);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         postSuccess();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">      mExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//最外层回调</span></span><br><span class="line">            mListener.onImageSaved(mFile);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个拍照流程和数据回调就讲解完毕了。<br>通过对 CameraX的 Preview 和 ImageCapture的分析，CameraX对Camera2进行完整的封装，统一参数配置，自动计算Resolution，简化Camera2的开发，并增加了生命周期控制，对外只暴露了简单接口。<br>使用该库，只需要简单的几行代码就可以实现以前Camera2复杂的操作。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/training/camerax/architecture">CameraX 架构</a></li><li><a href="https://medium.com/androiddevelopers/core-principles-behind-camerax-jetpack-library-8e8380f7604c">Core Principles Behind CameraX Jetpack Library</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面一篇文章中，已经介绍了如何使用 CameraX，这篇文章就分析下 CameraX 主要流程的源码。&lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="CameraX" scheme="http://yeungeek.github.io/tags/CameraX/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-CameraView源码分析</title>
    <link href="http://yeungeek.github.io/2020/01/29/AndroidCamera-CameraViewAnalysis/"/>
    <id>http://yeungeek.github.io/2020/01/29/AndroidCamera-CameraViewAnalysis/</id>
    <published>2020-01-29T15:54:31.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>在前面文章中已经介绍了如何使用 <a href="https://github.com/google/cameraview">CameraView</a>，这是 Google 官方提供的库，并有相关 demo，因为 Android 的碎片化太严重，官方也是考虑到这些，才提供了<a href="https://github.com/google/cameraview">CameraView</a>供大家学习和参考。     </p><span id="more"></span><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><a href="https://imgchr.com/i/1WWkn0"><img src="https://s2.ax1x.com/2020/02/08/1WWkn0.png" alt="源码结构"></a><br>根据官方的说明： </p><table><thead><tr><th align="center">API Level</th><th>Camera API</th><th>Preview View</th></tr></thead><tbody><tr><td align="center">9-13</td><td>Camera1</td><td>SurfaceView</td></tr><tr><td align="center">14-20</td><td>Camera1</td><td>TextureView</td></tr><tr><td align="center">21-23</td><td>Camera2</td><td>TextureView</td></tr><tr><td align="center">24</td><td>Camera2</td><td>SurfaceView</td></tr></tbody></table><p>具体的实现都在<a href="https://github.com/google/cameraview/blob/master/library/src/main/java/com/google/android/cameraview/CameraView.java">CameraView类</a>中。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>源码中涉及到的主要类之间的关系，是从最新的源码中查看到(跟官网的表格不太一样，最新的源码sdk最低版本为14)：<br><img src="https://s2.ax1x.com/2020/02/13/1OoPpD.png" alt="CameraView"></p><ul><li>Camera 区分：Android5.0(21)以下使用 Camera1，以上使用 Camera2</li><li>Preview View：Android6.0(23)以上使用SurfaceView(SurfaceView在Android7.0上增加了新特性(平移、旋转等))，这里应该是 Android7.0以上(&gt;23)使用SurfaceView，其他都使用TextureView，最新的源码sdk最低版本要求14。</li></ul><h2 id="CameraView"><a href="#CameraView" class="headerlink" title="CameraView"></a>CameraView</h2><p>CameraView使用非常简单，在 CameraView 使用那篇文章已经做过详细说明。 </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.cameraview.CameraView</span><br><span class="line">    android:id=<span class="string">&quot;@+id/camera&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:keepScreenOn=<span class="string">&quot;true&quot;</span></span><br><span class="line">    android:adjustViewBounds=<span class="string">&quot;true&quot;</span></span><br><span class="line">    app:autoFocus=<span class="string">&quot;true&quot;</span></span><br><span class="line">    app:aspectRatio=<span class="string">&quot;4:3&quot;</span></span><br><span class="line">    app:facing=<span class="string">&quot;back&quot;</span></span><br><span class="line">    app:flash=<span class="string">&quot;auto&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>直接看下<code>CameraView</code>的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CameraView</span><span class="params">(Context context, AttributeSet attrs, <span class="type">int</span> defStyleAttr)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Internal setup</span></span><br><span class="line">   <span class="comment">// 1.创建预览视图</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">PreviewImpl</span> <span class="variable">preview</span> <span class="operator">=</span> createPreviewImpl(context);</span><br><span class="line">   mCallbacks = <span class="keyword">new</span> <span class="title class_">CallbackBridge</span>();</span><br><span class="line">   <span class="comment">// 2.根据 Android SDK 版本选择不同的 Camera</span></span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">21</span>) &#123;</span><br><span class="line">      mImpl = <span class="keyword">new</span> <span class="title class_">Camera1</span>(mCallbacks, preview);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">23</span>) &#123;</span><br><span class="line">      mImpl = <span class="keyword">new</span> <span class="title class_">Camera2</span>(mCallbacks, preview, context);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mImpl = <span class="keyword">new</span> <span class="title class_">Camera2Api23</span>(mCallbacks, preview, context);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Attributes</span></span><br><span class="line">   <span class="comment">// 3. 读取自定义 View 属性, 设置相机摄像头位置、预览画面比例、对焦方式、闪光灯</span></span><br><span class="line">   <span class="type">TypedArray</span> <span class="variable">a</span> <span class="operator">=</span> context.obtainStyledAttributes(attrs, R.styleable.CameraView, defStyleAttr,</span><br><span class="line">            R.style.Widget_CameraView);</span><br><span class="line">   mAdjustViewBounds = a.getBoolean(R.styleable.CameraView_android_adjustViewBounds, <span class="literal">false</span>);</span><br><span class="line">   setFacing(a.getInt(R.styleable.CameraView_facing, FACING_BACK));</span><br><span class="line">   <span class="type">String</span> <span class="variable">aspectRatio</span> <span class="operator">=</span> a.getString(R.styleable.CameraView_aspectRatio);</span><br><span class="line">   <span class="keyword">if</span> (aspectRatio != <span class="literal">null</span>) &#123;</span><br><span class="line">      setAspectRatio(AspectRatio.parse(aspectRatio));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setAspectRatio(Constants.DEFAULT_ASPECT_RATIO);</span><br><span class="line">   &#125;</span><br><span class="line">   setAutoFocus(a.getBoolean(R.styleable.CameraView_autoFocus, <span class="literal">true</span>));</span><br><span class="line">   setFlash(a.getInt(R.styleable.CameraView_flash, Constants.FLASH_AUTO));</span><br><span class="line">   a.recycle();</span><br><span class="line">   <span class="comment">// Display orientation detector</span></span><br><span class="line">   <span class="comment">// 4. 增加旋转方向监听，设置相机的旋转方向</span></span><br><span class="line">   mDisplayOrientationDetector = <span class="keyword">new</span> <span class="title class_">DisplayOrientationDetector</span>(context) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisplayOrientationChanged</span><span class="params">(<span class="type">int</span> displayOrientation)</span> &#123;</span><br><span class="line">            mImpl.setDisplayOrientation(displayOrientation);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createPreviewImpl</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PreviewImpl <span class="title function_">createPreviewImpl</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">   PreviewImpl preview;</span><br><span class="line">   <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">      preview = <span class="keyword">new</span> <span class="title class_">SurfaceViewPreview</span>(context, <span class="built_in">this</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      preview = <span class="keyword">new</span> <span class="title class_">TextureViewPreview</span>(context, <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> preview;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要代码角度看下CameraView版本选择策略，在最开始的已经说明。<br>Camera的选择：api &lt;21的，使用Camera1，&gt;&#x3D;21使用 Camera2，这里完全没有问题。<br>Camera Preview的选择，存在几个疑问，api &gt;&#x3D;23使用SurfaceView，不过api 24的时候使用SurfaceView才是官方推荐的。  </p><blockquote><p>Starting in platform version N, SurfaceView’s window position is updated synchronously with other View rendering. This means that translating and scaling a SurfaceView on screen will not cause rendering artifacts. Such artifacts may occur on previous versions of the platform when its window is positioned asynchronously.</p></blockquote><p>这里应该 api &gt;23使用SurfaceView，其他情况使用TextureView，因为在工程中 定义了<code>minSdkVersion = 14</code>，api 14-23使用TextureView，表格可以更新为：</p><table><thead><tr><th align="center">API Level</th><th>Camera API</th><th>Preview View</th></tr></thead><tbody><tr><td align="center">14-20</td><td>Camera1</td><td>TextureView</td></tr><tr><td align="center">21-23</td><td>Camera2</td><td>TextureView</td></tr><tr><td align="center">24</td><td>Camera2</td><td>SurfaceView</td></tr></tbody></table><h3 id="Preview定义"><a href="#Preview定义" class="headerlink" title="Preview定义"></a>Preview定义</h3><p><code>PreviewImpl</code>封装了预览控件的操作方法，<code>SurfaceViewPreview</code>和<code>TextureViewPreview</code>分别对应<code>SurfaceView</code>和<code>TextureView</code>的<code>PreviewImpl</code>实现。  </p><h4 id="SurfaceViewPreview"><a href="#SurfaceViewPreview" class="headerlink" title="SurfaceViewPreview"></a>SurfaceViewPreview</h4><p>实现很简单，直接加载有<code>SurfaceView</code>控件的布局，并封装了<code>SurfaceHolder</code>操作</p><h4 id="TextureViewPreview"><a href="#TextureViewPreview" class="headerlink" title="TextureViewPreview"></a>TextureViewPreview</h4><p>直接加载有<code>TextureView</code>控件布局，并监听<code>TextureView.SurfaceTextureListener</code>。</p><h3 id="Camera定义"><a href="#Camera定义" class="headerlink" title="Camera定义"></a>Camera定义</h3><p><code>CameraViewImpl</code>定义了相机的各种操作，<code>Camera1</code>、<code>Camera2</code>、<code>Camera2Api23</code>都是<code>CameraViewImpl</code>的具体实现。<br>看下它们的构造函数:<br><code>Camera1</code>   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Camera1(Callback callback, PreviewImpl preview) &#123;</span><br><span class="line">   <span class="built_in">super</span>(callback, preview);</span><br><span class="line">   preview.setCallback(<span class="keyword">new</span> <span class="title class_">PreviewImpl</span>.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">               setUpPreview();</span><br><span class="line">               adjustCameraParameters();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加了 Callback，当SurfaceChanged的时候，设置预览和 Camera 参数。<br><code>Camera2</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Camera2(Callback callback, PreviewImpl preview, Context context) &#123;</span><br><span class="line">   <span class="built_in">super</span>(callback, preview);</span><br><span class="line">   mCameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">   mPreview.setCallback(<span class="keyword">new</span> <span class="title class_">PreviewImpl</span>.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSurfaceChanged</span><span class="params">()</span> &#123;</span><br><span class="line">            startCaptureSession();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.初始化了<code>CameraManager</code><br>2.增加Callback，当SurfaceChanged的时候，对CaptureSession进行设置  </p><p><code>Camera2Api23</code>继承了<code>Camera2</code>，重用了<code>Camera2</code>的构造。<br>Camera1和 Camera2的实现和使用流程，可以参考前面的几篇文章，接下来介绍<code>CameraView</code>的几个重要方法的实现。</p><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!mImpl.start()) &#123;</span><br><span class="line">      <span class="comment">//store the state ,and restore this state after fall back o Camera1</span></span><br><span class="line">      <span class="type">Parcelable</span> <span class="variable">state</span> <span class="operator">=</span> onSaveInstanceState();</span><br><span class="line">      <span class="comment">// Camera2 uses legacy hardware layer; fall back to Camera1</span></span><br><span class="line">      mImpl = <span class="keyword">new</span> <span class="title class_">Camera1</span>(mCallbacks, createPreviewImpl(getContext()));</span><br><span class="line">      onRestoreInstanceState(state);</span><br><span class="line">      mImpl.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启相机，首先判断是否可以开启，如果不能开启，默认会使用 Camera1。</p><h4 id="Camera1-start"><a href="#Camera1-start" class="headerlink" title="Camera1.start"></a>Camera1.start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1. 选择摄像头</span></span><br><span class="line">   chooseCamera();</span><br><span class="line">   <span class="comment">//2. 打开摄像头</span></span><br><span class="line">   openCamera();</span><br><span class="line">   <span class="comment">//3. 设置预览</span></span><br><span class="line">   <span class="keyword">if</span> (mPreview.isReady()) &#123;</span><br><span class="line">      setUpPreview();</span><br><span class="line">   &#125;</span><br><span class="line">   mShowingPreview = <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">//4. 开始预览</span></span><br><span class="line">   mCamera.startPreview();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的流程，可以参考<a href="/2020/01/17/AndroidCamera-UsingCamera1/">Camera1使用</a>，这里介绍几个重要的方法。<br>1.<code>chooseCamera</code>会遍历所有摄像头，然后根据<code>CameraView</code>初始化时传入的值进行对比，默认是<code>FACING_BACK</code>后置摄像头。<br>2.<code>openCamera</code>方法，这里具体展开介绍下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">openCamera</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">      releaseCamera();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1. 打开摄像头</span></span><br><span class="line">   mCamera = Camera.open(mCameraId);</span><br><span class="line">   mCameraParameters = mCamera.getParameters();</span><br><span class="line">   <span class="comment">// Supported preview sizes</span></span><br><span class="line">   mPreviewSizes.clear();</span><br><span class="line">   <span class="comment">//2. 获取所有支持的预览尺寸</span></span><br><span class="line">   <span class="keyword">for</span> (Camera.Size size : mCameraParameters.getSupportedPreviewSizes()) &#123;</span><br><span class="line">      Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;###### SupportedPreviewSizes: width=&quot;</span> + size.width + <span class="string">&quot;, height=&quot;</span></span><br><span class="line">               + size.height);</span><br><span class="line">      mPreviewSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.width, size.height));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Supported picture sizes;</span></span><br><span class="line">   mPictureSizes.clear();</span><br><span class="line">   <span class="comment">//3. 获取所有支持的拍照尺寸</span></span><br><span class="line">   <span class="keyword">for</span> (Camera.Size size : mCameraParameters.getSupportedPictureSizes()) &#123;</span><br><span class="line">      Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;###### SupportedPictureSizes: width=&quot;</span> + size.width + <span class="string">&quot;, height=&quot;</span></span><br><span class="line">               + size.height);</span><br><span class="line">      mPictureSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.width, size.height));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// AspectRatio</span></span><br><span class="line">   <span class="keyword">if</span> (mAspectRatio == <span class="literal">null</span>) &#123;</span><br><span class="line">      mAspectRatio = Constants.DEFAULT_ASPECT_RATIO;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4. 设置预览比例</span></span><br><span class="line">   adjustCameraParameters();</span><br><span class="line">   mCamera.setDisplayOrientation(calcDisplayOrientation(mDisplayOrientation));</span><br><span class="line">   mCallback.onCameraOpened();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<code>setUpPreview</code>设置预览</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setUpPreview</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mPreview.getOutputClass() == SurfaceHolder.class) &#123;</span><br><span class="line">            mCamera.setPreviewDisplay(mPreview.getSurfaceHolder());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mCamera.setPreviewTexture((SurfaceTexture) mPreview.getSurfaceTexture());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据mPreview类型的不同，使用<code>SurfaceView</code>预览或者<code>TextureView</code>预览。<br>4.<code>mCamera.startPreview()</code>开启预览</p><h4 id="Camera2-start"><a href="#Camera2-start" class="headerlink" title="Camera2.start"></a>Camera2.start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1. 选择摄像头，默认后置摄像头</span></span><br><span class="line">   <span class="keyword">if</span> (!chooseCameraIdByFacing()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2. 设置预览尺寸，预览尺寸比例，拍照尺寸，其他相关设置</span></span><br><span class="line">   collectCameraInfo();</span><br><span class="line">   <span class="comment">//3. 初始化 ImageReader，并设置回调</span></span><br><span class="line">   prepareImageReader();</span><br><span class="line">   <span class="comment">//4. 打开摄像头</span></span><br><span class="line">   startOpeningCamera();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体流程可以参考<a href="/2020/01/19/AndroidCamera-UsingCamera2/">Camera2使用</a>，这里只介绍重要方法说明。<br>1.<code>chooseCameraIdByFacing</code>遍历支持的摄像头列表，根据条件筛选获取到指定的摄像头，默认后置摄像头。<br>2.<code>collectCameraInfo</code>方法，获取所有支持预览尺寸，和拍照尺寸，并获取支持的预览尺寸比例<br>3.<code>prepareImageReader</code>方法，初始化ImageReader  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareImageReader</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mImageReader != <span class="literal">null</span>) &#123;</span><br><span class="line">      mImageReader.close();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">Size</span> <span class="variable">largest</span> <span class="operator">=</span> mPictureSizes.sizes(mAspectRatio).last();</span><br><span class="line">   mImageReader = ImageReader.newInstance(largest.getWidth(), largest.getHeight(),</span><br><span class="line">            ImageFormat.JPEG, <span class="comment">/* maxImages */</span> <span class="number">2</span>);</span><br><span class="line">   mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置输出格式为 JPEG，并增加<code>ImageAvailableListener</code>回调监听。<br>4.<code>startOpeningCamera</code>方法，打开摄像头，并设置<code>CameraDevice.StateCallback</code>监听  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOpeningCamera</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mCameraManager.openCamera(mCameraId, mCameraDeviceCallback, <span class="literal">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to open camera: &quot;</span> + mCameraId, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraDevice.<span class="type">StateCallback</span> <span class="variable">mCameraDeviceCallback</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraDevice</span>.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">      mCamera = camera;</span><br><span class="line">      mCallback.onCameraOpened();</span><br><span class="line">      <span class="comment">//相机打开，开启预览画面</span></span><br><span class="line">      startCaptureSession();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosed</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">      mCallback.onCameraClosed();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisconnected</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">      mCamera = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera, <span class="type">int</span> error)</span> &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;onError: &quot;</span> + camera.getId() + <span class="string">&quot; (&quot;</span> + error + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">      mCamera = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>监听相机打开后，开启预览画面，<code>startCaptureSession</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">startCaptureSession</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isCameraOpened() || !mPreview.isReady() || mImageReader == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1. 选择最合适的预览尺寸</span></span><br><span class="line">   <span class="type">Size</span> <span class="variable">previewSize</span> <span class="operator">=</span> chooseOptimalSize();</span><br><span class="line">   mPreview.setBufferSize(previewSize.getWidth(), previewSize.getHeight());</span><br><span class="line">   <span class="type">Surface</span> <span class="variable">surface</span> <span class="operator">=</span> mPreview.getSurface();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//2. 创建预览请求</span></span><br><span class="line">      mPreviewRequestBuilder = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">      <span class="comment">//3. 请求管理 target surface</span></span><br><span class="line">      mPreviewRequestBuilder.addTarget(surface);</span><br><span class="line">      <span class="comment">//4. 创建CaptureSession，并增加Session监听</span></span><br><span class="line">      mCamera.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),</span><br><span class="line">               mSessionCallback, <span class="literal">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failed to start camera session&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听<code>CameraCaptureSession</code>状态的回调声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraCaptureSession.<span class="type">StateCallback</span> <span class="variable">mSessionCallback</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraCaptureSession</span>.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigured</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCamera == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      mCaptureSession = session;</span><br><span class="line">      updateAutoFocus();</span><br><span class="line">      updateFlash();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//1. 开启预览，并设置监听回调</span></span><br><span class="line">            mCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(),</span><br><span class="line">                  mCaptureCallback, <span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to start camera preview because it couldn&#x27;t access camera&quot;</span>, e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to start camera preview.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigureFailed</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Failed to configure capture session.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosed</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCaptureSession != <span class="literal">null</span> &amp;&amp; mCaptureSession.equals(session)) &#123;</span><br><span class="line">            mCaptureSession = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="takePicture"><a href="#takePicture" class="headerlink" title="takePicture"></a>takePicture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takePicture</span><span class="params">()</span> &#123;</span><br><span class="line">   mImpl.takePicture();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 api 选择不同的实现</p><h4 id="Camera1-takePicture"><a href="#Camera1-takePicture" class="headerlink" title="Camera1.takePicture"></a>Camera1.takePicture</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">takePicture</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isCameraOpened()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">               <span class="string">&quot;Camera is not ready. Call start() before takePicture().&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//1. 判断是否自动对焦</span></span><br><span class="line">   <span class="keyword">if</span> (getAutoFocus()) &#123;</span><br><span class="line">      mCamera.cancelAutoFocus();</span><br><span class="line">      mCamera.autoFocus(<span class="keyword">new</span> <span class="title class_">Camera</span>.AutoFocusCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAutoFocus</span><span class="params">(<span class="type">boolean</span> success, Camera camera)</span> &#123;</span><br><span class="line">               <span class="comment">//2. 拍照</span></span><br><span class="line">               takePictureInternal();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2.拍照</span></span><br><span class="line">      takePictureInternal();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正执行拍照的方法<code>takePictureInternal</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">takePictureInternal</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isPictureCaptureInProgress.getAndSet(<span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="comment">//1. 拍照增加回调</span></span><br><span class="line">      mCamera.takePicture(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Camera</span>.PictureCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPictureTaken</span><span class="params">(<span class="type">byte</span>[] data, Camera camera)</span> &#123;</span><br><span class="line">               isPictureCaptureInProgress.set(<span class="literal">false</span>);</span><br><span class="line">               <span class="comment">//2. 把 data 传到上层的回调</span></span><br><span class="line">               mCallback.onPictureTaken(data);</span><br><span class="line">               camera.cancelAutoFocus();</span><br><span class="line">               camera.startPreview();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>takePicture</code>中增加的 jpeg 的<code>PictureCallback</code>回调，返回的data通过callback回调到上层</p><h4 id="Camera2-takePicture"><a href="#Camera2-takePicture" class="headerlink" title="Camera2.takePicture"></a>Camera2.takePicture</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">takePicture</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1.判断自动对焦</span></span><br><span class="line">   <span class="keyword">if</span> (mAutoFocus) &#123;</span><br><span class="line">      lockFocus();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//2. 拍照请求</span></span><br><span class="line">      captureStillPicture();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置对焦</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lockFocus</span><span class="params">()</span> &#123;</span><br><span class="line">   mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">            CaptureRequest.CONTROL_AF_TRIGGER_START);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mCaptureCallback.setState(PictureCaptureCallback.STATE_LOCKING);</span><br><span class="line">      mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, <span class="literal">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Failed to lock focus.&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PictureCaptureCallback</span></span><br><span class="line"><span class="type">PictureCaptureCallback</span> <span class="variable">mCaptureCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PictureCaptureCallback</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPrecaptureRequired</span><span class="params">()</span> &#123;</span><br><span class="line">      mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,</span><br><span class="line">               CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);</span><br><span class="line">      setState(STATE_PRECAPTURE);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">            mCaptureSession.capture(mPreviewRequestBuilder.build(), <span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,</span><br><span class="line">                  CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_IDLE);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to run precapture sequence.&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReady</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//2. 拍照请求</span></span><br><span class="line">      captureStillPicture();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>判断是否自动对焦，最后调用<code>captureStillPicture</code>方法进行拍照请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">captureStillPicture</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1. 创建TEMPLATE_STILL_CAPTURE的Capture请求</span></span><br><span class="line">      CaptureRequest.<span class="type">Builder</span> <span class="variable">captureRequestBuilder</span> <span class="operator">=</span> mCamera.createCaptureRequest(</span><br><span class="line">               CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">      <span class="comment">//2. 添加target</span></span><br><span class="line">      captureRequestBuilder.addTarget(mImageReader.getSurface());</span><br><span class="line">      <span class="comment">//3. 设置 AF mode</span></span><br><span class="line">      captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">               mPreviewRequestBuilder.get(CaptureRequest.CONTROL_AF_MODE));</span><br><span class="line">      <span class="comment">//4.flash模式设置</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// Calculate JPEG orientation.</span></span><br><span class="line">      <span class="comment">//5. 计算拍照图片的方向</span></span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;ConstantConditions&quot;)</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">sensorOrientation</span> <span class="operator">=</span> mCameraCharacteristics.get(</span><br><span class="line">               CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line">      captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION,</span><br><span class="line">               (sensorOrientation +</span><br><span class="line">                        mDisplayOrientation * (mFacing == Constants.FACING_FRONT ? <span class="number">1</span> : -<span class="number">1</span>) +</span><br><span class="line">                        <span class="number">360</span>) % <span class="number">360</span>);</span><br><span class="line">      <span class="comment">// Stop preview and capture a still picture.</span></span><br><span class="line">      <span class="comment">//6. 停止预览</span></span><br><span class="line">      mCaptureSession.stopRepeating();</span><br><span class="line">      <span class="comment">//7. 拍照</span></span><br><span class="line">      mCaptureSession.capture(captureRequestBuilder.build(),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">CameraCaptureSession</span>.CaptureCallback() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureCompleted</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session,</span></span><br><span class="line"><span class="params">                           <span class="meta">@NonNull</span> CaptureRequest request,</span></span><br><span class="line"><span class="params">                           <span class="meta">@NonNull</span> TotalCaptureResult result)</span> &#123;</span><br><span class="line">                        <span class="comment">//8. 取消对焦</span></span><br><span class="line">                        unlockFocus();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, <span class="literal">null</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Cannot capture a still picture.&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消对焦，重新设置预览</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlockFocus</span><span class="params">()</span> &#123;</span><br><span class="line">   mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">            CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, <span class="literal">null</span>);</span><br><span class="line">      updateAutoFocus();</span><br><span class="line">      updateFlash();</span><br><span class="line">      mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">               CaptureRequest.CONTROL_AF_TRIGGER_IDLE);</span><br><span class="line">      mCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(), mCaptureCallback,</span><br><span class="line">               <span class="literal">null</span>);</span><br><span class="line">      mCaptureCallback.setState(PictureCaptureCallback.STATE_PREVIEW);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      Log.e(TAG, <span class="string">&quot;Failed to restart camera preview.&quot;</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拍照后真正的数据回调，是在初始化 ImageReader 的<code>OnImageAvailableListener</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageReader.<span class="type">OnImageAvailableListener</span> <span class="variable">mOnImageAvailableListener</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageReader</span>.OnImageAvailableListener() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onImageAvailable</span><span class="params">(ImageReader reader)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> (<span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> reader.acquireNextImage()) &#123;</span><br><span class="line">            Image.Plane[] planes = image.getPlanes();</span><br><span class="line">            <span class="keyword">if</span> (planes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> planes[<span class="number">0</span>].getBuffer();</span><br><span class="line">               <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.remaining()];</span><br><span class="line">               buffer.get(data);</span><br><span class="line">               <span class="comment">//1. 数据回调到上层</span></span><br><span class="line">               mCallback.onPictureTaken(data);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>如果不用拍照，或者退出应用，调用 stop 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">   mImpl.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Camera1-stop"><a href="#Camera1-stop" class="headerlink" title="Camera1.stop"></a>Camera1.stop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//1. 停止预览</span></span><br><span class="line">      mCamera.stopPreview();</span><br><span class="line">   &#125;</span><br><span class="line">   mShowingPreview = <span class="literal">false</span>;</span><br><span class="line">   <span class="comment">//2. 释放相机资源</span></span><br><span class="line">   releaseCamera();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放相机资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">releaseCamera</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">      mCamera.release();</span><br><span class="line">      mCamera = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">//1. 回调上层</span></span><br><span class="line">      mCallback.onCameraClosed();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Camera2-stop"><a href="#Camera2-stop" class="headerlink" title="Camera2.stop"></a>Camera2.stop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1. 关闭 session</span></span><br><span class="line">   <span class="keyword">if</span> (mCaptureSession != <span class="literal">null</span>) &#123;</span><br><span class="line">      mCaptureSession.close();</span><br><span class="line">      mCaptureSession = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2. 关闭 Camera</span></span><br><span class="line">   <span class="keyword">if</span> (mCamera != <span class="literal">null</span>) &#123;</span><br><span class="line">      mCamera.close();</span><br><span class="line">      mCamera = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3. 关闭 ImageReader</span></span><br><span class="line">   <span class="keyword">if</span> (mImageReader != <span class="literal">null</span>) &#123;</span><br><span class="line">      mImageReader.close();</span><br><span class="line">      mImageReader = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraView源码相关的分析就结束了，该库很好的封装了 Camera1和 Camera2的使用，本篇文章对其中的重点方法进行了分析，讲解了它的实现原理，希望对大家有所帮助。</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://www.jianshu.com/p/0ac7234dcefc">Android相机开发——CameraView源码解析</a></li><li><a href="https://www.jianshu.com/p/f63f296a920b">Android Camera 编程从入门到精通</a></li><li><a href="https://blog.csdn.net/shanshui911587154/article/details/90290535">Android——谷歌cameraview详解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面文章中已经介绍了如何使用 &lt;a href=&quot;https://github.com/google/cameraview&quot;&gt;CameraView&lt;/a&gt;，这是 Google 官方提供的库，并有相关 demo，因为 Android 的碎片化太严重，官方也是考虑到这些，才提供了&lt;a href=&quot;https://github.com/google/cameraview&quot;&gt;CameraView&lt;/a&gt;供大家学习和参考。     &lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="SurfaceView" scheme="http://yeungeek.github.io/tags/SurfaceView/"/>
    
    <category term="TextureView" scheme="http://yeungeek.github.io/tags/TextureView/"/>
    
    <category term="CameraView" scheme="http://yeungeek.github.io/tags/CameraView/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-相机尺寸、方向和图像数据</title>
    <link href="http://yeungeek.github.io/2020/01/24/AndroidCamera-Orientation/"/>
    <id>http://yeungeek.github.io/2020/01/24/AndroidCamera-Orientation/</id>
    <published>2020-01-24T00:14:31.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇文章介绍了Camera1，Camera2，CameraView和CameraX的使用，对各个API的使用，应该问题不大，不过在真正开发过程中，也会遇到各种不同的问题，本篇文章继续介绍相机开发过程中遇到的问题，主要是相机预览、拍照尺寸，方向，以及图像数据的处理。</p><span id="more"></span><h1 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h1><p>这里的尺寸，主要是预览尺寸、拍照尺寸和显示预览画面的View大小。  </p><h2 id="预览尺寸"><a href="#预览尺寸" class="headerlink" title="预览尺寸"></a>预览尺寸</h2><p>如何获取预览尺寸?我们可以从<a href="https://github.com/google/cameraview">cameraview</a>的源码中获取到，分为了Camera1和Camera2。   </p><h3 id="Camera1"><a href="#Camera1" class="headerlink" title="Camera1"></a>Camera1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mCameraParameters = mCamera.getParameters();</span><br><span class="line"><span class="comment">// Supported preview sizes</span></span><br><span class="line">mPreviewSizes.clear();</span><br><span class="line"><span class="keyword">for</span> (Camera.Size size : mCameraParameters.getSupportedPreviewSizes()) &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;###### SupportedPreviewSizes: width=&quot;</span> + size.width + <span class="string">&quot;, height=&quot;</span></span><br><span class="line">            + size.height);</span><br><span class="line">    mPreviewSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.width, size.height));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mPreviewSizes.clear();</span><br><span class="line"><span class="keyword">for</span> (android.util.Size size : map.getOutputSizes(mPreview.getOutputClass())) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> size.getWidth();</span><br><span class="line">    <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> size.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (width &lt;= MAX_PREVIEW_WIDTH &amp;&amp; height &lt;= MAX_PREVIEW_HEIGHT) &#123;</span><br><span class="line">        mPreviewSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(width, height));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的厂商和系统所支持的预览尺寸是不一样，下面是红米Note 5A手机上支持的所有预览尺寸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SupportedPreviewSizes: width=<span class="number">1280</span>, height=<span class="number">720</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">960</span>, height=<span class="number">720</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">864</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">800</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">768</span>, height=<span class="number">432</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">720</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">640</span>, height=<span class="number">640</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">640</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">480</span>, height=<span class="number">640</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">640</span>, height=<span class="number">360</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">576</span>, height=<span class="number">432</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">480</span>, height=<span class="number">360</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">480</span>, height=<span class="number">320</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">384</span>, height=<span class="number">288</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">352</span>, height=<span class="number">288</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">320</span>, height=<span class="number">240</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">240</span>, height=<span class="number">320</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">240</span>, height=<span class="number">160</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">176</span>, height=<span class="number">144</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">144</span>, height=<span class="number">176</span></span><br><span class="line">SupportedPreviewSizes: width=<span class="number">160</span>, height=<span class="number">120</span></span><br></pre></td></tr></table></figure><p>这里尺寸的比例一般都是4:3、16:9，其他比例是在此基础上裁剪出来的</p><h2 id="选取预览尺寸"><a href="#选取预览尺寸" class="headerlink" title="选取预览尺寸"></a>选取预览尺寸</h2><p>在相同宽高比下，选择最接近View的宽高，避免过大的预览尺寸, 造成性能损耗, 引起预览卡顿。<br>在<a href="https://github.com/google/cameraview">cameraview</a>源码中，默认定义的宽高比<code>AspectRatio DEFAULT_ASPECT_RATIO = AspectRatio.of(4, 3)</code></p><h3 id="Camera1-1"><a href="#Camera1-1" class="headerlink" title="Camera1"></a>Camera1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Size <span class="title function_">chooseOptimalSize</span><span class="params">(SortedSet&lt;Size&gt; sizes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPreview.isReady()) &#123; <span class="comment">// Not yet laid out</span></span><br><span class="line">        <span class="keyword">return</span> sizes.first(); <span class="comment">// Return the smallest size</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> desiredWidth;</span><br><span class="line">    <span class="type">int</span> desiredHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">surfaceWidth</span> <span class="operator">=</span> mPreview.getWidth();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">surfaceHeight</span> <span class="operator">=</span> mPreview.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (isLandscape(mDisplayOrientation)) &#123;</span><br><span class="line">        desiredWidth = surfaceHeight;</span><br><span class="line">        desiredHeight = surfaceWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        desiredWidth = surfaceWidth;</span><br><span class="line">        desiredHeight = surfaceHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Size</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Size size : sizes) &#123; <span class="comment">// Iterate from small to large</span></span><br><span class="line">        <span class="keyword">if</span> (desiredWidth &lt;= size.getWidth() &amp;&amp; desiredHeight &lt;= size.getHeight()) &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        result = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区分了横竖屏，然后得到尺寸中宽和高等于或者大于View的宽高的尺寸。</p><h3 id="Camera2-1"><a href="#Camera2-1" class="headerlink" title="Camera2"></a>Camera2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Size <span class="title function_">chooseOptimalSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> surfaceLonger, surfaceShorter;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">surfaceWidth</span> <span class="operator">=</span> mPreview.getWidth();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">surfaceHeight</span> <span class="operator">=</span> mPreview.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (surfaceWidth &lt; surfaceHeight) &#123;</span><br><span class="line">        surfaceLonger = surfaceHeight;</span><br><span class="line">        surfaceShorter = surfaceWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        surfaceLonger = surfaceWidth;</span><br><span class="line">        surfaceShorter = surfaceHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    SortedSet&lt;Size&gt; candidates = mPreviewSizes.sizes(mAspectRatio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the smallest of those big enough</span></span><br><span class="line">    <span class="keyword">for</span> (Size size : candidates) &#123;</span><br><span class="line">        <span class="keyword">if</span> (size.getWidth() &gt;= surfaceLonger &amp;&amp; size.getHeight() &gt;= surfaceShorter) &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If no size is big enough, pick the largest one.</span></span><br><span class="line">    <span class="keyword">return</span> candidates.last();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断View宽高，区分其中较大值和较小值，然后再得到尺寸中宽和高大于或者等于View的较大值和较小值的尺寸。</p><h2 id="拍照尺寸"><a href="#拍照尺寸" class="headerlink" title="拍照尺寸"></a>拍照尺寸</h2><p>代码也是从<a href="https://github.com/google/cameraview">cameraview</a>中截取出来的</p><h3 id="Camera1-2"><a href="#Camera1-2" class="headerlink" title="Camera1"></a>Camera1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mPictureSizes.clear();</span><br><span class="line"><span class="keyword">for</span> (Camera.Size size : mCameraParameters.getSupportedPictureSizes()) &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;###### SupportedPictureSizes: width=&quot;</span> + size.width + <span class="string">&quot;, height=&quot;</span></span><br><span class="line">            + size.height);</span><br><span class="line">    mPictureSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.width, size.height));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Camera2-2"><a href="#Camera2-2" class="headerlink" title="Camera2"></a>Camera2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">collectPictureSizes</span><span class="params">(SizeMap sizes, StreamConfigurationMap map)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (android.util.Size size : map.getOutputSizes(ImageFormat.JPEG)) &#123;</span><br><span class="line">        mPictureSizes.add(<span class="keyword">new</span> <span class="title class_">Size</span>(size.getWidth(), size.getHeight()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在红米Note 5A手机支持的拍照尺寸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SupportedPictureSizes: width=<span class="number">4160</span>, height=<span class="number">3120</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">4160</span>, height=<span class="number">2340</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">4096</span>, height=<span class="number">3072</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">4096</span>, height=<span class="number">2304</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">4000</span>, height=<span class="number">3000</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">3840</span>, height=<span class="number">2160</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">3264</span>, height=<span class="number">2448</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">3200</span>, height=<span class="number">2400</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2976</span>, height=<span class="number">2976</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2592</span>, height=<span class="number">1944</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2592</span>, height=<span class="number">1458</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2688</span>, height=<span class="number">1512</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2304</span>, height=<span class="number">1728</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2048</span>, height=<span class="number">1536</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">2336</span>, height=<span class="number">1314</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1920</span>, height=<span class="number">1080</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1600</span>, height=<span class="number">1200</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1440</span>, height=<span class="number">1080</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1280</span>, height=<span class="number">960</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1280</span>, height=<span class="number">768</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1280</span>, height=<span class="number">720</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1200</span>, height=<span class="number">1200</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">1024</span>, height=<span class="number">768</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">800</span>, height=<span class="number">600</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">864</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">800</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">720</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">640</span>, height=<span class="number">480</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">640</span>, height=<span class="number">360</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">480</span>, height=<span class="number">640</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">480</span>, height=<span class="number">360</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">480</span>, height=<span class="number">320</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">352</span>, height=<span class="number">288</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">320</span>, height=<span class="number">240</span></span><br><span class="line">SupportedPictureSizes: width=<span class="number">240</span>, height=<span class="number">320</span></span><br></pre></td></tr></table></figure><p>这里尺寸的比例一般也是4:3、16:9</p><h2 id="选取拍照尺寸"><a href="#选取拍照尺寸" class="headerlink" title="选取拍照尺寸"></a>选取拍照尺寸</h2><p>Camaer1和Camera2都是一样的逻辑，选取固定宽高比例中的最大尺寸，这样拍摄的图片最清晰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Size</span> <span class="variable">largest</span> <span class="operator">=</span> mPictureSizes.sizes(mAspectRatio).last();</span><br></pre></td></tr></table></figure><h1 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h1><p>这里的设置方向有两种：图像预览方向和拍照方向。在这之前，需要先介绍几个概念：</p><ul><li>屏幕坐标方向</li><li>设备自然方向</li><li>摄像头传感器方向</li><li>相机预览方向</li></ul><h2 id="屏幕坐标方向"><a href="#屏幕坐标方向" class="headerlink" title="屏幕坐标方向"></a>屏幕坐标方向</h2><p>在Android系统中，以屏幕左上角为坐标系统的原点(0,0)坐标，该坐标系是固定不变的，不会因为设备方向的变化而改变。<br><img src="https://s2.ax1x.com/2020/01/31/11sOYQ.png" alt="屏幕坐标方向"></p><h2 id="屏幕自然方向"><a href="#屏幕自然方向" class="headerlink" title="屏幕自然方向"></a>屏幕自然方向</h2><p>每个设备都有一个自然方向，手机和平板自然方向不一样，如图所示，这里盗个图：<br><a href="https://imgchr.com/i/11ySO0"><img src="https://s2.ax1x.com/2020/01/31/11ySO0.md.png" alt="设备自然方向"></a><br>默认情况下，平板的自然方向是横屏，而手机的自然方向是竖屏方向。Android系统可以通过View的<code>OrientationEventListener</code>监听设备方向，回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOrientationChanged</span><span class="params">(<span class="type">int</span> orientation)</span>;</span><br></pre></td></tr></table></figure><p><code>onOrientationChanged</code>返回0到359的角度，其中0表示自然方向。</p><h2 id="摄像头传感器方向"><a href="#摄像头传感器方向" class="headerlink" title="摄像头传感器方向"></a>摄像头传感器方向</h2><p><a href="https://imgchr.com/i/11sXWj"><img src="https://s2.ax1x.com/2020/01/31/11sXWj.md.png" alt="摄像头传感器方向"></a><br>手机相机的图像数据都是来自于摄像头硬件的图像传感器，这个传感器在被固定到手机上后有一个默认的取景方向，方向一般是和手机横屏方向一致，如上图所示。  </p><h2 id="相机预览方向"><a href="#相机预览方向" class="headerlink" title="相机预览方向"></a>相机预览方向</h2><p>将摄像头传感器捕获的图像，显示在屏幕上的方向，就是相机预览方向。默认情况下，和摄像头传感器方向一致，可以通过Camera API进行改变。<br>Camaer1可以使用<code>setDisplayOrientation</code>设置预览方向，Camera2则可以通过TextureView来实现。<br>不同的摄像头位置，<code>orientation</code>是不一样的，orientation就是摄像头传感器方向顺时针旋转到屏幕自然方向的角度。</p><h3 id="后置"><a href="#后置" class="headerlink" title="后置"></a>后置</h3><p>后置的<code>orientation</code>90<br><a href="https://imgchr.com/i/18NuGt"><img src="https://s2.ax1x.com/2020/02/01/18NuGt.md.jpg" alt="后置"></a><br>对横屏来说，屏幕的自然方向和相机的摄像头传感器方向一致的。<br>对竖屏来说，看到的图像逆时针旋转了90度，因此预览方向需要顺时针旋转90度，才能与屏幕的自然方向保持一致。</p><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>前置的<code>orientation</code>270，收集到图像后(没有经过镜像处理)，但是要显示到屏幕上，就要按照屏幕自然方向的坐标系来进行显示，需要顺时针旋转270度，才能和设备自然方向一致。预览的时候，做了镜像处理，所以只需要顺时针旋转90度，就能和设置自然方向一致。<br>那么Camera1和Camera2具体设置预览方向的代码，来自<a href="https://github.com/google/cameraview">cameraview</a>：   </p><p><strong>Camera1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcDisplayOrientation</span><span class="params">(<span class="type">int</span> screenOrientationDegrees)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">360</span> - (mCameraInfo.orientation + screenOrientationDegrees) % <span class="number">360</span>) % <span class="number">360</span>;    <span class="comment">// compensate the mirror</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// back-facing</span></span><br><span class="line">        <span class="keyword">return</span> (mCameraInfo.orientation - screenOrientationDegrees + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中区分了前置和后置摄像头。   </p><ul><li>后置：<code>(mCameraInfo.orientation - screenOrientationDegrees + 360) % 360</code>，恢复到自然方向需要顺时针旋转，而屏幕逆时针旋转正好抵掉了摄像头的旋转，两者差值+360取模。</li><li>前置：<code>(mCameraInfo.orientation + screenOrientationDegrees) % 360</code>，屏幕竖直方向看到的是一个镜像，360-<code>(mCameraInfo.orientation + screenOrientationDegrees) % 360</code>，顺时针旋转这个差值可以到自然方向，只不过这是个镜像，左右翻转了</li></ul><p><strong>Camera2</strong><br>使用的TextureView的setTransform进行旋转，并有区分横竖屏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Configures the transform matrix for TextureView based on &#123;<span class="doctag">@link</span> #mDisplayOrientation&#125; and</span></span><br><span class="line"><span class="comment">* the surface size.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">configureTransform</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Matrix</span> <span class="variable">matrix</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">    <span class="keyword">if</span> (mDisplayOrientation % <span class="number">180</span> == <span class="number">90</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> getWidth();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> getHeight();</span><br><span class="line">        <span class="comment">// Rotate the camera preview when the screen is landscape.</span></span><br><span class="line">        matrix.setPolyToPoly(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">float</span>[]&#123;</span><br><span class="line">                        <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="comment">// top left</span></span><br><span class="line">                        width, <span class="number">0.f</span>, <span class="comment">// top right</span></span><br><span class="line">                        <span class="number">0.f</span>, height, <span class="comment">// bottom left</span></span><br><span class="line">                        width, height, <span class="comment">// bottom right</span></span><br><span class="line">                &#125;, <span class="number">0</span>,</span><br><span class="line">                mDisplayOrientation == <span class="number">90</span> ?</span><br><span class="line">                        <span class="comment">// Clockwise</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">float</span>[]&#123;</span><br><span class="line">                                <span class="number">0.f</span>, height, <span class="comment">// top left</span></span><br><span class="line">                                <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="comment">// top right</span></span><br><span class="line">                                width, height, <span class="comment">// bottom left</span></span><br><span class="line">                                width, <span class="number">0.f</span>, <span class="comment">// bottom right</span></span><br><span class="line">                        &#125; : <span class="comment">// mDisplayOrientation == 270</span></span><br><span class="line">                        <span class="comment">// Counter-clockwise</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">float</span>[]&#123;</span><br><span class="line">                                width, <span class="number">0.f</span>, <span class="comment">// top left</span></span><br><span class="line">                                width, height, <span class="comment">// top right</span></span><br><span class="line">                                <span class="number">0.f</span>, <span class="number">0.f</span>, <span class="comment">// bottom left</span></span><br><span class="line">                                <span class="number">0.f</span>, height, <span class="comment">// bottom right</span></span><br><span class="line">                        &#125;, <span class="number">0</span>,</span><br><span class="line">                <span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDisplayOrientation == <span class="number">180</span>) &#123;</span><br><span class="line">        matrix.postRotate(<span class="number">180</span>, getWidth() / <span class="number">2</span>, getHeight() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mTextureView.setTransform(matrix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拍照方向"><a href="#拍照方向" class="headerlink" title="拍照方向"></a>拍照方向</h2><p>设置预览方向并不会改变拍出照片的方向。<br>对于后置相机，相机采集到的图像和相机预览的图像是一样的，只需要旋转后置相机orientation度。<br>对于前置相机来说，相机预览的图像和相机采集到的图像是镜像关系。<br>采集的图像：顺时针旋转270度后，与屏幕自然方向一致。<br>预览的图像：顺时针旋转90度后，与屏幕自然方向一致。<br>最后盗用一张图来说明：<br><img src="https://s2.ax1x.com/2020/02/01/18NlM8.jpg" alt="拍照方向"></p><h3 id="Camera1-3"><a href="#Camera1-3" class="headerlink" title="Camera1"></a>Camera1</h3><p>使用<code>mCameraParameters.setRotation()</code>设置拍照后图像方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mCameraParameters.setRotation(calcCameraRotation(displayOrientation));</span><br><span class="line">......</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Calculate camera rotation</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This calculation is applied to the output JPEG either via Exif Orientation tag</span></span><br><span class="line"><span class="comment">* or by actually transforming the bitmap. (Determined by vendor camera API implementation)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Note: This is not the same calculation as the display orientation</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> screenOrientationDegrees Screen orientation in degrees</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> Number of degrees to rotate image in order for it to view correctly.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcCameraRotation</span><span class="params">(<span class="type">int</span> screenOrientationDegrees)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">        <span class="keyword">return</span> (mCameraInfo.orientation + screenOrientationDegrees) % <span class="number">360</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// back-facing</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">landscapeFlip</span> <span class="operator">=</span> isLandscape(screenOrientationDegrees) ? <span class="number">180</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (mCameraInfo.orientation + screenOrientationDegrees + landscapeFlip) % <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相机采集到的图像，只需要旋转相机orientation度。</p><h3 id="Camera2-3"><a href="#Camera2-3" class="headerlink" title="Camera2"></a>Camera2</h3><p>根据<code>CameraCharacteristics.SENSOR_ORIENTATION</code>，使用<code>captureRequest</code>设置了JPEG图像的旋转方向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculate JPEG orientation.</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;ConstantConditions&quot;)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sensorOrientation</span> <span class="operator">=</span> mCameraCharacteristics.get(</span><br><span class="line">        CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line">captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION,</span><br><span class="line">        (sensorOrientation +</span><br><span class="line">                mDisplayOrientation * (mFacing == Constants.FACING_FRONT ? <span class="number">1</span> : -<span class="number">1</span>) +</span><br><span class="line">                <span class="number">360</span>) % <span class="number">360</span>);</span><br></pre></td></tr></table></figure><h1 id="图像数据"><a href="#图像数据" class="headerlink" title="图像数据"></a>图像数据</h1><p>Android Camera默认返回的数据格式是NV21。Camera1通过<code>mParameters.setPreviewFormat()</code>设置，Camera2通过<code>ImageReader.newInstance()</code>设置。<br>ImageFormat枚举了很多种图片格式，其中ImageFormat.NV21和ImageFormat.YV12是官方推荐的格式，NV21、YV12格式都属于 YUV 格式，也可以表示为YCbCr，Cb、Cr的含义等同于U、V。   </p><h3 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h3><p>YUV是一种颜色编码方法，和它类似的还有RGB颜色编码方法，主要应用于电视系统和模拟视频领域。其中YUV代表三个分量，Y 代表明亮度，U 和 V 表示的是色度，色度又定义了颜色的两个方面：色调和饱和度。将Y与UV分离，没有UV信息一样可以显示完整的图像，但是只能显示灰度图。   </p><h3 id="YUV采样格式"><a href="#YUV采样格式" class="headerlink" title="YUV采样格式"></a>YUV采样格式</h3><p>YUV 图像的主流采样方式有如下三种：</p><ul><li>YUV 4:4:4 采样：每一个Y对应一组UV分量</li><li>YUV 4:2:2 采样：每两个Y共用一组UV分量</li><li>YUV 4:2:0 采样：每四个Y共用一组UV分量</li></ul><p>盗个图说明比较清晰，黑点表示采样该像素点的Y分量，空心圆圈表示采用该像素点的UV分量<br><a href="https://imgchr.com/i/1G8a5t"><img src="https://s2.ax1x.com/2020/02/01/1G8a5t.md.jpg" alt="YUV"></a></p><h3 id="YUV存储格式"><a href="#YUV存储格式" class="headerlink" title="YUV存储格式"></a>YUV存储格式</h3><p>有两种存储格式，planar和packed。</p><ul><li>planar：先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V</li><li>packed：每个像素点的Y,U,V是连续交替存储</li></ul><p>YUV格式信息可以参考：<a href="https://www.fourcc.org/yuv.php">YUV pixel formats</a><br>根据采样方式和存储格式的不同，形成了多种YUV格式，常见的YUV格式：</p><table><thead><tr><th align="center">采样&#x2F;格式</th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="center">YUV422</td><td>YUVY 格式</td><td>UYVY 格式</td><td>YUV422P 格式</td></tr><tr><td align="center">YUV420</td><td>YUV420P<br>(YV12、YU12格式)</td><td>YUV420P<br>(NV12、NV21格式)</td><td></td></tr></tbody></table><h4 id="YUVY格式"><a href="#YUVY格式" class="headerlink" title="YUVY格式"></a>YUVY格式</h4><p>YUVY格式属于packed存储格式，相邻的两个Y共用其相邻的两个U、V</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y0 UO Y1 V0 Y2 U2 Y3 V2</span><br></pre></td></tr></table></figure><p>Y0、Y1共用 U0、V0<br>Y2、Y3共用 U2、V2</p><h4 id="UYVY格式"><a href="#UYVY格式" class="headerlink" title="UYVY格式"></a>UYVY格式</h4><p>UYVY格式也属于packed存储格式，与YUYV格式不同的是UV的排列顺序不一样而已</p><h4 id="YUV422P格式"><a href="#YUV422P格式" class="headerlink" title="YUV422P格式"></a>YUV422P格式</h4><p>YUV422P格式属于planar存储格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V</p><h4 id="YV12、YU12格式"><a href="#YV12、YU12格式" class="headerlink" title="YV12、YU12格式"></a>YV12、YU12格式</h4><p>YU12和YV12格式都属于YUV420P格式，YUV420P是planar存储格式。先存储所有Y，然后在存储U、V。<br>YU12和YV12的区别在于YU12是先Y再U后V，而YV12是先Y再V后U。</p><h4 id="NV12、NV21格式"><a href="#NV12、NV21格式" class="headerlink" title="NV12、NV21格式"></a>NV12、NV21格式</h4><p>NV12、NV21格式YUV420SP格式，YUV420SP也是planar存储格式。先存储所有Y，然后按照UV或者VU的交替顺序进行存储。<br>NV12格式先存储Y，然后UV再进行交替存储。<br>NV21格式则是先存储Y，然后VU再进行交替存储。<br>最后盗用一个数据格式的总结：   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YV21: YYYYYYYY UU VV =&gt; YUV420P   </span><br><span class="line">YV12: YYYYYYYY VV UU =&gt; YUV420P   </span><br><span class="line">NV12: YYYYYYYY UV UV =&gt; YUV420SP   </span><br><span class="line">NV21: YYYYYYYY VU VU =&gt; YUV420SP</span><br></pre></td></tr></table></figure><p>Android Camera 默认数据格式是 NV21，Camera1直接设置<code>mParameters.setPreviewFormat(ImageFormat.NV21)</code>，然后拍照回调中的 raw data 数据返回就是 NV21的。<br>Camera2通过<code>ImageReader.newInstance()</code>设置，但是不能直接设置格式<code>ImageFormat.NV21</code>，在源码中有段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (format == ImageFormat.NV21) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">            <span class="string">&quot;NV21 format is not supported&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最新的<code>ImageFormat.NV21</code>上有说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YCrCb format used <span class="keyword">for</span> images, which uses the NV21 encoding format.   </span><br><span class="line">This is the <span class="keyword">default</span> format <span class="keyword">for</span> android.hardware.Camera preview images,</span><br><span class="line">when not otherwise set with android.hardware.Camera.Parameters.setPreviewFormat(<span class="type">int</span>).</span><br><span class="line">For the android.hardware.camera2 API, the YUV_420_888 format is recommended <span class="keyword">for</span> YUV output instead.</span><br></pre></td></tr></table></figure><p>Camera2建议使用<code>YUV_420_888</code>来替代，所以要得到NV21的数据需要进行数据转化，具体可以参考<a href="https://www.polarxiong.com/archives/Android-Image%E7%B1%BB%E6%B5%85%E6%9E%90-%E7%BB%93%E5%90%88YUV_420_888.html">Image类浅析(结合YUV_420_888)</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.csdn.net/xx326664162/article/details/53350551">Android相机开发和遇到的坑</a></li><li><a href="https://www.jianshu.com/p/067889611ae7">Android Camera2 教程 · 第三章 · 预览</a></li><li><a href="https://glumes.com/post/android/android-camera-aspect-ratio-and-orientation/">Android 相机开发中的尺寸和方向问题</a></li><li><a href="https://blog.csdn.net/tencent_bugly/article/details/53375311">【腾讯优测干货分享】Android 相机预览方向及其适配探索</a></li><li><a href="https://juejin.im/post/5ce497285188252dd500c304">一文读懂 YUV 的采样与格式</a></li><li><a href="https://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html">图文详解YUV420数据格式</a></li><li><a href="https://www.polarxiong.com/archives/Android-Image%E7%B1%BB%E6%B5%85%E6%9E%90-%E7%BB%93%E5%90%88YUV_420_888.html">Image类浅析(结合YUV_420_888)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面几篇文章介绍了Camera1，Camera2，CameraView和CameraX的使用，对各个API的使用，应该问题不大，不过在真正开发过程中，也会遇到各种不同的问题，本篇文章继续介绍相机开发过程中遇到的问题，主要是相机预览、拍照尺寸，方向，以及图像数据的处理。&lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="Orientation" scheme="http://yeungeek.github.io/tags/Orientation/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-CameraView和CameraX使用</title>
    <link href="http://yeungeek.github.io/2020/01/21/AndroidCamera-UsingCameraView/"/>
    <id>http://yeungeek.github.io/2020/01/21/AndroidCamera-UsingCameraView/</id>
    <published>2020-01-21T16:21:38.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇介绍了Camera1和Camera2的使用，发现Camera API从1到2的变化非常大，Camera2的复杂度提升了不少，官方为了让我们更容易使用Camera，出了个一个官方的库<a href="https://github.com/google/cameraview">cameraview</a>。不过这个库已经Deprecated，官方建议使用<a href="https://developer.android.com/jetpack/androidx/releases/camerax">Jetpack CameraX</a> 替代。本篇文章就介绍下CameraView和CameraX的使用</p><span id="more"></span><h1 id="CameraView"><a href="#CameraView" class="headerlink" title="CameraView"></a>CameraView</h1><p>CameraView的目的就是帮助开发者能够快速集成Camera1和Camera2的特性，可以用下面这张表来说明：</p><table><thead><tr><th align="center">API Level</th><th>Camera API</th><th>Preview View</th></tr></thead><tbody><tr><td align="center">9-13</td><td>Camera1</td><td>SurfaceView</td></tr><tr><td align="center">14-20</td><td>Camera1</td><td>TextureView</td></tr><tr><td align="center">21-23</td><td>Camera2</td><td>TextureView</td></tr><tr><td align="center">24</td><td>Camera2</td><td>SurfaceView</td></tr></tbody></table><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="CameraView定义"><a href="#CameraView定义" class="headerlink" title="CameraView定义"></a>CameraView定义</h3><p>xml中定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.cameraview.CameraView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/camera&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:keepScreenOn</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:adjustViewBounds</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:autoFocus</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:aspectRatio</span>=<span class="string">&quot;4:3&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:facing</span>=<span class="string">&quot;back&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:flash</span>=<span class="string">&quot;auto&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>xml中可以配置：</p><ul><li>autoFocus：是否自动对焦</li><li>aspectRatio：预览画面比例</li><li>facing：前后摄像头</li><li>flash：闪光灯模式</li></ul><h3 id="增加生命周期"><a href="#增加生命周期" class="headerlink" title="增加生命周期"></a>增加生命周期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onResume();</span><br><span class="line">    mCameraView.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">    mCameraView.stop();</span><br><span class="line">    <span class="built_in">super</span>.onPause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样声明后，就可以完成预览的工作了</p><h3 id="相机状态回调"><a href="#相机状态回调" class="headerlink" title="相机状态回调"></a>相机状态回调</h3><p>在xml声明CameraView后，增加回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mCameraView != <span class="literal">null</span>) &#123;</span><br><span class="line">    mCameraView.addCallback(mCallback);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> CameraView.<span class="type">Callback</span> <span class="variable">mCallback</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraView</span>.Callback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCameraOpened</span><span class="params">(CameraView cameraView)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCameraOpened&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCameraClosed</span><span class="params">(CameraView cameraView)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onCameraClosed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPictureTaken</span><span class="params">(CameraView cameraView, <span class="keyword">final</span> <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPictureTaken &quot;</span> + data.length);</span><br><span class="line">        Toast.makeText(cameraView.getContext(), R.string.picture_taken, Toast.LENGTH_SHORT)</span><br><span class="line">                .show();</span><br><span class="line">        getBackgroundHandler().post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getExternalFilesDir(Environment.DIRECTORY_PICTURES),</span><br><span class="line">                        <span class="string">&quot;picture.jpg&quot;</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onPictureTaken file path: &quot;</span> + file.getPath());</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line">                    os.write(data);</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">&quot;Cannot write to &quot;</span> + file, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            os.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="comment">// Ignore</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有三个回调方法，相机打开，相机关闭，和拍照。</p><h3 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCameraView.takePicture();</span><br></pre></td></tr></table></figure><p>就是这么简单，点击后拍照，然后回调中处理图像数据</p><h1 id="CameraX"><a href="#CameraX" class="headerlink" title="CameraX"></a>CameraX</h1><p>CameraX 是一个 Jetpack 支持库，目的是简化Camera的开发工作，它是基于Camera2 API的基础，向后兼容至 Android 5.0（API 级别 21）。<br>它有以下几个特性：</p><ul><li>易用性，只需要几行代码就可以实现预览和拍照</li><li>保持设备的一致性，在不同相机设备上，对宽高比、屏幕方向、旋转、预览大小和高分辨率图片大小，做到都可以正常使用</li><li>相机特性的扩展，增加人像、HDR、夜间模式和美颜等功能</li></ul><h2 id="开发流程-1"><a href="#开发流程-1" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="库引用"><a href="#库引用" class="headerlink" title="库引用"></a>库引用</h3><p>目前CameraX最新版本是<code>1.0.0-alpha06</code>，在app的build.gradle引用：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// CameraX core library.</span></span><br><span class="line">    <span class="keyword">def</span> camerax_version = <span class="string">&quot;1.0.0-alpha06&quot;</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.camera:camera-core:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line">    <span class="comment">// If you want to use Camera2 extensions.</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.camera:camera-camera2:$&#123;camerax_version&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> camerax_view_version = <span class="string">&quot;1.0.0-alpha03&quot;</span></span><br><span class="line">    <span class="keyword">def</span> camerax_ext_version = <span class="string">&quot;1.0.0-alpha03&quot;</span></span><br><span class="line">    <span class="comment">//other</span></span><br><span class="line">    <span class="comment">// If you to use the Camera View class</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.camera:camera-view:$camerax_view_version&quot;</span></span><br><span class="line">    <span class="comment">// If you to use Camera Extensions</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.camera:camera-extensions:$camerax_ext_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为CameraX是一个 Jetpack 支持库，相机的打开和释放都是使用了Jetpack的Lifecycle来进行处理。</p><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>预览参数设置，使用PreviewConfig.Builder()实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreviewConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PreviewConfig</span>.Builder()</span><br><span class="line">                .setLensFacing(CameraX.LensFacing.BACK)</span><br><span class="line">                .setTargetRotation(mTextureView.getDisplay().getRotation())</span><br><span class="line">                .setTargetResolution(<span class="keyword">new</span> <span class="title class_">Size</span>(<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line"><span class="type">Preview</span> <span class="variable">preview</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Preview</span>(config);</span><br><span class="line">preview.setOnPreviewOutputUpdateListener(<span class="keyword">new</span> <span class="title class_">Preview</span>.OnPreviewOutputUpdateListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onUpdated</span><span class="params">(<span class="meta">@NonNull</span> Preview.PreviewOutput output)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTextureView.getParent() <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">            <span class="type">ViewGroup</span> <span class="variable">viewGroup</span> <span class="operator">=</span> (ViewGroup) mTextureView.getParent();</span><br><span class="line">            viewGroup.removeView(mTextureView);</span><br><span class="line">            viewGroup.addView(mTextureView, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            mTextureView.setSurfaceTexture(output.getSurfaceTexture());</span><br><span class="line">            updateTransform();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//lifecycle</span></span><br><span class="line">CameraX.bindToLifecycle(<span class="built_in">this</span>, preview);</span><br></pre></td></tr></table></figure><p>PreivewConfig.Builder可以设置的属性很多，这里只设置了摄像头、旋转方向、预览分辨率，还有很多其他方法，大家可以自行试验。<br>在preview回调监听中，把output的SurfaceTexture设置到mTextureView中，实现图像预览，最后增加Lifecycle的绑定。</p><h3 id="拍照-1"><a href="#拍照-1" class="headerlink" title="拍照"></a>拍照</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageCaptureConfig</span> <span class="variable">captureConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageCaptureConfig</span>.Builder()</span><br><span class="line">        .setTargetAspectRatio(AspectRatio.RATIO_16_9)</span><br><span class="line">        .setCaptureMode(ImageCapture.CaptureMode.MIN_LATENCY)</span><br><span class="line">        .setTargetRotation(getWindowManager().getDefaultDisplay().getRotation())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">ImageCapture</span> <span class="variable">imageCapture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageCapture</span>(captureConfig);</span><br><span class="line">mTakePicture.setOnClickListener((view) -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getExternalMediaDirs()[<span class="number">0</span>], System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">    Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;##### file path: &quot;</span> + file.getPath());</span><br><span class="line">    imageCapture.takePicture(file, ContextCompat.getMainExecutor(getApplicationContext()), <span class="keyword">new</span> <span class="title class_">ImageCapture</span>.OnImageSavedListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onImageSaved</span><span class="params">(<span class="meta">@NonNull</span> File file)</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;##### onImageSaved: &quot;</span> + file.getPath());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> ImageCapture.ImageCaptureError imageCaptureError, <span class="meta">@NonNull</span> String message, <span class="meta">@Nullable</span> Throwable cause)</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;##### onError: &quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CameraX.bindToLifecycle(<span class="built_in">this</span>, preview, imageCapture);</span><br></pre></td></tr></table></figure><p>拍照的参数通过<code>ImageCaptureConfig.Builder</code>设置，这里只设置了图片宽高比、拍摄模式和旋转方向，还有很多其他方法，大家可以自行试验。<br>真正调用拍照的方法：</p><ul><li>takePicture(OnImageCapturedListener)：此方法为拍摄的图片提供内存缓冲区。</li><li>takePicture(File, OnImageSavedListener)：此方法将拍摄的图片保存到提供的文件位置。</li><li>takePicture(File, OnImageSavedListener, Metadata)：此方法可用于指定要嵌入已保存文件的 Exif 中的元数据。</li></ul><p>例子调用的是takePicture(File, OnImageSavedListener)，直接存为文件。最后再增加Lifecycle的绑定。</p><h3 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ImageAnalysisConfig</span> <span class="variable">analysisConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageAnalysisConfig</span>.Builder()</span><br><span class="line">        .setImageReaderMode(ImageAnalysis.ImageReaderMode.ACQUIRE_LATEST_IMAGE)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="type">ImageAnalysis</span> <span class="variable">imageAnalysis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageAnalysis</span>(analysisConfig);</span><br><span class="line">imageAnalysis.setAnalyzer(ContextCompat.getMainExecutor(getApplicationContext()),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LuminosityAnalyzer</span>());</span><br><span class="line"></span><br><span class="line">CameraX.bindToLifecycle(<span class="built_in">this</span>, preview, imageCapture, imageAnalysis);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LuminosityAnalyzer</span> <span class="keyword">implements</span> <span class="title class_">ImageAnalysis</span>.Analyzer &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastAnalyzedTimestamp</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">analyze</span><span class="params">(ImageProxy image, <span class="type">int</span> rotationDegrees)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Image</span> <span class="variable">img</span> <span class="operator">=</span> image.getImage();</span><br><span class="line">        <span class="keyword">if</span> (img != <span class="literal">null</span>) &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;DEBUG&quot;</span>, img.getWidth() + <span class="string">&quot;,&quot;</span> + img.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片分析，不是必要的步骤，但是ImageAnalysis，可以对每帧图像进行分析。<br>设置参数通过<code>ImageAnalysisConfig.Builder()</code>，这里只设置了<code>ImageReaderMode</code>，它有两种模式：</p><ul><li>阻止模式(ImageReaderMode.ACQUIRE_NEXT_IMAGE)：就是Camera2中的acquireNextImage()，获取下一个最新的可用Image</li><li>非阻止模式(ImageReaderMode.ACQUIRE_LATEST_IMAGE)：Camera2中的acquireLatestImage()，获得图像队列中最新的图片，并且会清空队列,删除已有的旧的图像</li></ul><p>最后还是增加Lifecycle的绑定。CameraX的使用也非常简单，把Camera2中复杂的API封装到统一的config中，只需要几行代码，就实现需要的功能。<br>文章中涉及到的<a href="https://github.com/yeungeek/AndroidRoad/blob/master/CameraSample/app/src/main/java/com/yeungeek/camerasample/camerax/CameraXActivity.java">代码</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/training/camerax">CameraX</a></li><li><a href="https://www.jianshu.com/p/f63f296a920b">Android Camera 编程从入门到精通</a></li><li><a href="https://glumes.com/post/android/google-jetpack-camerax/">Google Jetpack 新组件 CameraX 介绍与实践</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面两篇介绍了Camera1和Camera2的使用，发现Camera API从1到2的变化非常大，Camera2的复杂度提升了不少，官方为了让我们更容易使用Camera，出了个一个官方的库&lt;a href=&quot;https://github.com/google/cameraview&quot;&gt;cameraview&lt;/a&gt;。不过这个库已经Deprecated，官方建议使用&lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/camerax&quot;&gt;Jetpack CameraX&lt;/a&gt; 替代。本篇文章就介绍下CameraView和CameraX的使用&lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="CameraX" scheme="http://yeungeek.github.io/tags/CameraX/"/>
    
    <category term="SurfaceView" scheme="http://yeungeek.github.io/tags/SurfaceView/"/>
    
    <category term="TextureView" scheme="http://yeungeek.github.io/tags/TextureView/"/>
    
    <category term="CameraView" scheme="http://yeungeek.github.io/tags/CameraView/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-Camera2使用</title>
    <link href="http://yeungeek.github.io/2020/01/19/AndroidCamera-UsingCamera2/"/>
    <id>http://yeungeek.github.io/2020/01/19/AndroidCamera-UsingCamera2/</id>
    <published>2020-01-19T19:30:54.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章介绍了Camera1的使用，本篇介绍Camera2的使用。<br>Camera2(android.hardware.camera2)是从 Android 5.0 L 版本开始引入的，并且废弃了旧的相机框架Camera1(android.hardware.Camera)。<br>相比于Camera1，Camera2架构上也发生了变化，API上的使用难度也增加了。Camera2将相机设备模拟成一个管道，它按顺序处理每一帧的请求并返回请求结果给客户端。</p><span id="more"></span><h1 id="设计框架"><a href="#设计框架" class="headerlink" title="设计框架"></a>设计框架</h1><p>来自官网的模型图，展示了相关的工作流程<br><img src="https://s2.ax1x.com/2020/01/25/1eqOyj.png" alt="相机核心操作模型"><br>重新设计 Android Camera API 的目的在于大幅提高应用对于 Android 设备上的相机子系统的控制能力，同时重新组织 API，提高其效率和可维护性。<br>在CaptureRequest中设置不同的Surface用于接收不同的图片数据，最后从不同的Surface中获取到图片数据和包含拍照相关信息的CaptureResult。  </p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>通过设计框架的改造和优化，Camera2具备了以下优点:</p><ul><li>改进了新硬件的性能。Supported Hardware Level的概念，不同厂商对Camera2的支持程度不同，从低到高有LEGACY、LIMITED、FULL 和 LEVEL_3四个级别</li><li>以更快的间隔拍摄图像</li><li>显示来自多个摄像机的预览</li><li>直接应用效果和滤镜</li></ul><h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>框架上的变化，对整个使用流程变化也非常大，首先了解一些主要的开发类</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="CameraManager"><a href="#CameraManager" class="headerlink" title="CameraManager"></a>CameraManager</h3><p>相机系统服务，用于管理和连接相机设备</p><h3 id="CameraDevice"><a href="#CameraDevice" class="headerlink" title="CameraDevice"></a>CameraDevice</h3><p>相机设备类，和Camera1中的Camera同级</p><h3 id="CameraCharacteristics"><a href="#CameraCharacteristics" class="headerlink" title="CameraCharacteristics"></a>CameraCharacteristics</h3><p>主要用于获取相机信息，内部携带大量的相机信息，包含摄像头的正反(<code>LENS_FACING</code>)、AE模式、AF模式等，和Camera1中的Camera.Parameters类似</p><h3 id="CaptureRequest"><a href="#CaptureRequest" class="headerlink" title="CaptureRequest"></a>CaptureRequest</h3><p>相机捕获图像的设置请求，包含传感器，镜头，闪光灯等</p><h3 id="CaptureRequest-Builder"><a href="#CaptureRequest-Builder" class="headerlink" title="CaptureRequest.Builder"></a>CaptureRequest.Builder</h3><p>CaptureRequest的构造器，使用Builder模式，设置更加方便</p><h3 id="CameraCaptureSession"><a href="#CameraCaptureSession" class="headerlink" title="CameraCaptureSession"></a>CameraCaptureSession</h3><p>请求抓取相机图像帧的会话，会话的建立主要会建立起一个通道。一个CameraDevice一次只能开启一个CameraCaptureSession。<br>源端是相机，另一端是 Target，Target可以是Preview，也可以是ImageReader。</p><h3 id="ImageReader"><a href="#ImageReader" class="headerlink" title="ImageReader"></a>ImageReader</h3><p>用于从相机打开的通道中读取需要的格式的原始图像数据，可以设置多个ImageReader。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="https://s2.ax1x.com/2020/01/29/1QX6XV.png" alt="Camera2开发流程"></p><h3 id="获取CameraManager"><a href="#获取CameraManager" class="headerlink" title="获取CameraManager"></a>获取CameraManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CameraManager</span> <span class="variable">cameraManager</span> <span class="operator">=</span> (CameraManager) getSystemService(Context.CAMERA_SERVICE);</span><br></pre></td></tr></table></figure><h3 id="获取相机信息"><a href="#获取相机信息" class="headerlink" title="获取相机信息"></a>获取相机信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String cameraId : cameraManager.getCameraIdList()) &#123;</span><br><span class="line">    <span class="type">CameraCharacteristics</span> <span class="variable">characteristics</span> <span class="operator">=</span> cameraManager.getCameraCharacteristics(cameraId);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">facing</span> <span class="operator">=</span> characteristics.get(CameraCharacteristics.LENS_FACING);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != facing &amp;&amp; facing == CameraCharacteristics.LENS_FACING_FRONT) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里默认选择前置摄像头，并获取相关相机信息。</p><h3 id="初始化ImageReader"><a href="#初始化ImageReader" class="headerlink" title="初始化ImageReader"></a>初始化ImageReader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mImageReader = ImageReader.newInstance(largest.getWidth(), largest.getHeight(), ImageFormat.JPEG, <span class="number">2</span>);</span><br><span class="line">mImageReader.setOnImageAvailableListener(<span class="keyword">new</span> <span class="title class_">ImageReader</span>.OnImageAvailableListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onImageAvailable</span><span class="params">(ImageReader reader)</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;##### onImageAvailable: &quot;</span> + mFile.getPath());</span><br><span class="line">        mBackgroundHandler.post(<span class="keyword">new</span> <span class="title class_">ImageSaver</span>(reader.acquireNextImage(), mFile));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, mBackgroundHandler);</span><br></pre></td></tr></table></figure><p><code>ImageReader</code>是获取图像数据的重要途径，通过它可以获取到不同格式的图像数据，例如JPEG、YUV、RAW等。通过<code>ImageReader.newInstance(int width, int height, int format, int maxImages)</code>创建<code>ImageReader</code>对象，有4个参数：</p><ul><li>width：图像数据的宽度</li><li>height：图像数据的高度</li><li>format：图像数据的格式，例如<code>ImageFormat.JPEG</code>，<code>ImageFormat.YUV_420_888</code>等</li><li>maxImages：最大Image个数，Image对象池的大小，指定了能从ImageReader获取Image对象的最大值，过多获取缓冲区可能导致OOM，所以最好按照最少的需要去设置这个值</li></ul><p>ImageReader其他相关的方法和回调：</p><ul><li>ImageReader.OnImageAvailableListener：有新图像数据的回调</li><li>acquireLatestImage()：从ImageReader的队列里面，获取最新的Image，删除旧的，如果没有可用的Image，返回null</li><li>acquireNextImage()：获取下一个最新的可用Image，没有则返回null</li><li>close()：释放与此ImageReader关联的所有资源</li><li>getSurface()：获取为当前ImageReader生成Image的Surface</li></ul><h3 id="打开相机设备"><a href="#打开相机设备" class="headerlink" title="打开相机设备"></a>打开相机设备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mCameraOpenCloseLock.tryAcquire(<span class="number">2500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Time out waiting to lock camera opening.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cameraManager.openCamera(mCameraId, mStateCallback, mBackgroundHandler);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cameraManager.openCamera(@NonNull String cameraId,@NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler)</code>的三个参数:</p><ul><li>cameraId：摄像头的唯一标识</li><li>callback：设备连接状态变化的回调</li><li>handler：回调执行的Handler对象，传入null则使用当前的主线程Handler</li></ul><p>其中callback回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraDevice.<span class="type">StateCallback</span> <span class="variable">mStateCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraDevice</span>.StateCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        mCameraDevice = camera;</span><br><span class="line">        createCameraPreviewSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisconnected</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        camera.close();</span><br><span class="line">        mCameraDevice = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera, <span class="type">int</span> error)</span> &#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        camera.close();</span><br><span class="line">        mCameraDevice = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosed</span><span class="params">(<span class="meta">@NonNull</span> CameraDevice camera)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onClosed(camera);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>onOpened：表示相机打开成功，可以真正开始使用相机，创建Capture会话</li><li>onDisconnected：当相机断开连接时回调该方法，需要进行释放相机的操作</li><li>onError：当相机打开失败时，需要进行释放相机的操作</li><li>onClosed：调用Camera.close()后的回调方法</li></ul><h3 id="创建Capture会话"><a href="#创建Capture会话" class="headerlink" title="创建Capture会话"></a>创建Capture会话</h3><p>在CameraDevice.StateCallback的onOpened回调中执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createCameraPreviewSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SurfaceTexture</span> <span class="variable">texture</span> <span class="operator">=</span> mTextureView.getSurfaceTexture();</span><br><span class="line">    <span class="keyword">assert</span> texture != <span class="literal">null</span>;</span><br><span class="line">    texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">    <span class="type">Surface</span> <span class="variable">surface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Surface</span>(texture);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">        mPreviewRequestBuilder.addTarget(surface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here, we create a CameraCaptureSession for camera preview.</span></span><br><span class="line">        mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CameraCaptureSession</span>.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigured</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession cameraCaptureSession)</span> &#123;</span><br><span class="line">                        <span class="comment">// The camera is already closed</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> == mCameraDevice) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// When the session is ready, we start displaying the preview.</span></span><br><span class="line">                        mCaptureSession = cameraCaptureSession;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// Auto focus should be continuous for camera preview.</span></span><br><span class="line">                            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">                                    CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">                            <span class="comment">// Flash is automatically enabled when necessary.</span></span><br><span class="line">                            setAutoFlash(mPreviewRequestBuilder);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Finally, we start displaying the camera preview.</span></span><br><span class="line">                            mPreviewRequest = mPreviewRequestBuilder.build();</span><br><span class="line">                            mCaptureSession.setRepeatingRequest(mPreviewRequest,</span><br><span class="line">                                    mCaptureCallback, mBackgroundHandler);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigureFailed</span><span class="params">(</span></span><br><span class="line"><span class="params">                            <span class="meta">@NonNull</span> CameraCaptureSession cameraCaptureSession)</span> &#123;</span><br><span class="line">                        Toast.makeText(Camera2Activity.<span class="built_in">this</span>, <span class="string">&quot;configureFailed&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="literal">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段的代码核心方法是<code>mCameraDevice.createCaptureSession()</code>创建Capture会话，它接受了三个参数：</p><ul><li>outputs：用于接受图像数据的surface集合，这里传入的是一个preview的surface</li><li>callback：用于监听 Session 状态的CameraCaptureSession.StateCallback对象</li><li>handler：用于执行CameraCaptureSession.StateCallback的Handler对象，传入null则使用当前的主线程Handler</li></ul><h3 id="创建CaptureRequest"><a href="#创建CaptureRequest" class="headerlink" title="创建CaptureRequest"></a>创建CaptureRequest</h3><p>CaptureRequest是向CameraCaptureSession提交Capture请求时的信息载体，其内部包括了本次Capture的参数配置和接收图像数据的Surface。   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">mPreviewRequestBuilder.addTarget(surface);</span><br></pre></td></tr></table></figure><p>通过<code>CameraDevice.createCaptureRequest()</code>创建<code>CaptureRequest.Builder</code>对象，传入一个templateType参数，templateType用于指定使用何种模板创建<code>CaptureRequest.Builder</code>对象，templateType的取值：</p><ul><li>TEMPLATE_PREVIEW：预览模式</li><li>TEMPLATE_STILL_CAPTURE：拍照模式</li><li>TEMPLATE_RECORD：视频录制模式</li><li>TEMPLATE_VIDEO_SNAPSHOT：视频截图模式</li><li>TEMPLATE_MANUAL：手动配置参数模式</li></ul><p>除了模式的配置，CaptureRequest还可以配置很多其他信息，例如图像格式、图像分辨率、传感器控制、闪光灯控制、3A(自动对焦-AF、自动曝光-AE和自动白平衡-AWB)控制等。在createCaptureSession的回调中可以进行设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Auto focus should be continuous for camera preview.</span></span><br><span class="line">mPreviewRequestBuilder.<span class="built_in">set</span>(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line"><span class="comment">// Flash is automatically enabled when necessary.</span></span><br><span class="line"><span class="built_in">setAutoFlash</span>(mPreviewRequestBuilder);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, we start displaying the camera preview.</span></span><br><span class="line">mPreviewRequest = mPreviewRequestBuilder.<span class="built_in">build</span>();</span><br></pre></td></tr></table></figure><p>代码中设置了AF为设置未图片模式下的连续对焦，并设置自动闪光灯。最后通过<code>build()</code>方法生成CaptureRequest对象。</p><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>Camera2中，通过连续重复的Capture实现预览功能，每次Capture会把预览画面显示到对应的Surface上。连续重复的Capture操作通过<code>mCaptureSession.setRepeatingRequest(mPreviewRequest,mCaptureCallback, mBackgroundHandler)</code>实现，该方法有三个参数：</p><ul><li>request：CaptureRequest对象</li><li>listener：监听Capture 状态的回调</li><li>handler：用于执行CameraCaptureSession.CaptureCallback的Handler对象，传入null则使用当前的主线程Handler</li></ul><p>停止预览使用<code>mCaptureSession.stopRepeating()</code>方法。</p><h3 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h3><p>设置上面的request，session后，就可以真正的开始拍照操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, mBackgroundHandler);</span><br></pre></td></tr></table></figure><p>该方法也有三个参数，和mCaptureSession.setRepeatingRequest一样：</p><ul><li>request：CaptureRequest对象</li><li>listener：监听Capture 状态的回调</li><li>handler：用于执行CameraCaptureSession.CaptureCallback的Handler对象，传入null则使用当前的主线程Handler</li></ul><p>这里设置了mCaptureCallback：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CameraCaptureSession.<span class="type">CaptureCallback</span> <span class="variable">mCaptureCallback</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraCaptureSession</span>.CaptureCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureProgressed</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session, <span class="meta">@NonNull</span> CaptureRequest request, <span class="meta">@NonNull</span> CaptureResult partialResult)</span> &#123;</span><br><span class="line">        process(partialResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCaptureCompleted</span><span class="params">(<span class="meta">@NonNull</span> CameraCaptureSession session, <span class="meta">@NonNull</span> CaptureRequest request, <span class="meta">@NonNull</span> TotalCaptureResult result)</span> &#123;</span><br><span class="line">        process(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(CaptureResult result)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">            <span class="keyword">case</span> STATE_PREVIEW: &#123;</span><br><span class="line">                <span class="comment">// We have nothing to do when the camera preview is working normally.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> STATE_WAITING_LOCK: &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">afState</span> <span class="operator">=</span> result.get(CaptureResult.CONTROL_AF_STATE);</span><br><span class="line">                Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;##### process STATE_WAITING_LOCK: &quot;</span> + afState);</span><br><span class="line">                <span class="keyword">if</span> (afState == <span class="literal">null</span>) &#123;</span><br><span class="line">                    captureStillPicture();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED == afState ||</span><br><span class="line">                        CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED == afState) &#123;</span><br><span class="line">                    <span class="comment">// CONTROL_AE_STATE can be null on some devices</span></span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">aeState</span> <span class="operator">=</span> result.get(CaptureResult.CONTROL_AE_STATE);</span><br><span class="line">                    <span class="keyword">if</span> (aeState == <span class="literal">null</span> ||</span><br><span class="line">                            aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) &#123;</span><br><span class="line">                        mState = STATE_PICTURE_TAKEN;</span><br><span class="line">                        captureStillPicture();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        runPrecaptureSequence();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> STATE_WAITING_PRECAPTURE: &#123;</span><br><span class="line">                <span class="comment">// CONTROL_AE_STATE can be null on some devices</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">aeState</span> <span class="operator">=</span> result.get(CaptureResult.CONTROL_AE_STATE);</span><br><span class="line">                <span class="keyword">if</span> (aeState == <span class="literal">null</span> ||</span><br><span class="line">                        aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE ||</span><br><span class="line">                        aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) &#123;</span><br><span class="line">                    mState = STATE_WAITING_NON_PRECAPTURE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> STATE_WAITING_NON_PRECAPTURE: &#123;</span><br><span class="line">                <span class="comment">// CONTROL_AE_STATE can be null on some devices</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">aeState</span> <span class="operator">=</span> result.get(CaptureResult.CONTROL_AE_STATE);</span><br><span class="line">                <span class="keyword">if</span> (aeState == <span class="literal">null</span> || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) &#123;</span><br><span class="line">                    mState = STATE_PICTURE_TAKEN;</span><br><span class="line">                    captureStillPicture();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过设置<code>mState</code>来区分当前状态，是在预览还是拍照</p><h3 id="关闭相机"><a href="#关闭相机" class="headerlink" title="关闭相机"></a>关闭相机</h3><p>退到后台或者当前页面被关闭的时候，已经不需要使用相机了，需要进行相机关闭操作，释放资源，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeCamera</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCameraOpenCloseLock.acquire();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != mCaptureSession) &#123;</span><br><span class="line">            mCaptureSession.close();</span><br><span class="line">            mCaptureSession = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != mCameraDevice) &#123;</span><br><span class="line">            mCameraDevice.close();</span><br><span class="line">            mCameraDevice = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != mImageReader) &#123;</span><br><span class="line">            mImageReader.close();</span><br><span class="line">            mImageReader = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Interrupted while trying to lock camera closing.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先后对CaptureSession，CameraDevice，ImageReader进行close操作，释放资源。<br>这里仅仅对Camera2基本使用流程做了介绍，一些更高级的用法需要大家自行去实践。在Camera1中需要对画面进行方向矫正，而Camera2是否需要呢，关于相机Orientation相关的知识，通过后面的章节再进行介绍。</p><p>文章中涉及到的<a href="https://github.com/yeungeek/AndroidRoad/blob/master/CameraSample/app/src/main/java/com/yeungeek/camerasample/camera2/Camera2Activity.java">代码</a></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li><a href="https://source.android.com/devices/camera">Camera</a></li><li><a href="https://medium.com/google-developers/detecting-camera-features-with-camera2-61675bb7d1bf">Detecting camera features with Camera2</a></li><li><a href="https://www.jianshu.com/p/f63f296a920b">Android Camera 编程从入门到精通</a></li><li><a href="https://www.jianshu.com/p/9a2e66916fcb">Android Camera2 教程 · 第一章 · 概览</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上篇文章介绍了Camera1的使用，本篇介绍Camera2的使用。&lt;br&gt;Camera2(android.hardware.camera2)是从 Android 5.0 L 版本开始引入的，并且废弃了旧的相机框架Camera1(android.hardware.Camera)。&lt;br&gt;相比于Camera1，Camera2架构上也发生了变化，API上的使用难度也增加了。Camera2将相机设备模拟成一个管道，它按顺序处理每一帧的请求并返回请求结果给客户端。&lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="SurfaceView" scheme="http://yeungeek.github.io/tags/SurfaceView/"/>
    
    <category term="TextureView" scheme="http://yeungeek.github.io/tags/TextureView/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-Camera1使用</title>
    <link href="http://yeungeek.github.io/2020/01/17/AndroidCamera-UsingCamera1/"/>
    <id>http://yeungeek.github.io/2020/01/17/AndroidCamera-UsingCamera1/</id>
    <published>2020-01-17T09:32:39.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>Android Camera API和Android版本一样，也是碎片化比较严重，所以Google官方推出了<a href="https://github.com/google/cameraview">CameraView</a>，提供给开发者参考和学习，现在最新的可以使用<a href="https://developer.android.com/jetpack/androidx/releases/camerax">Jetpack CameraX</a>来开发，大大简化了开发的复杂度。本系列从Camera1-&gt;Camera2-&gt;CameraView-&gt;CameraX，一步步讲解Camera的进化过程，本篇先介绍Camera1的使用。</p><span id="more"></span><p>相机开发的流程：</p><ol><li>检测设备摄像头，打开相机</li><li>创建预览画面，显示实时预览画面</li><li>设置相机参数，进行拍照监听</li><li>监听中，保存图片资源或者直接操作原始数据</li><li>释放相机资源</li></ol><p>上面的是基本的相机开发流程，不同的Camera API在实现上会有不同，整体流程上还是统一的。  </p><h1 id="Camera1使用"><a href="#Camera1使用" class="headerlink" title="Camera1使用"></a>Camera1使用</h1><h2 id="权限声明"><a href="#权限声明" class="headerlink" title="权限声明"></a>权限声明</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>相机必须声明<code>CAMERA</code>权限，在Android6.0上，你还需要在代码中动态申请权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActivityCompat.requestPermissions(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;Manifest.permission.CAMERA&#125;,</span><br><span class="line">                    REQUEST_CAMERA_PERMISSION);</span><br></pre></td></tr></table></figure><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>下图是一个开发流程的导览：<br><a href="https://imgchr.com/i/lxqhbq"><img src="https://s2.ax1x.com/2020/01/17/lxqhbq.md.png" alt="Camera1开发流程"></a></p><h3 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Camera.open()</span><br></pre></td></tr></table></figure><p>该方法的系统源码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Camera <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfCameras</span> <span class="operator">=</span> getNumberOfCameras();</span><br><span class="line">    <span class="type">CameraInfo</span> <span class="variable">cameraInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CameraInfo</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numberOfCameras; i++) &#123;</span><br><span class="line">        getCameraInfo(i, cameraInfo);</span><br><span class="line">        <span class="keyword">if</span> (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Camera</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会检查可用的摄像头，默认使用的<code>CameraInfo.CAMERA_FACING_BACK</code>后置摄像头</p><h3 id="创建预览画面"><a href="#创建预览画面" class="headerlink" title="创建预览画面"></a>创建预览画面</h3><p>这里使用的是<code>SurfaceView</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SurfaceView mSurfaceView;</span><br><span class="line"><span class="keyword">private</span> SurfaceHolder mSurfaceHolder;</span><br><span class="line">...</span><br><span class="line">mSurfaceHolder = mSurfaceView.getHolder();</span><br><span class="line">mSurfaceHolder.addCallback(<span class="keyword">new</span> <span class="title class_">SurfaceHolder</span>.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        startPreview();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="type">int</span> format, <span class="type">int</span> width, <span class="type">int</span> height)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> &#123;</span><br><span class="line">        releaseCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startPreview</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置实时预览</span></span><br><span class="line">        mCamera.setPreviewDisplay(mSurfaceHolder);</span><br><span class="line">        <span class="comment">//Orientation</span></span><br><span class="line">        setCameraDisplayOrientation();</span><br><span class="line">        <span class="comment">//开始预览</span></span><br><span class="line">        mCamera.startPreview();</span><br><span class="line"></span><br><span class="line">        startFaceDetect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置预览的时候，可以设置<code>setPreviewCallback</code>监听预览数据的回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onPreviewFrame</span><span class="params">(<span class="type">byte</span>[] data, Camera camera)</span>;</span><br></pre></td></tr></table></figure><h3 id="设置相机参数"><a href="#设置相机参数" class="headerlink" title="设置相机参数"></a>设置相机参数</h3><p>设置相机参数后，需要重新启动预览，这边在初始化的时候，已经设置好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initParameters</span><span class="params">(<span class="keyword">final</span> Camera camera)</span> &#123;</span><br><span class="line">    mParameters = camera.getParameters();</span><br><span class="line">    mParameters.setPreviewFormat(ImageFormat.NV21); <span class="comment">//default</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSupportFocus(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) &#123;</span><br><span class="line">        mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSupportFocus(Camera.Parameters.FOCUS_MODE_AUTO)) &#123;</span><br><span class="line">        mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置预览图片大小</span></span><br><span class="line">    setPreviewSize();</span><br><span class="line">    <span class="comment">//设置图片大小</span></span><br><span class="line">    setPictureSize();</span><br><span class="line"></span><br><span class="line">    camera.setParameters(mParameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Camera.Parameters可以设置的参数非常多，这里就介绍几个比较常用的<br><img src="https://s2.ax1x.com/2020/01/15/lXPg5q.png" alt="Camera.Parameters"></p><h4 id="1-setFocusMode"><a href="#1-setFocusMode" class="headerlink" title="1.setFocusMode"></a>1.setFocusMode</h4><p>设置对焦模式    </p><ul><li>FOCUS_MODE_AUTO：自动对焦</li><li>FOCUS_MODE_INFINITY：无穷远</li><li>FOCUS_MODE_MACRO：微距</li><li>FOCUS_MODE_FIXED：固定焦距</li><li>FOCUS_MODE_EDOF：景深扩展</li><li>FOCUS_MODE_CONTINUOUS_PICTURE：持续对焦(针对照片)</li><li>FOCUS_MODE_CONTINUOUS_VIDEO：(针对视频)</li></ul><h4 id="2-setPreviewSize"><a href="#2-setPreviewSize" class="headerlink" title="2.setPreviewSize"></a>2.setPreviewSize</h4><p>设置预览图片大小</p><h4 id="3-setPreviewFormat"><a href="#3-setPreviewFormat" class="headerlink" title="3.setPreviewFormat"></a>3.setPreviewFormat</h4><p>支持的格式： </p><ul><li>ImageFormat.NV16</li><li>ImageFormat.NV21</li><li>ImageFormat.YUY2</li><li>ImageFormat.YV12</li><li>ImgaeFormat.RGB_565</li><li>ImageFormat.JPEG<br>如果不设置，默认返回NV21的数据</li></ul><h4 id="4-setPictureSize"><a href="#4-setPictureSize" class="headerlink" title="4.setPictureSize"></a>4.setPictureSize</h4><p>设置保存图片的大小</p><h4 id="5-setPictureFormat"><a href="#5-setPictureFormat" class="headerlink" title="5.setPictureFormat"></a>5.setPictureFormat</h4><p>设置保存图片的格式，格式和<code>setPreviewFormat</code>一样</p><h4 id="6-setDisplayOrientation"><a href="#6-setDisplayOrientation" class="headerlink" title="6.setDisplayOrientation"></a>6.setDisplayOrientation</h4><p>设置相机预览画面旋转的角度，degress取值0，90，180，270</p><h4 id="7-setPreviewDisplay"><a href="#7-setPreviewDisplay" class="headerlink" title="7.setPreviewDisplay"></a>7.setPreviewDisplay</h4><p>设置实时预览SurfaceHolder</p><h4 id="8-setPreviewCallback"><a href="#8-setPreviewCallback" class="headerlink" title="8.setPreviewCallback"></a>8.setPreviewCallback</h4><p>监听相机预览数据回调</p><h4 id="9-setParameters"><a href="#9-setParameters" class="headerlink" title="9.setParameters"></a>9.setParameters</h4><p>设置相机的Parameters<br>其他一些设置，大家可以查看Android文档进行相应的设置</p><h3 id="设置方向"><a href="#设置方向" class="headerlink" title="设置方向"></a>设置方向</h3><p>设置相机的预览方向，<a href="https://juejin.im/post/5d6d1155e51d4561ea1a94a4#heading-7">orientation比较详细的介绍</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setCameraDisplayOrientation</span><span class="params">()</span> &#123;</span><br><span class="line">    Camera.<span class="type">CameraInfo</span> <span class="variable">cameraInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Camera</span>.CameraInfo();</span><br><span class="line">    Camera.getCameraInfo(mCameraId, cameraInfo);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rotation</span> <span class="operator">=</span> getWindowManager().getDefaultDisplay().getRotation();  <span class="comment">//自然方向</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">degrees</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (rotation) &#123;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_0:</span><br><span class="line">            degrees = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_90:</span><br><span class="line">            degrees = <span class="number">90</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_180:</span><br><span class="line">            degrees = <span class="number">180</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Surface.ROTATION_270:</span><br><span class="line">            degrees = <span class="number">270</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="comment">//cameraInfo.orientation 图像传感方向</span></span><br><span class="line">    <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">        result = (cameraInfo.orientation + degrees) % <span class="number">360</span>;</span><br><span class="line">        result = (<span class="number">360</span> - result) % <span class="number">360</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = (cameraInfo.orientation - degrees + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOrientation = result;</span><br><span class="line">    <span class="comment">//相机预览方向</span></span><br><span class="line">    mCamera.setDisplayOrientation(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">takePicture</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != mCamera) &#123;</span><br><span class="line">        mCamera.takePicture(<span class="keyword">new</span> <span class="title class_">Camera</span>.ShutterCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onShutter</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">Camera</span>.PictureCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPictureTaken</span><span class="params">(<span class="type">byte</span>[] data, Camera camera)</span> &#123;</span><br><span class="line">                <span class="comment">//base data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">Camera</span>.PictureCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPictureTaken</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data, Camera camera)</span> &#123;</span><br><span class="line">                mCamera.startPreview();</span><br><span class="line">                <span class="comment">//save data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>takePicture的源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">takePicture</span><span class="params">(ShutterCallback shutter, PictureCallback raw,</span></span><br><span class="line"><span class="params">            PictureCallback jpeg)</span> &#123;</span><br><span class="line">        takePicture(shutter, raw, <span class="literal">null</span>, jpeg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>shutter(ShutterCallback)：快门按下后的回调</li><li>raw(PictureCallback)：raw图像数据</li><li>jpeg(PictureCallback)：jpeg图像生成以后的回调</li></ul><h3 id="释放相机资源"><a href="#释放相机资源" class="headerlink" title="释放相机资源"></a>释放相机资源</h3><p>在使用完成后，onPause或者onDestory中进行相机资源的释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">releaseCamera</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != mCamera) &#123;</span><br><span class="line">        mCamera.stopPreview();</span><br><span class="line">        mCamera.stopFaceDetection();</span><br><span class="line">        mCamera.setPreviewCallback(<span class="literal">null</span>);</span><br><span class="line">        mCamera.release();</span><br><span class="line">        mCamera = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>stopPreview：停止预览</li><li>release：释放资源</li></ul><p>Camera1的开发上，还是相对比较简单的，需要定制的功能项比较少，下面一篇开始介绍Camera2的使用。<br>文章中涉及到的<a href="https://github.com/yeungeek/AndroidRoad/blob/master/CameraSample/app/src/main/java/com/yeungeek/camerasample/camera1/Camera1Activity.java">代码</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/f63f296a920b">Android Camera 编程从入门到精通</a></li><li><a href="https://juejin.im/post/5d6d1155e51d4561ea1a94a4">Android之Camera1实现相机开发</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android Camera API和Android版本一样，也是碎片化比较严重，所以Google官方推出了&lt;a href=&quot;https://github.com/google/cameraview&quot;&gt;CameraView&lt;/a&gt;，提供给开发者参考和学习，现在最新的可以使用&lt;a href=&quot;https://developer.android.com/jetpack/androidx/releases/camerax&quot;&gt;Jetpack CameraX&lt;/a&gt;来开发，大大简化了开发的复杂度。本系列从Camera1-&amp;gt;Camera2-&amp;gt;CameraView-&amp;gt;CameraX，一步步讲解Camera的进化过程，本篇先介绍Camera1的使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="SurfaceView" scheme="http://yeungeek.github.io/tags/SurfaceView/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-基础知识篇</title>
    <link href="http://yeungeek.github.io/2020/01/14/AndroidCamera-Basic/"/>
    <id>http://yeungeek.github.io/2020/01/14/AndroidCamera-Basic/</id>
    <published>2020-01-14T19:49:33.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>现在随着音视频的应用越来越多，直接使用系统原生相机进行拍照裁剪和拍视频，已经不能满足需求了。<br>需要通过Camera API进行自定义相机开发，满足一些复杂的业务场景，开篇先介绍Camera的基础知识，为后面Camera开发提供支持。     </p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>Android Framework提供Camera API来实现拍照与录制视频的功能，目前Android有三类API，</p><ul><li><a href="https://developer.android.com/reference/android/hardware/Camera.html">Camera</a><br>此类是用于控制设备相机的旧版 API，现已弃用，在Android5.0以下使用</li><li><a href="https://developer.android.com/reference/android/hardware/camera2/package-summary.html">Camera2</a><br>此软件包是用于控制设备相机的主要 API，Android5.0以上使用</li><li><a href="https://developer.android.com/training/camerax">CameraX</a><br>基于Camera 2 API封装，简化了开发流程，并增加生命周期控制</li></ul><h2 id="相关开发类"><a href="#相关开发类" class="headerlink" title="相关开发类"></a>相关开发类</h2><ul><li><a href="https://developer.android.com/reference/android/hardware/Camera.html">android.hardware.camera2</a><br>控制相机的核心API，使用它可以实现拍照和录制视频的功能。</li><li><a href="https://developer.android.com/reference/android/hardware/Camera.html">Camera</a><br>此类是用于控制设备相机的旧版 API，现已弃用。</li><li><a href="https://developer.android.com/reference/android/view/SurfaceView.html">SurfaceView</a><br>此类用于向用户呈现实时相机预览。</li><li><a href="https://developer.android.com/reference/android/view/TextureView">TextureView</a><br>也是用于实时相机预览，Android4.0之后引入</li><li><a href="http://developer.android.com/reference/android/media/MediaRecorder.html">MediaRecorder</a><br>用于录制视频</li><li><a href="https://developer.android.com/reference/android/content/Intent.html">Intent</a><br>MediaStore.ACTION_IMAGE_CAPTURE 或 MediaStore.ACTION_VIDEO_CAPTURE 的 Intent 操作类型可用于捕获图像或视频，而无需直接使用 Camera 对象。</li></ul><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol><li><strong>ISO(感光度)</strong><br>CMOS（或胶卷）对光线的敏感程度，用ISO100的胶卷，相机2秒可以正确曝光的话，同样光线条件下用ISO200的胶卷只需要1秒即可，用ISO400则只要0.5秒。<br>常见的标准：ISO100，ISO200，ISO400</li><li><strong>曝光时间</strong><br>曝光时间是为了将光投射到相机感光片上，相机快门所要打开至关闭的时间</li><li><strong>光圈</strong><br>用来控制光线透过镜头，进入相机内感光面光量的装置</li><li><strong>焦距</strong><br>指的是平行的光线穿过镜片后，所汇集的焦点至镜片间之距离。<br>数值越小，代表可以拍摄的角度越广，数值越大，代表可以拍摄的角度越小 </li><li><strong>景深</strong><br>拍摄时，当镜头聚集于某个被摄体时，这个被摄体就能在相机上结成清晰影像。使被摄体产生较为清晰影像的纵深的范围叫景深 </li><li><strong>测光</strong><br>测光模式：中央平均测光(average metering)、中央局部测光、点测光(spot metering)、多点测光、评价测光</li><li><strong>自动曝光(Auto Exposure)</strong><br>相机根据光线条件自动来调整曝光时间等来确定曝光量</li><li><strong>对焦</strong><br>对焦模式：自动对焦 AE(Auto Focus)、手动对焦 MF(Manual Focus)<br>自动对焦分为对比度对焦(contrast)、相位对焦(PDAF: Phase Detection Auto Focus)和混合对焦(hybrid)</li><li><strong>闪光灯(Flashlight)</strong><br>通过闪光灯打闪照亮物体来达到拍出清晰图片的目的</li><li><strong>ScreenFlash</strong><br>通过屏幕打闪，照亮周围物体，拍出高清图片</li><li><strong>高动态范围图像(HDR)</strong><br>HDR全称是High-Dynamic Range，即高动态范围图像技术。在拍照过程中开启HDR，可以让原先的暗场景变得更明亮更通透。</li><li><strong>零延时拍照(ZSD)</strong><br>为了减少拍照延时,让拍照&amp;回显瞬间完成的一种技术</li><li><strong>连拍(ContinuousShot)</strong><br>通过节约数据传输时间来捕捉摄影时机</li><li><strong>预览大小(PreviewSize)</strong><br>相机预览图片的大小 </li><li><strong>拍照大小(PictureSize)</strong><br>拍照生成图片的大小 </li><li><strong>自动白平衡(Auto white balance)</strong><br>AWB(Auto white balance)，自动白平衡是相机的默认设置，相机中有一结构复杂的矩形图，它可决定画面中的白平衡基准点，以此来达到白平衡调校</li><li><strong>对比度</strong><br>图像最亮和最暗之间的区域之间的比率，比值越大，从黑到白的渐变层次就越多，从而色彩表现越丰富</li><li><strong>饱和度</strong><br>指色彩的鲜艳程度</li><li><strong>锐度</strong><br>是反映图像平面清晰度和图像边缘锐利程度的一个指标</li></ol><h2 id="相机功能"><a href="#相机功能" class="headerlink" title="相机功能"></a>相机功能</h2><p>Android 支持多种相机功能，您可使用相机应用控制这些功能，如图片格式、闪光模式、对焦设置等等。<br>通过<code>Camera.Parameters</code>可以设置大部分的功能，下面介绍几个重要功能：</p><ul><li>区域测光和对焦</li><li>人脸检测</li><li>延时视频</li></ul><h3 id="区域测光和对焦"><a href="#区域测光和对焦" class="headerlink" title="区域测光和对焦"></a>区域测光和对焦</h3><p>从 Android 4.0（API 级别 14）开始，通过<code>Camera.Parameters</code>来确定对焦或亮度设置的区域，然后进行拍照或者录像</p><h3 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h3><p>这个和真正的人脸识别是不一样的 ，这里仅仅是检测人脸。<br>通过照片分析，检测照片中是否包含人脸，使用人脸识别技术来识别人脸并计算照片设置</p><h3 id="延时视频"><a href="#延时视频" class="headerlink" title="延时视频"></a>延时视频</h3><p>延时视频功能允许用户将间隔几秒钟或几分钟拍摄的图片串联起来，创建视频剪辑。使用<code>MediaRecorder</code>录制时间流逝片段的图像。</p><p>其他重要功能API：<br><img src="https://s2.ax1x.com/2020/01/14/lqLgsK.png" alt="功能API"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://developer.android.com/training/camerax">CameraX</a></li><li><a href="https://developer.android.com/training/camera">Camera</a></li><li><a href="https://medium.com/google-developers/detecting-camera-features-with-camera2-61675bb7d1bf#.2x3icoqnc">Detecting camera features with Camera2</a></li><li><a href="http://hukai.me/android-dev-camera-basics/">Android相机开发 - 1)基础概览篇</a></li><li><a href="https://juejin.im/post/5d6d1155e51d4561ea1a94a4">Android之Camera1实现相机开发</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在随着音视频的应用越来越多，直接使用系统原生相机进行拍照裁剪和拍视频，已经不能满足需求了。&lt;br&gt;需要通过Camera API进行自定义相机开发，满足一些复杂的业务场景，开篇先介绍Camera的基础知识，为后面Camera开发提供支持。     &lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="CameraX" scheme="http://yeungeek.github.io/tags/CameraX/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera-系列文章</title>
    <link href="http://yeungeek.github.io/2020/01/13/AndroidCamera-Series/"/>
    <id>http://yeungeek.github.io/2020/01/13/AndroidCamera-Series/</id>
    <published>2020-01-13T10:44:49.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>最近比较忙，文章也很久没有更新了。<br>最近项目中用到Camera，做了一些功能，发现Camera涉及到很多内容，可以做成一个系列来分析。随着5G时代的到来，音视频相关的内容，会越来越流行，而Camera应该算是最基础的设施了，所以接下来会对Camera这块进行分析，通过下面这些文章，可以对Camera有个更深入的理解。</p><span id="more"></span><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ul><li><a href="/2020/01/13/AndroidCamera-Basic/">Camera基础知识</a></li><li><a href="/2020/01/17/AndroidCamera-UsingCamera1/">Camera1使用</a></li><li><a href="/2020/01/19/AndroidCamera-UsingCamera2/">Camera2使用</a></li><li><a href="/2020/01/21/AndroidCamera-UsingCameraView/">CameraView和AndroidX使用</a></li><li><a href="/2020/01/24/AndroidCamera-Orientation/">相机尺寸、方向和图像数据</a></li><li><a href="/2020/01/29/AndroidCamera-CameraViewAnalysis/">CameraView源码分析</a></li><li><a href="/2020/02/28/AndroidCamera-CameraXSource/">CameraX源码分析</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://source.android.com/devices/camera">Android Camera</a></li><li><a href="https://developer.android.com/training/camerax">CameraX</a></li><li><a href="https://www.jianshu.com/p/f63f296a920b">Android Camera 编程从入门到精通</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近比较忙，文章也很久没有更新了。&lt;br&gt;最近项目中用到Camera，做了一些功能，发现Camera涉及到很多内容，可以做成一个系列来分析。随着5G时代的到来，音视频相关的内容，会越来越流行，而Camera应该算是最基础的设施了，所以接下来会对Camera这块进行分析，通过下面这些文章，可以对Camera有个更深入的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/categories/Camera/"/>
    
    
    <category term="Camera" scheme="http://yeungeek.github.io/tags/Camera/"/>
    
    <category term="Camera2" scheme="http://yeungeek.github.io/tags/Camera2/"/>
    
    <category term="CameraX" scheme="http://yeungeek.github.io/tags/CameraX/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK-深入理解JNI</title>
    <link href="http://yeungeek.github.io/2019/08/21/AndroidNDK-DeepUnderstandJNI/"/>
    <id>http://yeungeek.github.io/2019/08/21/AndroidNDK-DeepUnderstandJNI/</id>
    <published>2019-08-21T11:21:43.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>Java调用C&#x2F;C++在Java语言里面本来就有的，并非Android独有的，即JNI。JNI就是Java调用C++的规范。</p><span id="more"></span><h1 id="JNI-概述"><a href="#JNI-概述" class="headerlink" title="JNI 概述"></a>JNI 概述</h1><p>JNI，全称为Java Native Interface，即Java本地接口，JNI是Java调用Native语言的一种特性，通过JNI可以使JAVA和 C&#x2F;C++进行交互。<br>Java语言是跨平台的语言，而这跨平台的背后都是依靠Java虚拟机，虚拟机采用C&#x2F;C++编写，适配各个系统，通过JNI为上层Java提供各种服务，保证跨平台性。<br>在Java语言出现前，就有很多程序和库都是由Native语言写的，如果想重复利用这些库，就可以所使用JNI来实现。在Android平台上，JNI就是一座将Java世界和Native世界联通的一座桥梁。<br><img src="https://s2.ax1x.com/2019/08/30/mOgNGD.png" alt="jni.png"><br>通过JNI，Java世界和Native世界的代码就可以相互访问了。</p><h1 id="JNI实例：Camera"><a href="#JNI实例：Camera" class="headerlink" title="JNI实例：Camera"></a>JNI实例：Camera</h1><p>最新有在看系统的Camera相关，所以从系统Camera角度来分析下JNI的应用，下面讲的实例基于Camera2</p><blockquote><p>Android5.0(21)之后android.hardware.Camera就被废弃了，取而代之的是全新的android.hardware.Camera2</p></blockquote><p>相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/AndroidRuntime.cpp</span><br><span class="line"></span><br><span class="line">frameworks/base/core/java/android/hardware/camera2/impl/CameraMetadataNative.java</span><br><span class="line">frameworks/base/core/jni/android_hardware_camera2_CameraMetadata.cpp</span><br></pre></td></tr></table></figure><p>Camera2 Java层对应的是CameraMetadataNative.java，Native层对应的是android_hardware_camera2_CameraMetadata.cpp</p><h2 id="Java层CameraMetadataNative"><a href="#Java层CameraMetadataNative" class="headerlink" title="Java层CameraMetadataNative"></a>Java层CameraMetadataNative</h2><p>相关代码在CameraMetadataNative.java<br>Camera2使用CameraManager(摄像头管理器)进行控制，CameraManager具体的操作会通过CameraMetadataNative来执行。<br>CameraMetadataNative的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CameraMetadataNative</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * We use a class initializer to allow the native code to cache some field offsets</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      nativeClassInit();</span><br><span class="line">      registerAllMarshalers();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeClassInit</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法初始化调用了Native层的方法<code>nativeClassInit</code>，这个方法对应的Native层具体实现，是在android_hardware_camera2_CameraMetadata.cpp</p><h2 id="Native层CameraMetadata"><a href="#Native层CameraMetadata" class="headerlink" title="Native层CameraMetadata"></a>Native层CameraMetadata</h2><p>Native层相关代码在android_hardware_camera2_CameraMetadata.cpp<br>Native方法初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gCameraMetadataMethods[] = &#123;</span><br><span class="line"><span class="comment">// static methods</span></span><br><span class="line">  &#123; <span class="string">&quot;nativeClassInit&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_classInit &#125;,   <span class="comment">//和Java层nativeClassInit()对应</span></span><br><span class="line">  &#123; <span class="string">&quot;nativeGetAllVendorKeys&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(Ljava/lang/Class;)Ljava/util/ArrayList;&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_getAllVendorKeys&#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeGetTagFromKey&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(Ljava/lang/String;)I&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_getTagFromKey &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeGetTypeFromTag&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(I)I&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_getTypeFromTag &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeSetupGlobalVendorTagDescriptor&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()I&quot;</span>,</span><br><span class="line">    (<span class="type">void</span>*)CameraMetadata_setupGlobalVendorTagDescriptor &#125;,</span><br><span class="line"><span class="comment">// instance methods</span></span><br><span class="line">  &#123; <span class="string">&quot;nativeAllocate&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()J&quot;</span>,</span><br><span class="line">    (<span class="type">void</span>*)CameraMetadata_allocate &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeAllocateCopy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(L&quot;</span> CAMERA_METADATA_CLASS_NAME <span class="string">&quot;;)J&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_allocateCopy &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeIsEmpty&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()Z&quot;</span>,</span><br><span class="line">    (<span class="type">void</span>*)CameraMetadata_isEmpty &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeGetEntryCount&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()I&quot;</span>,</span><br><span class="line">    (<span class="type">void</span>*)CameraMetadata_getEntryCount &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeClose&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span>*)CameraMetadata_close &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeSwap&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(L&quot;</span> CAMERA_METADATA_CLASS_NAME <span class="string">&quot;;)V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_swap &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeReadValues&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(I)[B&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_readValues &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeWriteValues&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(I[B)V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_writeValues &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeDump&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_dump &#125;,</span><br><span class="line"><span class="comment">// Parcelable interface</span></span><br><span class="line">  &#123; <span class="string">&quot;nativeReadFromParcel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(Landroid/os/Parcel;)V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_readFromParcel &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;nativeWriteToParcel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;(Landroid/os/Parcel;)V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_writeToParcel &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>gCameraMetadataMethods什么时候会被加载？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_android_hardware_camera2_CameraMetadata</span><span class="params">(JNIEnv *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// Register native functions</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(env,</span><br><span class="line">         CAMERA_METADATA_CLASS_NAME,</span><br><span class="line">         gCameraMetadataMethods,</span><br><span class="line">         <span class="built_in">NELEM</span>(gCameraMetadataMethods));</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">RegisterMethodsOrDie</span><span class="params">(JNIEnv* env, <span class="type">const</span> <span class="type">char</span>* className,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> JNINativeMethod* gMethods, <span class="type">int</span> numMethods)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = AndroidRuntime::<span class="built_in">registerNativeMethods</span>(env, className, gMethods, numMethods);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(res &lt; <span class="number">0</span>, <span class="string">&quot;Unable to register native methods.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>register_android_hardware_camera2_CameraMetadata</code>何时会被调用到，这个就需要了解下JNI的查找方式。</p><h2 id="JNI查找方式"><a href="#JNI查找方式" class="headerlink" title="JNI查找方式"></a>JNI查找方式</h2><blockquote><p>Android系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C&#x2F;C++的进程，即Zygote进程。Zygote启动过程中会AndroidRuntime.cpp中的startVm创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。  </p></blockquote><p>刚才CameraMetadata中<code>register_android_hardware_camera2_CameraMetadata</code>方法，在AndroidRuntime.cpp的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">register_android_hardware_camera2_CameraMetadata</span><span class="params">(JNIEnv *env)</span></span>;</span><br></pre></td></tr></table></figure><p>然后在gRegJNI中的静态声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">REG_JNI</span>(register_android_hardware_camera2_CameraMetadata),</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gRegJNI方法在startReg中被调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> <span class="function"><span class="type">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;RegisterAndroidNatives&quot;</span>);</span><br><span class="line">    <span class="built_in">androidSetCreateThreadFunc</span>((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;--- registering native functions ---\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    env-&gt;<span class="built_in">PushLocalFrame</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_jni_procs</span>(gRegJNI, <span class="built_in">NELEM</span>(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">PopLocalFrame</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="built_in">PopLocalFrame</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//createJavaThread(&quot;fubar&quot;, quickTest, (void*) &quot;hello&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register_jni_procs(gRegJNI, NELEM(gRegJNI), env)会循环调用gRegJNI数组成员所对应的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="type">const</span> RegJNIRec array[], <span class="type">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i].<span class="built_in">mProc</span>(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">            <span class="built_in">ALOGD</span>(<span class="string">&quot;----------!!! %s failed to load\n&quot;</span>, array[i].mName);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样android_hardware_camera2_CameraMetadata.cpp中的<code>int register_android_hardware_camera2_CameraMetadata(JNIEnv *env)</code>就会被调用到。<br>除了这种Android系统启动时，就注册JNI所对应的方法。还有一种就是程序自定义的JNI方法，以 MediePlay 为例：<br>相关代码路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/media/java/android/media/MediaPlayer.java</span><br><span class="line">frameworks/base/media/jni/android_media_MediaPlayer.cpp</span><br></pre></td></tr></table></figure><p>MediaPlayer声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaPlayer</span> <span class="keyword">extends</span> <span class="title class_">PlayerBase</span></span><br><span class="line">                         <span class="keyword">implements</span> <span class="title class_">SubtitleController</span>.Listener</span><br><span class="line">&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">native_init</span><span class="params">()</span>;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      System.loadLibrary(<span class="string">&quot;media_jni&quot;</span>);</span><br><span class="line">      native_init();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块中使用System.loadLibrary加载动态库，media_jni在Android平台对应的是libmedia_jni.so库。<br>在jni目录<code>/frameworks/base/media/jni/Android.mk</code>中有相应的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES:= \</span><br><span class="line">android_media_MediaPlayer.cpp \</span><br><span class="line">...</span><br><span class="line">LOCAL_MODULE:= libmedia_jni</span><br></pre></td></tr></table></figure><p>在<code>android_media_MediaPlayer.cpp</code>找到对应的Native(natvie_init)方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">android_media_MediaPlayer_native_init</span><span class="params">(JNIEnv *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;android/media/MediaPlayer&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNI注册的方法就是上面描述的两种方法：</p><ul><li>在Android系统启动时注册，在AndroidRuntime.cpp中的gRegJNI方法中声明</li><li>使用System.loadLibrary()方式注册</li></ul><h1 id="JNI基础"><a href="#JNI基础" class="headerlink" title="JNI基础"></a>JNI基础</h1><p>上面一节主要描述了系统中Java层和Native层交互和实现，并没有对JNI的基础理论，流程进行分析</p><h2 id="JNI命名规则"><a href="#JNI命名规则" class="headerlink" title="JNI命名规则"></a>JNI命名规则</h2><p>JNI方法名规范 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值 + Java前缀 + 全路径类名 + 方法名 + 参数① JNIEnv + 参数② jobject + 其它参数</span><br></pre></td></tr></table></figure><p>简单的一个例子，返回一个字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI</span><span class="params">(JNIEnv *env, jclass jclass1)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;##### from c&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">&quot;Hello JNI&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值：jstring</li><li>全路径类名：com_yeungeek_jnisample_NativeHelper</li><li>方法名：stringFromJNI</li></ul><h2 id="JNI开发流程"><a href="#JNI开发流程" class="headerlink" title="JNI开发流程"></a>JNI开发流程</h2><ul><li>在Java中先声明一个native方法</li><li>编译Java源文件javac得到.class文件</li><li>通过javah -jni命令导出JNI的.h头文件</li><li>使用Java需要交互的本地代码，实现在Java中声明的Native方法（如果Java需要与C++交互，那么就用C++实现Java的Native方法。）</li><li>将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib)</li><li>通过Java命令执行Java程序，最终实现Java调用本地代码。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table><thead><tr><th align="left">Signature</th><th align="left">Java</th><th align="left">Native</th></tr></thead><tbody><tr><td align="left">B</td><td align="left">byte</td><td align="left">jbyte</td></tr><tr><td align="left">C</td><td align="left">char</td><td align="left">jchar</td></tr><tr><td align="left">D</td><td align="left">double</td><td align="left">jdouble</td></tr><tr><td align="left">F</td><td align="left">float</td><td align="left">jfloat</td></tr><tr><td align="left">I</td><td align="left">int</td><td align="left">jint</td></tr><tr><td align="left">S</td><td align="left">short</td><td align="left">jshort</td></tr><tr><td align="left">J</td><td align="left">long</td><td align="left">jlong</td></tr><tr><td align="left">Z</td><td align="left">boolean</td><td align="left">jboolean</td></tr><tr><td align="left">V</td><td align="left">void</td><td align="left">jvoid</td></tr></tbody></table><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><table><thead><tr><th align="left">Signature</th><th align="left">Java</th><th align="left">Native</th></tr></thead><tbody><tr><td align="left">L+classname +;</td><td align="left">Object</td><td align="left">jobject</td></tr><tr><td align="left">Ljava&#x2F;lang&#x2F;String;</td><td align="left">String</td><td align="left">jstring</td></tr><tr><td align="left">[L+classname +;</td><td align="left">Object[]</td><td align="left">jobjectArray</td></tr><tr><td align="left">Ljava.lang.Class;</td><td align="left">Class</td><td align="left">jclass</td></tr><tr><td align="left">Ljava.lang.Throwable;</td><td align="left">Throwable</td><td align="left">jthrowable</td></tr><tr><td align="left">[B</td><td align="left">byte[]</td><td align="left">jbyteArray</td></tr><tr><td align="left">[C</td><td align="left">char[]</td><td align="left">jcharArray</td></tr><tr><td align="left">[D</td><td align="left">double[]</td><td align="left">jdoubleArray</td></tr><tr><td align="left">[F</td><td align="left">float[]</td><td align="left">jfloatArray</td></tr><tr><td align="left">[I</td><td align="left">int[]</td><td align="left">jintArray</td></tr><tr><td align="left">[S</td><td align="left">short[]</td><td align="left">jshortArray</td></tr><tr><td align="left">[J</td><td align="left">long[]</td><td align="left">jlongArray</td></tr><tr><td align="left">[Z</td><td align="left">boolean[]</td><td align="left">jbooleanArray</td></tr></tbody></table><h2 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h2><p>JNI的方法签名的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数签名格式...)返回值签名格式</span><br></pre></td></tr></table></figure><p>demo的native 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> java.lang.String <span class="title function_">stringFromJNI</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>可以通过javap命令生成方法签名&#96;&#96;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()Ljava/lang/String;</span><br></pre></td></tr></table></figure><h1 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h1><p>Java语言的执行环境是Java虚拟机(JVM)，JVM其实是主机环境中的一个进程，每个JVM虚拟机都在本地环境中有一个JavaVM结构体，该结构体在创建Java虚拟机时被返回，在JNI环境中创建JVM的函数为JNI_CreateJavaVM。<br>JNI 定义了两个关键数据结构，即“JavaVM”和“JNIEnv”，两者本质上都是指向函数表的二级指针。</p><h2 id="JavaVM"><a href="#JavaVM" class="headerlink" title="JavaVM"></a>JavaVM</h2><p>JavaVM是Java虚拟机在JNI层的代表，JavaVM 提供了“调用接口”函数，您可以利用此类函数创建和销毁 JavaVM。理论上，每个进程可以包含多个JavaVM，但AnAndroid只允许每个进程包含一个JavaVM。</p><h2 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv"></a>JNIEnv</h2><p>JNIEnv是一个线程相关的结构体，该结构体代表了Java在本线程的执行环境。JNIEnv 提供了大多数 JNI 函数。您的原生函数均会接收 JNIEnv 作为第一个参数。<br>JNIEnv作用：</p><ul><li>调用Java函数</li><li>操作Java代码</li></ul><p>JNIEnv定义(jni.h)：<br><code>libnativehelper/include/nativehelper/jni.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="keyword">typedef</span> _JNIEnv JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> _JavaVM JavaVM; </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNINativeInterface</span>* JNIEnv;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">JNIInvokeInterface</span>* JavaVM;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>定义中可以看到JavaVM，Android中一个进程只会有一个JavaVM，一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构<br><img src="https://s2.ax1x.com/2019/09/01/n9wYL9.png" alt="javavm.png"></p><h2 id="注册JNI函数"><a href="#注册JNI函数" class="headerlink" title="注册JNI函数"></a>注册JNI函数</h2><p>Java世界和Native世界的方法是如何关联的，就是通过JNI函数注册来实现。JNI函数注册有两种方式：</p><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>这种方法就是通过函数名来找对应的JNI函数，可以通过<code>javah</code>命令行来生成JNI头文件</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah <span class="keyword">com</span>.yeungeek.jnisample.NativeHelper</span><br></pre></td></tr></table></figure><p>生成对应的<code>com_yeungeek_jnisample_NativeHelper.h</code>文件，生成对应的JNI函数，然后在实现这个函数就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_yeungeek_jnisample_NativeHelper</span></span><br><span class="line"><span class="comment"> * Method:    stringFromJNI</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jclass)</span></span>;</span><br></pre></td></tr></table></figure><p>静态注册方法中，Native是如何找到对应的JNI函数，在<a href="#JNI%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F">JNI查找方式</a>中介绍系统的流程，并没有详细说明静态注册的查找。这里简单说明下这个过程(以上面的声明为例子s)：<br>当Java调用native stringFromJNI函数时，会从对应JNI库中查找<code>Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI</code>函数，如果没有找到，就会报错。<br>静态注册方法，就是根据函数名来关联Java函数和JNI函数，JNI函数需要遵循特定的格式，这其中就有一些缺点：</p><ul><li>声明了native方法的Java类，需要通过<code>javah</code>来生成头文件</li><li>JNI函数名称非常长</li><li>第一次调用native函数，需要通过函数名来搜索关联对应的JNI函数，效率比较低</li></ul><p>如何解决这些问题，让native函数，提前知道JNI函数，就可以解决这个问题，这个过程就是动态注册。</p><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册在前面的Camera例子中，已经有涉及到，JNI函数<code>classInit</code>的声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gCameraMetadataMethods[] = &#123;</span><br><span class="line"><span class="comment">// static methods</span></span><br><span class="line">  &#123; <span class="string">&quot;nativeClassInit&quot;</span>,</span><br><span class="line">    <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">    (<span class="type">void</span> *)CameraMetadata_classInit &#125;,   <span class="comment">//和Java层nativeClassInit()对应</span></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JNI中有一种结构用来记录Java的Native方法和JNI方法的关联关系，它就是JNINativeMethod，它在jni.h中被定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;  <span class="comment">//Java层native函数名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* signature; <span class="comment">//Java函数签名，记录参数类型和个数，以及返回值类型</span></span><br><span class="line">    <span class="type">void</span>*       fnPtr; <span class="comment">//Native层对应的函数指针</span></span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure><p>在<a href="#JNI%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F">JNI查找方式</a>说到，JNI注册的两种时间，第一种已经介绍过了，我们自定义的native函数，基本都是会使用<code>System.loadLibrary(“xxx”)</code>，来进行JNI函数的关联。</p><h4 id="loadLibrary-Android7-0"><a href="#loadLibrary-Android7-0" class="headerlink" title="loadLibrary(Android7.0)"></a>loadLibrary(Android7.0)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadLibrary</span><span class="params">(String libname)</span> &#123;</span><br><span class="line">   Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到Runtime(libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java)的loadLibrary0方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">loadLibrary0</span><span class="params">(ClassLoader loader, String libname)</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="type">String</span> <span class="variable">libraryName</span> <span class="operator">=</span> libname;</span><br><span class="line">   <span class="keyword">if</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> loader.findLibrary(libraryName);</span><br><span class="line">      <span class="keyword">if</span> (filename == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// It&#x27;s not necessarily true that the ClassLoader used</span></span><br><span class="line">            <span class="comment">// System.mapLibraryName, but the default setup does, and it&#x27;s</span></span><br><span class="line">            <span class="comment">// misleading to say we didn&#x27;t find &quot;libMyLibrary.so&quot; when we</span></span><br><span class="line">            <span class="comment">// actually searched for &quot;liblibMyLibrary.so.so&quot;.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(loader + <span class="string">&quot; couldn&#x27;t find \&quot;&quot;</span> +</span><br><span class="line">                                          System.mapLibraryName(libraryName) + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//doLoad</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> doLoad(filename, loader);</span><br><span class="line">      <span class="keyword">if</span> (error != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsatisfiedLinkError</span>(error);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//loader 为 null</span></span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">for</span> (String directory : getLibPaths()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">candidate</span> <span class="operator">=</span> directory + filename;</span><br><span class="line">      candidates.add(candidate);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">error</span> <span class="operator">=</span> doLoad(candidate, loader);</span><br><span class="line">            <span class="keyword">if</span> (error == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>; <span class="comment">// We successfully loaded the library. Job done.</span></span><br><span class="line">            &#125;</span><br><span class="line">            lastError = error;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doLoad"><a href="#doLoad" class="headerlink" title="doLoad"></a>doLoad</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">doLoad</span><span class="params">(String name, ClassLoader loader)</span> &#123;</span><br><span class="line">   <span class="comment">//调用 native 方法</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nativeLoad(name, loader, librarySearchPath);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nativeLoad"><a href="#nativeLoad" class="headerlink" title="nativeLoad"></a>nativeLoad</h4><p>进入到虚拟机代码<code>/libcore/ojluni/src/main/native/Runtime.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Runtime_nativeLoad</span><span class="params">(JNIEnv* env, jclass ignored, jstring javaFilename,</span></span></span><br><span class="line"><span class="params"><span class="function">                   jobject javaLoader, jstring javaLibrarySearchPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JVM_NativeLoad</span>(env, javaFilename, javaLoader, javaLibrarySearchPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>JVM_NativeLoad</code>，JVM_NativeLoad方法申明在jvm.h中，实现在<code>OpenjdkJvm.cc(/art/runtime/openjdkjvm/OpenjdkJvm.cc)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jstring <span class="title">JVM_NativeLoad</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 jstring javaFilename,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 jobject javaLoader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 jstring javaLibrarySearchPath)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">filename</span><span class="params">(env, javaFilename)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (filename.<span class="built_in">c_str</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string error_msg;</span><br><span class="line">  &#123;</span><br><span class="line">    art::JavaVMExt* vm = art::Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetJavaVM</span>();</span><br><span class="line">    <span class="type">bool</span> success = vm-&gt;<span class="built_in">LoadNativeLibrary</span>(env,</span><br><span class="line">                                         filename.<span class="built_in">c_str</span>(),</span><br><span class="line">                                         javaLoader,</span><br><span class="line">                                         javaLibrarySearchPath,</span><br><span class="line">                                         &amp;error_msg);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Don&#x27;t let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF.</span></span><br><span class="line">  env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">  <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(error_msg.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LoadNativeLibrary"><a href="#LoadNativeLibrary" class="headerlink" title="LoadNativeLibrary"></a>LoadNativeLibrary</h4><p>调用JavaVMExt的LoadNativeLibrary方法，方法在(art&#x2F;runtime&#x2F;java_vm_ext.cc)中，这个方法代码非常多，选取主要的部分进行分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JavaVMExt::LoadNativeLibrary</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">const</span> std::string&amp; path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  jobject class_loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  jstring library_path,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string* error_msg)</span> </span>&#123;</span><br><span class="line">         ......</span><br><span class="line">         <span class="type">bool</span> was_successful = <span class="literal">false</span>;</span><br><span class="line">         <span class="comment">//加载so库中查找JNI_OnLoad方法，如果没有系统就认为是静态注册方式进行的，直接返回true，代表so库加载成功，</span></span><br><span class="line">         <span class="comment">//如果找到JNI_OnLoad就会调用JNI_OnLoad方法，JNI_OnLoad方法中一般存放的是方法注册的函数，</span></span><br><span class="line">         <span class="comment">//所以如果采用动态注册就必须要实现JNI_OnLoad方法，否则调用java中申明的native方法时会抛出异常</span></span><br><span class="line">         <span class="type">void</span>* sym = library-&gt;<span class="built_in">FindSymbol</span>(<span class="string">&quot;JNI_OnLoad&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">         <span class="keyword">if</span> (sym == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">VLOG</span>(jni) &lt;&lt; <span class="string">&quot;[No JNI_OnLoad found in \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;]&quot;</span>;</span><br><span class="line">            was_successful = <span class="literal">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Call JNI_OnLoad.  We have to override the current class</span></span><br><span class="line">            <span class="comment">// loader, which will always be &quot;null&quot; since the stuff at the</span></span><br><span class="line">            <span class="comment">// top of the stack is around Runtime.loadLibrary().  (See</span></span><br><span class="line">            <span class="comment">// the comments in the JNI FindClass function.)</span></span><br><span class="line">            ScopedLocalRef&lt;jobject&gt; <span class="built_in">old_class_loader</span>(env, env-&gt;<span class="built_in">NewLocalRef</span>(self-&gt;<span class="built_in">GetClassLoaderOverride</span>()));</span><br><span class="line">            self-&gt;<span class="built_in">SetClassLoaderOverride</span>(class_loader);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">VLOG</span>(jni) &lt;&lt; <span class="string">&quot;[Calling JNI_OnLoad in \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;]&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*JNI_OnLoadFn)</span><span class="params">(JavaVM*, <span class="type">void</span>*)</span></span>;</span><br><span class="line">            JNI_OnLoadFn jni_on_load = <span class="built_in">reinterpret_cast</span>&lt;JNI_OnLoadFn&gt;(sym);</span><br><span class="line">            <span class="comment">//调用JNI_OnLoad方法</span></span><br><span class="line">            <span class="type">int</span> version = (*jni_on_load)(<span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (runtime_-&gt;<span class="built_in">GetTargetSdkVersion</span>() != <span class="number">0</span> &amp;&amp; runtime_-&gt;<span class="built_in">GetTargetSdkVersion</span>() &lt;= <span class="number">21</span>) &#123;</span><br><span class="line">               <span class="comment">// Make sure that sigchain owns SIGSEGV.</span></span><br><span class="line">               <span class="built_in">EnsureFrontOfChain</span>(SIGSEGV);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            self-&gt;<span class="built_in">SetClassLoaderOverride</span>(old_class_loader.<span class="built_in">get</span>());</span><br><span class="line">         &#125;</span><br><span class="line">         ......</span><br><span class="line">&#125;                        </span><br></pre></td></tr></table></figure><p>代码里的主要逻辑：</p><ul><li>加载so库中查找JNI_OnLoad方法，如果没有系统就认为是静态注册方式进行的，直接返回true，代表so库加载成功</li><li>如果找到JNI_OnLoad就会调用JNI_OnLoad方法，JNI_OnLoad方法中一般存放的是方法注册的函数</li><li>所以如果采用动态注册就必须要实现<code>JNI_OnLoad</code>方法，否则调用Java中的native方法时会抛出异常</li></ul><h2 id="jclass、jmethodID和jfieldID"><a href="#jclass、jmethodID和jfieldID" class="headerlink" title="jclass、jmethodID和jfieldID"></a>jclass、jmethodID和jfieldID</h2><p>如果要通过原生代码访问对象的字段，需要执行以下操作：</p><ol><li>使用 FindClass 获取类的类对象引用</li><li>使用 GetFieldID 获取字段的字段 ID</li><li>使用适当内容获取字段的内容，例如 GetIntField</li></ol><p>具体的使用，放在第二篇文章中讲解</p><h2 id="JNI的引用"><a href="#JNI的引用" class="headerlink" title="JNI的引用"></a>JNI的引用</h2><p>JNI规范中定义了三种引用：</p><ul><li>局部引用（Local Reference）</li><li>全局引用（Global Reference）</li><li>弱全局引用（Weak Global Reference）</li></ul><h3 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h3><p>也叫本地引用，在 JNI层函数使用的非全局引用对象都是Local Reference，最大的特点就是，JNI 函数返回后，这些声明的引用可能就会被垃圾回收</p><h3 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h3><p>这种声明的对象，不会主动释放资源，不会被垃圾回收</p><h3 id="弱全局引用"><a href="#弱全局引用" class="headerlink" title="弱全局引用"></a>弱全局引用</h3><p>一种特殊的全局引用，在运行过程中可能被回收，使用之前需要判断下是否为空</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/59827fb86fb9a03c341907e6">Android：清晰讲解JNI 与 NDK（含实例教学）</a></li><li><a href="https://www.jianshu.com/nb/22528035">Android JNI学习</a></li><li><a href="http://gityuan.com/2016/05/28/android-jni/">Android JNI原理分析</a></li><li><a href="http://liuwangshu.cn/framework/jni/1-mediarecorder_register.html">Android深入理解JNI（一）JNI原理与静态、动态注册</a></li><li><a href="https://developer.android.com/training/articles/perf-jni">JNI Tips</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java调用C&amp;#x2F;C++在Java语言里面本来就有的，并非Android独有的，即JNI。JNI就是Java调用C++的规范。&lt;/p&gt;</summary>
    
    
    
    <category term="Android框架层" scheme="http://yeungeek.github.io/categories/Android%E6%A1%86%E6%9E%B6%E5%B1%82/"/>
    
    
    <category term="JNI" scheme="http://yeungeek.github.io/tags/JNI/"/>
    
    <category term="NDK" scheme="http://yeungeek.github.io/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-Retrofit源码角度分析Http</title>
    <link href="http://yeungeek.github.io/2019/07/25/Network-Retrofit/"/>
    <id>http://yeungeek.github.io/2019/07/25/Network-Retrofit/</id>
    <published>2019-07-25T19:31:38.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲解了OKHttp，本篇来介绍下它的黄金搭档Retrofit，OKHttp+Retrofit是网络框架的不二之选。同是Square出品，和OKHttp融合起来非常简单。<br>Retofit是一个RESTful的HTTP网络请求框架，有以下特点：</p><ul><li>基于OKHttp</li><li>通过注解配置网络请求参数</li><li>支持同步、异步请求</li><li>支持多种序列化、反序列化格式</li><li>解耦彻底、模块高度封装，使用很多设计模式来实现<span id="more"></span></li></ul><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>下面讲解的是官网的例子</p><h2 id="创建网络请求接口"><a href="#创建网络请求接口" class="headerlink" title="创建网络请求接口"></a>创建网络请求接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GitHubService</span> &#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; <span class="title function_">listRepos</span><span class="params">(<span class="meta">@Path(&quot;user&quot;)</span> String user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建Retrofit实例-使用建造者模式"><a href="#创建Retrofit实例-使用建造者模式" class="headerlink" title="创建Retrofit实例(使用建造者模式)"></a>创建Retrofit实例(使用建造者模式)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="创建网络接口实例"><a href="#创建网络接口实例" class="headerlink" title="创建网络接口实例"></a>创建网络接口实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GitHubService</span> <span class="variable">service</span> <span class="operator">=</span> retrofit.create(GitHubService.class);</span><br><span class="line"></span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">&quot;yeungeek&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="发送网络请求"><a href="#发送网络请求" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>默认返回的是OKHttpCall，实际真正发送请求的就是OKHttp</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;List&lt;Repo&gt;&gt; list = repos.execute()</span><br></pre></td></tr></table></figure><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;List&lt;Repo&gt;&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response)</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t)</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h1><p>具体的请求流程可以分为7大步骤<br><img src="https://s2.ax1x.com/2019/08/13/mPNBQK.png" alt="retrofit"></p><ol><li>解析网络请求接口的注解，配置网络请求参数</li><li>通过动态代理生成网络请求对象</li><li>通过CallAdapter，将网络请求对象进行平台适配(Android,Java8)</li><li>通过网络请求执行器(Call)，发送网络请求</li><li>通过Converter进行数据解析</li><li>通过回调执行器，进行线程切换</li><li>在主线程处理返回结果</li></ol><p>Refrofit最大特点是使用了大量的设计模式，来进行解耦，下图是完整的流程图(来自<a href="https://www.jianshu.com/p/45cb536be2f4">Stay 在 Retrofit分析-漂亮的解耦套路</a>)：<br><img src="https://s2.ax1x.com/2019/08/17/muu48s.png" alt="retrofit 流程图"><br>接下来通过源码分析，详细讲解上面的流程</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Retrofit初始化"><a href="#Retrofit初始化" class="headerlink" title="Retrofit初始化"></a>Retrofit初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Retrofit</span> <span class="variable">retrofit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>  <span class="comment">//1. Retrofit声明</span></span><br><span class="line">    .Builder()                    <span class="comment">//2. Builder</span></span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.github.com/&quot;</span>)   <span class="comment">//3. baseUrl</span></span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())  <span class="comment">//4. Converter Factory</span></span><br><span class="line">    .addCallAdapterFactory(RxJava2CallAdapterFactory.create())  <span class="comment">//5. CallAdapter Factory</span></span><br><span class="line">    .build();                    <span class="comment">//6. 生成实例</span></span><br></pre></td></tr></table></figure><h3 id="Retrofit声明"><a href="#Retrofit声明" class="headerlink" title="Retrofit声明"></a>Retrofit声明</h3><p>在使用Retrofit时，首先通过建造者模式构建Retrofit。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Retrofit</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">  <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">  <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories;</span><br><span class="line">  <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories;</span><br><span class="line">  <span class="keyword">final</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,</span><br><span class="line">      List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories,</span><br><span class="line">      <span class="meta">@Nullable</span> Executor callbackExecutor, <span class="type">boolean</span> validateEagerly) &#123;</span><br><span class="line">    <span class="built_in">this</span>.callFactory = callFactory;</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">    <span class="built_in">this</span>.converterFactories = converterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="built_in">this</span>.callAdapterFactories = callAdapterFactories; <span class="comment">// Copy+unmodifiable at call site.</span></span><br><span class="line">    <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="built_in">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>serviceMethodCache：网络请求配置对象缓存，通过解析网络请求接口后得到请求对象</li><li>callFactory：网络请求器工厂(Call)，默认实现是OKHttp</li><li>baseUrl：网络请求Url地址</li><li>converterFactories：数据转换器工厂集合</li><li>callAdapterFactories：请求适配器工厂集合</li><li>callbackExecutor：回调方法执行器</li><li>validateEagerly：是否提前验证请求方法</li></ul><p>剩下的步骤都是来初始化上面的参数</p><h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">    <span class="keyword">private</span> HttpUrl baseUrl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> validateEagerly;</span><br><span class="line"></span><br><span class="line">    Builder(Platform platform) &#123;</span><br><span class="line">      <span class="built_in">this</span>.platform = platform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>(Platform.get());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder中的参数和 Retrfit 是意义一一对应的，默认构造函数进行平台的选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Platform</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">PLATFORM</span> <span class="operator">=</span> findPlatform();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Platform <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title function_">findPlatform</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">&quot;android.os.Build&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Android</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">&quot;java.util.Optional&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Java8</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Platform</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反射来判断选择Android还是Java8，以前版本还有对IOS平台的支持，最新版本已经去掉了。<br>我们看下Android平台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Android</span> <span class="keyword">extends</span> <span class="title class_">Platform</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Executor <span class="title function_">defaultCallbackExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//默认回调执行器，会切换到主线程</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MainThreadExecutor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> CallAdapter.Factory <span class="title function_">defaultCallAdapterFactory</span><span class="params">(<span class="meta">@Nullable</span> Executor callbackExecutor)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (callbackExecutor == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">      <span class="comment">//默认的 CallAdapter</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutorCallAdapterFactory</span>(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="baseUrl"><a href="#baseUrl" class="headerlink" title="baseUrl"></a>baseUrl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder <span class="title function_">baseUrl</span><span class="params">(String baseUrl)</span> &#123;</span><br><span class="line">   checkNotNull(baseUrl, <span class="string">&quot;baseUrl == null&quot;</span>);</span><br><span class="line">   <span class="type">HttpUrl</span> <span class="variable">httpUrl</span> <span class="operator">=</span> HttpUrl.parse(baseUrl);</span><br><span class="line">   <span class="keyword">if</span> (httpUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal URL: &quot;</span> + baseUrl);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> baseUrl(httpUrl);</span><br><span class="line"> &#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">baseUrl</span><span class="params">(HttpUrl baseUrl)</span> &#123;</span><br><span class="line">  checkNotNull(baseUrl, <span class="string">&quot;baseUrl == null&quot;</span>);</span><br><span class="line">  List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">  <span class="comment">//检查合法性</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(pathSegments.get(pathSegments.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;baseUrl must end in /: &quot;</span> + baseUrl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.baseUrl = baseUrl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把String url 转换成HttpUrl，会对baseUrl进行合法性校验(URL参数是不是以”&#x2F;“结尾)</p><h3 id="ConverterFactory"><a href="#ConverterFactory" class="headerlink" title="ConverterFactory"></a>ConverterFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder <span class="title function_">addConverterFactory</span><span class="params">(Converter.Factory factory)</span> &#123;</span><br><span class="line">   converterFactories.add(checkNotNull(factory, <span class="string">&quot;factory == null&quot;</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>把factory加到数据转换器集合中，看下GsonFactory.create()具体的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> GsonConverterFactory <span class="title function_">create</span><span class="params">(Gson gson)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (gson == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;gson == null&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GsonConverterFactory</span>(gson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">GsonConverterFactory</span><span class="params">(Gson gson)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.gson = gson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">    Retrofit retrofit) &#123;</span><br><span class="line">  TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GsonResponseBodyConverter</span>&lt;&gt;(gson, adapter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">  TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GsonRequestBodyConverter</span>&lt;&gt;(gson, adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GsonConverterFactory使用Gson 为初始化参数，实现<code>responseBodyConverter</code>和<code>requestBodyConverter</code>接口，进行真正的数据转换处理。</p><h3 id="CallAdapterFactory"><a href="#CallAdapterFactory" class="headerlink" title="CallAdapterFactory"></a>CallAdapterFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Builder <span class="title function_">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> &#123;</span><br><span class="line">  callAdapterFactories.add(checkNotNull(factory, <span class="string">&quot;factory == null&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把factory加到请求适配器工厂集合中，Android 平台默认实现是ExecutorCallAdapterFactory，后面再进行详细讲解。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>最后一步build生成Retrofit对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Retrofit <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (baseUrl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Base URL required.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  okhttp3.Call.<span class="type">Factory</span> <span class="variable">callFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (callFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">    callFactory = <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Executor</span> <span class="variable">callbackExecutor</span> <span class="operator">=</span> <span class="built_in">this</span>.callbackExecutor;</span><br><span class="line">  <span class="keyword">if</span> (callbackExecutor == <span class="literal">null</span>) &#123;</span><br><span class="line">    callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">  List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.callAdapterFactories);</span><br><span class="line">  callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">  List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1</span> + <span class="built_in">this</span>.converterFactories.size());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">  <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">  converterFactories.add(<span class="keyword">new</span> <span class="title class_">BuiltInConverters</span>());</span><br><span class="line">  converterFactories.addAll(<span class="built_in">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retrofit</span>(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">      unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>callFactory配置，默认OkHttpClient</li><li>callbackExecutor配置，Android 平台默认使用<code>MainThreadExecutor</code></li><li>callAdapterFactories配置，先加入自定义的callAdapter，然后再加入defaultCallAdapterFactory</li><li>converterFactories配置，先加入内建转换器(BuiltInConverters)，然后加入自定义的数据转换器</li><li>生成Retrofit对象</li></ul><h2 id="创建网络接口实例-1"><a href="#创建网络接口实例-1" class="headerlink" title="创建网络接口实例"></a>创建网络接口实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GitHubService</span> &#123;</span><br><span class="line">  <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; <span class="title function_">listRepos</span><span class="params">(<span class="meta">@Path(&quot;user&quot;)</span> String user)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建接口实例</span></span><br><span class="line"><span class="type">GitHubService</span> <span class="variable">service</span> <span class="operator">=</span> retrofit.create(GitHubService.class);</span><br><span class="line"><span class="comment">//生成请求对象</span></span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">&quot;yeungeek&quot;</span>);</span><br></pre></td></tr></table></figure><p>Retrofit通过外观模式和动态代理生成网络接口实例，网络接口的请求参数从接口声明获取</p><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create方法中最重要的是使用了动态代理，调用接口的方法都会到Proxy的invoke方法中，在invoke方法中最重要的就是下面三行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br></pre></td></tr></table></figure><h3 id="loadServiceMethod"><a href="#loadServiceMethod" class="headerlink" title="loadServiceMethod"></a>loadServiceMethod</h3><p>该方法读取网络请求接口里的方法，根据配置生成ServiceMethod对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      result = <span class="keyword">new</span> <span class="title class_">ServiceMethod</span>.Builder&lt;&gt;(<span class="built_in">this</span>, method).build();</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadServiceMethod会先从cache中获取对象，如果获取不到，则通过建造者模式生成ServiceMethod对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServiceMethod</span>.Builder&lt;&gt;(<span class="built_in">this</span>, method).build();</span><br></pre></td></tr></table></figure><h4 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceMethod</span>&lt;R, T&gt; &#123;</span><br><span class="line">  <span class="comment">// Upper and lower characters, digits, underscores, and hyphens, starting with a character.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARAM</span> <span class="operator">=</span> <span class="string">&quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">PARAM_URL_REGEX</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\&#123;(&quot;</span> + PARAM + <span class="string">&quot;)\\&#125;&quot;</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">PARAM_NAME_REGEX</span> <span class="operator">=</span> Pattern.compile(PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CallAdapter&lt;R, T&gt; callAdapter;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpUrl baseUrl;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;ResponseBody, R&gt; responseConverter;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String httpMethod;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String relativeUrl;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Headers headers;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MediaType contentType;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> hasBody;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isFormEncoded;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> isMultipart;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line"></span><br><span class="line">  ServiceMethod(Builder&lt;R, T&gt; builder) &#123;</span><br><span class="line">    <span class="built_in">this</span>.callFactory = builder.retrofit.callFactory();</span><br><span class="line">    <span class="built_in">this</span>.callAdapter = builder.callAdapter;</span><br><span class="line">    <span class="built_in">this</span>.baseUrl = builder.retrofit.baseUrl();</span><br><span class="line">    <span class="built_in">this</span>.responseConverter = builder.responseConverter;</span><br><span class="line">    <span class="built_in">this</span>.httpMethod = builder.httpMethod;</span><br><span class="line">    <span class="built_in">this</span>.relativeUrl = builder.relativeUrl;</span><br><span class="line">    <span class="built_in">this</span>.headers = builder.headers;</span><br><span class="line">    <span class="built_in">this</span>.contentType = builder.contentType;</span><br><span class="line">    <span class="built_in">this</span>.hasBody = builder.hasBody;</span><br><span class="line">    <span class="built_in">this</span>.isFormEncoded = builder.isFormEncoded;</span><br><span class="line">    <span class="built_in">this</span>.isMultipart = builder.isMultipart;</span><br><span class="line">    <span class="built_in">this</span>.parameterHandlers = builder.parameterHandlers;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>callFactory：网络请求器工厂，和retrofit对象声明中的含义一样</li><li>callAdapter：网络请求适配器工厂</li><li>baseUrl：网络请求Url地址</li><li>responseConverter：Response 数据转换器</li><li>httpMethod：http 请求方法</li><li>relativeUrl：网络请求相对地址</li><li>headers：网络请求头</li><li>contentType：网络请求 body 类型</li><li>parameterHandlers：方法处理解析器</li></ul><h4 id="ServiceMethod-Builder"><a href="#ServiceMethod-Builder" class="headerlink" title="ServiceMethod.Builder"></a>ServiceMethod.Builder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">   <span class="built_in">this</span>.retrofit = retrofit;</span><br><span class="line">   <span class="built_in">this</span>.method = method;</span><br><span class="line">   <span class="built_in">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">   <span class="built_in">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">   <span class="built_in">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>methodAnnotations：网络请求接口方法注解</li><li>parameterTypes：网络请求接口方法里的参数注解</li><li>parameterAnnotationsArray：网络请求接口方法里的注解内容</li></ul><h4 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceMethod <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">//1. 从 Retrofit 中获取网络请求器</span></span><br><span class="line">   callAdapter = createCallAdapter();</span><br><span class="line">   responseType = callAdapter.responseType();</span><br><span class="line">   <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">     <span class="keyword">throw</span> methodError(<span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">         + Utils.getRawType(responseType).getName()</span><br><span class="line">         + <span class="string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2. 从 Refrofit 中获取数据转换器</span></span><br><span class="line">   responseConverter = createResponseConverter();</span><br><span class="line">   <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">   <span class="comment">//3. 解析网络请求接口中方法的注解</span></span><br><span class="line">     parseMethodAnnotation(annotation);</span><br><span class="line">   &#125;</span><br><span class="line">   .....</span><br><span class="line">   <span class="type">int</span> <span class="variable">parameterCount</span> <span class="operator">=</span> parameterAnnotationsArray.length;</span><br><span class="line">   parameterHandlers = <span class="keyword">new</span> <span class="title class_">ParameterHandler</span>&lt;?&gt;[parameterCount];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">     <span class="type">Type</span> <span class="variable">parameterType</span> <span class="operator">=</span> parameterTypes[p];</span><br><span class="line">     <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> parameterError(p, <span class="string">&quot;Parameter type must not include a type variable or wildcard: %s&quot;</span>,</span><br><span class="line">           parameterType);</span><br><span class="line">     &#125;</span><br><span class="line">     Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">     <span class="keyword">if</span> (parameterAnnotations == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> parameterError(p, <span class="string">&quot;No Retrofit annotation found.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4. 创建ParameterHandler&lt;?&gt;，用来解析来解析参数使用到注解</span></span><br><span class="line">     parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceMethod</span>&lt;&gt;(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createCallAdapter：根据接口方法返回类型、接口请求的注解，获取网络请求器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; <span class="title function_">createCallAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//获取接口方法的返回类型</span></span><br><span class="line">  <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">  <span class="keyword">if</span> (Utils.hasUnresolvableType(returnType)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(</span><br><span class="line">        <span class="string">&quot;Method return type must not include a type variable or wildcard: %s&quot;</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (returnType == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">&quot;Service methods cannot return void.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取接口请求的注解</span></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(e, <span class="string">&quot;Unable to create call adapter for %s&quot;</span>, returnType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createResponseConverter：根据接口请求注解类型、返回类型，获取数据数据转换器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title function_">createResponseConverter</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//获取接口请求的注解</span></span><br><span class="line">  Annotation[] annotations = method.getAnnotations();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//从Rtrofit中获取数据转换器</span></span><br><span class="line">    <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123; <span class="comment">// Wide exception range because factories are user code.</span></span><br><span class="line">    <span class="keyword">throw</span> methodError(e, <span class="string">&quot;Unable to create converter for %s&quot;</span>, responseType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parseMethodAnnotation：解析请求接口的方法注解，主要有以下标签</p><ul><li>Http请求方法</li><li>Headers</li><li>Multipart</li><li>FormUrlEncoded</li></ul><p>parseParameter：对方法的参数注解进行解析<br>包含：Url，Path，Query，QueryName，QueryMap，Header，HeaderMap，Field，FieldMap，Part，PartMap，Body</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ParameterHandler&lt;?&gt; parseParameter(</span><br><span class="line">    <span class="type">int</span> p, Type parameterType, Annotation[] annotations) &#123;</span><br><span class="line">  ParameterHandler&lt;?&gt; result = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    <span class="comment">//参数注解解析</span></span><br><span class="line">    ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation(</span><br><span class="line">        p, parameterType, annotations, annotation);</span><br><span class="line">    <span class="keyword">if</span> (annotationAction == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">&quot;Multiple Retrofit annotations found, only one allowed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = annotationAction;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> parameterError(p, <span class="string">&quot;No Retrofit annotation found.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OKHttpCall"><a href="#OKHttpCall" class="headerlink" title="OKHttpCall"></a>OKHttpCall</h3><p>根据serviceMethod和请求参数，创建OkHttpCall对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OkHttpCall</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Call</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ServiceMethod&lt;T, ?&gt; serviceMethod;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;</span><br><span class="line">  <span class="meta">@GuardedBy(&quot;this&quot;)</span> <span class="comment">// Either a RuntimeException, non-fatal Error, or IOException.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> Throwable creationFailure;</span><br><span class="line">  <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> executed;</span><br><span class="line"></span><br><span class="line">  OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, <span class="meta">@Nullable</span> Object[] args) &#123;</span><br><span class="line">    <span class="built_in">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>serviceMethod和 args不做介绍了</p><ul><li>rawCall：OKHttp，真正发送网络请求</li><li>canceled：取消请求标志位</li><li>executed：是否执行标志位</li><li>creationFailure：异常标志位</li></ul><h3 id="adapt"><a href="#adapt" class="headerlink" title="adapt"></a>adapt</h3><p>根据ServiceMethod的中的callAdapter，来真正执行adapt方法<br>ServiceMethod的adapt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">adapt</span><span class="params">(Call&lt;R&gt; call)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android 默认的返回 ExecutorCallAdapterFactory的Call<br>这里使用了静态代理delegate，加入一些额外的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title function_">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutorCallAdapterFactory</span>.ExecutorCallbackCall(ExecutorCallAdapterFactory.<span class="built_in">this</span>.callbackExecutor, call);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">   <span class="built_in">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">   <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RxJavaCallAdapterFactory返回的是Observable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">adapt</span><span class="params">(Call&lt;R&gt; call)</span> &#123;</span><br><span class="line">  Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</span><br><span class="line">      ? <span class="keyword">new</span> <span class="title class_">CallEnqueueObservable</span>&lt;&gt;(call)</span><br><span class="line">      : <span class="keyword">new</span> <span class="title class_">CallExecuteObservable</span>&lt;&gt;(call);</span><br><span class="line">  Observable&lt;?&gt; observable;</span><br><span class="line">  <span class="keyword">if</span> (isResult) &#123;</span><br><span class="line">    observable = <span class="keyword">new</span> <span class="title class_">ResultObservable</span>&lt;&gt;(responseObservable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBody) &#123;</span><br><span class="line">    observable = <span class="keyword">new</span> <span class="title class_">BodyObservable</span>&lt;&gt;(responseObservable);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observable = responseObservable;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (scheduler != <span class="literal">null</span>) &#123;</span><br><span class="line">    observable = observable.subscribeOn(scheduler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isFlowable) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.toFlowable(BackpressureStrategy.LATEST);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSingle) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.singleOrError();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isMaybe) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.singleElement();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isCompletable) &#123;</span><br><span class="line">    <span class="keyword">return</span> observable.ignoreElements();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> observable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面几步操作 <code>Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;yeungeek&quot;)</code>，返回了一个 OKHttpCall 对象。</p><h2 id="发送网络请求-1"><a href="#发送网络请求-1" class="headerlink" title="发送网络请求"></a>发送网络请求</h2><p>请求和 OKHttp 一样，分为同步请求和异步请求</p><h3 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h3><p>execute 首先会调用ExecutorCallbackCall的execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response&lt;T&gt; <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">return</span> delegate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delegate代理实际是 OKHttpCall，最终会调用OKHttpCall的execute方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response&lt;T&gt; <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  okhttp3.Call call;</span><br><span class="line">  ......</span><br><span class="line">    call = rawCall;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException | RuntimeException | Error e) &#123;</span><br><span class="line">        throwIfFatal(e); <span class="comment">//  Do not assign a fatal error to creationFailure.</span></span><br><span class="line">        creationFailure = e;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="createRawCall"><a href="#createRawCall" class="headerlink" title="createRawCall"></a>createRawCall</h4><p>创建真正发送的请求Request对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> okhttp3.Call <span class="title function_">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  okhttp3.<span class="type">Call</span> <span class="variable">call</span> <span class="operator">=</span> serviceMethod.toCall(args);</span><br><span class="line">  <span class="keyword">if</span> (call == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Call.Factory returned null.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用serviceMethod的 toCall 方法</span></span><br><span class="line">okhttp3.Call <span class="title function_">toCall</span><span class="params">(<span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">//Request 的 builder 生成 Reuqest 对象</span></span><br><span class="line">  <span class="type">RequestBuilder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestBuilder</span>(httpMethod, baseUrl, relativeUrl, headers,</span><br><span class="line">      contentType, hasBody, isFormEncoded, isMultipart);</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="comment">// It is an error to invoke a method with the wrong arg types.</span></span><br><span class="line">  ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;</span><br><span class="line">  <span class="type">int</span> <span class="variable">argumentCount</span> <span class="operator">=</span> args != <span class="literal">null</span> ? args.length : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (argumentCount != handlers.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Argument count (&quot;</span> + argumentCount</span><br><span class="line">        + <span class="string">&quot;) doesn&#x27;t match expected count (&quot;</span> + handlers.length + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; argumentCount; p++) &#123;</span><br><span class="line">    handlers[p].apply(requestBuilder, args[p]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> callFactory.newCall(requestBuilder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parseResponse"><a href="#parseResponse" class="headerlink" title="parseResponse"></a>parseResponse</h4><p>调用OKHttp的execute发送网络请求，根据网络请求结果再进行结果解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Response&lt;T&gt; <span class="title function_">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">ResponseBody</span> <span class="variable">rawBody</span> <span class="operator">=</span> rawResponse.body();</span><br><span class="line">  <span class="comment">// Remove the body&#x27;s source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse = rawResponse.newBuilder()</span><br><span class="line">      .body(<span class="keyword">new</span> <span class="title class_">NoContentResponseBody</span>(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">      .build();</span><br><span class="line">  <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      <span class="type">ResponseBody</span> <span class="variable">bufferedBody</span> <span class="operator">=</span> Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    rawBody.close();</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="literal">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">ExceptionCatchingRequestBody</span> <span class="variable">catchingBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionCatchingRequestBody</span>(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">body</span> <span class="operator">=</span> serviceMethod.toResponse(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">    <span class="comment">// a runtime exception.</span></span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先对响应码进行处理，再通过serviceMethod.toResponse选择数据转换器，对数据进行解析后，生成Response对象返回</p><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>异步请求的流程和同步请求一样，就是再回调处理会进行线程切换<br>ExecutorCallbackCall的enqueue方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">  checkNotNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  delegate.enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;T&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> &#123;</span><br><span class="line">      callbackExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">            <span class="comment">// Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">            callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback.onResponse(ExecutorCallbackCall.<span class="built_in">this</span>, response);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> &#123;</span><br><span class="line">      callbackExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          callback.onFailure(ExecutorCallbackCall.<span class="built_in">this</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理执行加入了线程切换到逻辑，通过callbackExecutor切换到主线程<br>OKHttpCall的enqueue方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> &#123;</span><br><span class="line">  checkNotNull(callback, <span class="string">&quot;callback == null&quot;</span>);</span><br><span class="line"></span><br><span class="line">  okhttp3.Call call;</span><br><span class="line">  Throwable failure;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already executed.&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    call = rawCall;</span><br><span class="line">    failure = creationFailure;</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="literal">null</span> &amp;&amp; failure == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        call = rawCall = createRawCall();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        throwIfFatal(t);</span><br><span class="line">        failure = creationFailure = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (failure != <span class="literal">null</span>) &#123;</span><br><span class="line">    callback.onFailure(<span class="built_in">this</span>, failure);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">    call.cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  call.enqueue(<span class="keyword">new</span> <span class="title class_">okhttp3</span>.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> &#123;</span><br><span class="line">      Response&lt;T&gt; response;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = parseResponse(rawResponse);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        callback.onResponse(OkHttpCall.<span class="built_in">this</span>, response);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> &#123;</span><br><span class="line">      callFailure(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callFailure</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        callback.onFailure(OkHttpCall.<span class="built_in">this</span>, e);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用到RxJava，在上一节已经提到， adapt会进行适配，RxJava2CallAdapter的adapt方法中有对RxJava转换，具体逻辑实现这边先不展开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</span><br><span class="line">        ? <span class="keyword">new</span> <span class="title class_">CallEnqueueObservable</span>&lt;&gt;(call)</span><br><span class="line">        : <span class="keyword">new</span> <span class="title class_">CallExecuteObservable</span>&lt;&gt;(call);</span><br></pre></td></tr></table></figure><h1 id="Retrofit中的HTTP实现"><a href="#Retrofit中的HTTP实现" class="headerlink" title="Retrofit中的HTTP实现"></a>Retrofit中的HTTP实现</h1><p>Retrofit真正请求网络，底层使用的是OKHttp，Refrofit主要负责网络请求接口的封装，看下源码中与HTTP相关的注解<br><img src="https://s2.ax1x.com/2019/08/17/munlOf.png" alt="Retrofit-HTTP"><br>这些注解都是在接口上的声明，主要是HTTP的请求方法和参数，具体可以参考<a href="/2019/07/12/Network-Http/#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">Android网络编程-HTTP&#x2F;HTTPS</a>，这里也不具体展开了</p><h1 id="设计模式应用"><a href="#设计模式应用" class="headerlink" title="设计模式应用"></a>设计模式应用</h1><p>我们再回顾下这张流程图:<br><img src="https://s2.ax1x.com/2019/08/17/muu48s.png" alt="retrofit-stay"></p><h2 id="构建者模式"><a href="#构建者模式" class="headerlink" title="构建者模式"></a>构建者模式</h2><p>这个模式运用的比较多，Retrofit的Builder，ServiceMethod的Builder等<br>设计模式可以参考<a href="http://c.biancheng.net/view/1354.html">建造者模式（Bulider模式）详解</a></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在Retrofit 初始化，addCallAdapterFactory中的CallAdapter就是用工厂方法模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CallAdapter</span>&lt;R, T&gt; &#123;</span><br><span class="line">  Type <span class="title function_">responseType</span><span class="params">()</span>;</span><br><span class="line">  T <span class="title function_">adapt</span><span class="params">(Call&lt;R&gt; call)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Type <span class="title function_">getParameterUpperBound</span><span class="params">(<span class="type">int</span> index, ParameterizedType type)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.getRawType(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Factory中抽象方法get，就会返回不同的 CallAdapter 对象<br>设计模式可以参考<a href="http://c.biancheng.net/view/1348.html">工厂方法模式（详解版）</a></p><h2 id="外观模式-门面模式"><a href="#外观模式-门面模式" class="headerlink" title="外观模式(门面模式)"></a>外观模式(门面模式)</h2><p>Retrofit 就是一个典型的外观类，它屏蔽了所有的实现细节，提供给使用者方便的接口，统一调用创建接口实例和网络请求配置的方法<br>设计模式可以参考<a href="http://c.biancheng.net/view/1369.html">外观模式（Facade模式）详解</a></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>主要应用CallAdapter类的adapt方法，在 Retrofit addCallAdapterFactory，对应 Factory 生成不同的CallAdapter，adapt就可以调用到不同实现<br>CallAdapter就是一个Strategy，Retrofit 对应上下文(Context)<br>设计模式可以参考<a href="http://c.biancheng.net/view/1378.html">策略模式（策略设计模式）详解</a></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>还是在CallAdapter得到应用，Retrofit可以适配Android，Java8，RxJava,guava等平台， 不同平台有不同的特性，addCallAdapterFactory可以生成不同的平台的CallAdapter，把不同平台的特性，统一在一个接口中<br>设计模式可以参考<a href="http://c.biancheng.net/view/1361.html">适配器模式（Adapter模式）详解</a></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>Retrofit实例的create方法，使用了动态代理模式，网络请求接口，都会调用到<code>Proxy.newProxyInstance</code>的 invoke 方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> &#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Platform</span> <span class="variable">platform</span> <span class="operator">=</span> Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">          OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> <span class="title class_">OkHttpCall</span>&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用动态代理，Retrofit 还使用了静态代理模式，ExecutorCallbackCall的delegate，在发送请求和接收响应的过程中，增加了一些额外逻辑 </p><pre><code class="java">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;  checkNotNull(callback, &quot;callback == null&quot;);  delegate.enqueue(new Callback&lt;T&gt;() &#123;    @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;      callbackExecutor.execute(new Runnable() &#123;        @Override public void run() &#123;          if (delegate.isCanceled()) &#123;            // Emulate OkHttp&#39;s behavior of throwing/delivering an IOException on cancellation.            callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));          &#125; else &#123;            callback.onResponse(ExecutorCallbackCall.this, response);          &#125;        &#125;      &#125;);    &#125;    @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;      callbackExecutor.execute(new Runnable() &#123;        @Override public void run() &#123;          callback.onFailure(ExecutorCallbackCall.this, t);        &#125;      &#125;);    &#125;  &#125;);&#125;</code></pre><p>设计模式可以参考<a href="http://c.biancheng.net/view/1359.html">代理模式（代理设计模式）详解</a><br>Retrofit使用了大量的设计模式，上面只是在主流过程使用到的，其他设计模式的应用，大家可以继续深入源码去分析，总之，Refrofit框架是非常值得深入研究的框架</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://square.github.io/retrofit/">Retrofit官网</a></li><li><a href="https://blog.csdn.net/carson_ho/article/details/73732115">Android：手把手带你深入剖析 Retrofit 2.0 源码</a></li><li><a href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/index.html">拆轮子系列：拆 Retrofit</a></li><li><a href="https://www.jianshu.com/p/45cb536be2f4">Retrofit分析-漂亮的解耦套路</a></li><li><a href="https://segmentfault.com/a/1190000014823244">Retrofit2 源码解析之动态代理</a></li><li><a href="https://www.jianshu.com/p/fb8d21978e38">Retrofit分析-经典设计模式案例</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇讲解了OKHttp，本篇来介绍下它的黄金搭档Retrofit，OKHttp+Retrofit是网络框架的不二之选。同是Square出品，和OKHttp融合起来非常简单。&lt;br&gt;Retofit是一个RESTful的HTTP网络请求框架，有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于OKHttp&lt;/li&gt;
&lt;li&gt;通过注解配置网络请求参数&lt;/li&gt;
&lt;li&gt;支持同步、异步请求&lt;/li&gt;
&lt;li&gt;支持多种序列化、反序列化格式&lt;/li&gt;
&lt;li&gt;解耦彻底、模块高度封装，使用很多设计模式来实现</summary>
    
    
    
    <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
    <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
    <category term="Http" scheme="http://yeungeek.github.io/tags/Http/"/>
    
    <category term="Retrofit" scheme="http://yeungeek.github.io/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-OKHttp源码角度分析Http</title>
    <link href="http://yeungeek.github.io/2019/07/17/Network-OKHttp/"/>
    <id>http://yeungeek.github.io/2019/07/17/Network-OKHttp/</id>
    <published>2019-07-17T14:09:07.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍了网络的基础知识，这篇主要从<code>OKHttp</code>源码角度来分析Http。<br><a href="https://github.com/square/okhttp/">OKHttp</a>是一个优秀的网络请求框架，有以下特点：</p><ul><li>支持HTTP2&#x2F;SPDY</li><li>Socket自动选择最好路线，并支持自动重连</li><li>拥有自动维护的Socket连接池，减少握手次数</li><li>拥有队列线程池，轻松写并发</li><li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩）</li><li>实现基于Headers的缓存策略</li></ul><span id="more"></span><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><p>同步的Get请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line"><span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line"><span class="keyword">return</span> response.body().string();</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>异步的Get请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Call call, IOException e)</span> &#123;</span><br><span class="line">                Log.e(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;##### onFailure: &quot;</span>, e);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;DEBUG&quot;</span>, <span class="string">&quot;##### response: &quot;</span> + response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们从<code>OKHttp</code>的初始化开始分析。  </p><h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>新建一个<code>OkHttpClient</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br></pre></td></tr></table></figure><p>构造函数声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OkHttpClient</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">Builder</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder模式构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">   dispatcher = <span class="keyword">new</span> <span class="title class_">Dispatcher</span>();</span><br><span class="line">   protocols = DEFAULT_PROTOCOLS;</span><br><span class="line">   connectionSpecs = DEFAULT_CONNECTION_SPECS;</span><br><span class="line">   eventListenerFactory = EventListener.factory(EventListener.NONE);</span><br><span class="line">   proxySelector = ProxySelector.getDefault();</span><br><span class="line">   <span class="keyword">if</span> (proxySelector == <span class="literal">null</span>) &#123;</span><br><span class="line">      proxySelector = <span class="keyword">new</span> <span class="title class_">NullProxySelector</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   cookieJar = CookieJar.NO_COOKIES;</span><br><span class="line">   socketFactory = SocketFactory.getDefault();</span><br><span class="line">   hostnameVerifier = OkHostnameVerifier.INSTANCE;</span><br><span class="line">   certificatePinner = CertificatePinner.DEFAULT;</span><br><span class="line">   proxyAuthenticator = Authenticator.NONE;</span><br><span class="line">   authenticator = Authenticator.NONE;</span><br><span class="line">   connectionPool = <span class="keyword">new</span> <span class="title class_">ConnectionPool</span>();</span><br><span class="line">   dns = Dns.SYSTEM;</span><br><span class="line">   followSslRedirects = <span class="literal">true</span>;</span><br><span class="line">   followRedirects = <span class="literal">true</span>;</span><br><span class="line">   retryOnConnectionFailure = <span class="literal">true</span>;</span><br><span class="line">   callTimeout = <span class="number">0</span>;</span><br><span class="line">   connectTimeout = <span class="number">10_000</span>;</span><br><span class="line">   readTimeout = <span class="number">10_000</span>;</span><br><span class="line">   writeTimeout = <span class="number">10_000</span>;</span><br><span class="line">   pingInterval = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了很多属性，具体含义，等后面用到在具体介绍。</p><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>请求流程可分为同步和异步，大体的请求流程如下图所示：<br><img src="https://s2.ax1x.com/2019/07/23/ekVFiV.png" alt="OKHttp流程"></p><h3 id="同步请求流程"><a href="#同步请求流程" class="headerlink" title="同步请求流程"></a>同步请求流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.newCall(request).execute();</span><br></pre></td></tr></table></figure><p>newCall返回的是<code>RealCall</code>，上面代码实际上执行的是<code>RealCall</code>的execute方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> getResponseWithInterceptorChain();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>executed</code>判断Call对象是否已经执行，每个Call对象只能执行一次</li><li><code>client.dispatcher()</code>返回Dispatcher对象，任务核心调度类，是OKHttp中最重要类之一, executed方法把该线程添加到同步线程队列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">executed</span><span class="params">(RealCall call)</span> &#123;</span><br><span class="line">  runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>getResponseWithInterceptorChain()</code>获取HTTP请求结果，并会进行一系列拦截操作</li><li><code>client.dispatcher().finished(this)</code>执行完毕操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(RealCall call)</span> &#123;</span><br><span class="line">   finished(runningSyncCalls, call);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>执行完毕后，会把线程从同步线程队列中移除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> &#123;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line">    idleCallback = <span class="built_in">this</span>.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//异步方法中调用</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> promoteAndExecute();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步请求流程"><a href="#异步请求流程" class="headerlink" title="异步请求流程"></a>异步请求流程</h3><p><code>RealCall</code>的enqueue方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  transmitter.callStart();</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>executed</code>含义和同步请求一样，表示请求只能执行一次</li><li><code>client.dispatcher().enqueue(new AsyncCall(responseCallback));</code>，会生成一个<code>AsyncCall</code>对象，并把它加入到<code>readyAsyncCalls</code>线程队列中，等待执行</li></ul><p><code>AsyncCall</code>是<code>RealCall</code>的内部类，并且是<code>NamedRunnable</code>线程类，具体执行方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">signalledCallback</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  transmitter.timeoutEnter();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">    signalledCallback = <span class="literal">true</span>;</span><br><span class="line">    responseCallback.onResponse(RealCall.<span class="built_in">this</span>, response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">      <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">      Platform.get().log(INFO, <span class="string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="built_in">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getResponseWithInterceptorChain()</code>获取HTTP请求结果，并会进行一系列拦截操作</li><li><code>client.dispatcher().finished(this);</code>这个方法很重要，和同步方法中调用类似，但是异步的流程则完全不同</li></ul><p>finish方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">  call.callsPerHost().decrementAndGet();</span><br><span class="line">  finished(runningAsyncCalls, call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(Deque&lt;T&gt; calls, T call)</span> &#123;</span><br><span class="line">  Runnable idleCallback;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Call wasn&#x27;t in-flight!&quot;</span>);</span><br><span class="line">    idleCallback = <span class="built_in">this</span>.idleCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//异步方法中调用</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">isRunning</span> <span class="operator">=</span> promoteAndExecute();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">    idleCallback.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步流程中，<code>promoteAndExecute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">promoteAndExecute</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span> (!Thread.holdsLock(<span class="built_in">this</span>));</span><br><span class="line">  List&lt;AsyncCall&gt; executableCalls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="type">boolean</span> isRunning;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      <span class="type">AsyncCall</span> <span class="variable">asyncCall</span> <span class="operator">=</span> i.next();</span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">break</span>; <span class="comment">// Max capacity.</span></span><br><span class="line">      <span class="keyword">if</span> (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) <span class="keyword">continue</span>; <span class="comment">// Host max capacity.</span></span><br><span class="line">      i.remove();</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet();</span><br><span class="line">      executableCalls.add(asyncCall);</span><br><span class="line">      runningAsyncCalls.add(asyncCall);</span><br><span class="line">    &#125;</span><br><span class="line">    isRunning = runningCallsCount() &gt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class="line">    <span class="type">AsyncCall</span> <span class="variable">asyncCall</span> <span class="operator">=</span> executableCalls.get(i);</span><br><span class="line">    asyncCall.executeOn(executorService());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会遍历异步等待线程队列，并对正在执行的异步线程队列进行最大请求size，以及每个host最大请求size进行检查。<br>把异步等待线程放到正在执行线程队列中，并在等待线程队列中删除该线程，这样就把等待线程变成正在执行线程。</p><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>任务调度核心类，这个类，其实在同步和异步请求流程中已经介绍过，其最重要功能是负责请求的分发。<br>Dispatcher在OKHttpClient的Builder中被初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;</span><br><span class="line">   dispatcher = <span class="keyword">new</span> <span class="title class_">Dispatcher</span>();</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequests</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequestsPerHost</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> Runnable idleCallback;</span><br><span class="line"><span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line"><span class="comment">/** Ready async calls in the order they&#x27;ll be run. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ul><li>maxRequests：最大请求并发请求数64</li><li>maxRequestsPerHost：每个主机的最大请求数5</li><li>executorService：线程池</li><li>readyAsyncCalls：异步等待线程队列</li><li>runningAsyncCalls：正在运行的异步线程队列</li><li>runningSyncCalls：正在运行的同步线程队列</li></ul><p>线程池executorService的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title function_">executorService</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="literal">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数为0，表示线程在空闲时不会被保留，等待一段时间后停止</li><li>最大线程数Integer.MAX_VALUE，基本上就是可以创建线程无上限</li><li>keepAliveTime为60s，表示如果线程空闲时，最多只能存活60s</li></ul><p>综合上诉，在OKHttp中，设置了不设上限的线程，不保留最小线程，线程空闲时，最大存活时间为60s，保证I&#x2F;O任务中高阻塞低占用的过程，不会长时间卡在阻塞上。并通过<code>maxRequests</code>和<code>maxRequestsPerHost</code>来控制并发最大请求数。</p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>在同步和异步请求中，具体的执行过程中都会调用到<code>getResponseWithInterceptorChain</code>方法，该方法添加了一系列的拦截器，它在OKHttp整理流程中处于非常重要的地位，<br><img src="https://s2.ax1x.com/2019/07/23/ekW4US.png" alt="流程"></p><p>方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">RetryAndFollowUpInterceptor</span>(client));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line">  Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(interceptors, transmitter, <span class="literal">null</span>, <span class="number">0</span>,</span><br><span class="line">      originalRequest, <span class="built_in">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">      client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">calledNoMoreExchanges</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> chain.proceed(originalRequest);</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">      closeQuietly(response);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    calledNoMoreExchanges = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">throw</span> transmitter.noMoreExchanges(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!calledNoMoreExchanges) &#123;</span><br><span class="line">      transmitter.noMoreExchanges(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认添加的拦截器：</p><ul><li>RetryAndFollowUpInterceptor：负责失败重试以及重定向</li><li>BridgeInterceptor：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应</li><li>CacheInterceptor：负责读取缓存直接返回、更新缓存</li><li>ConnectInterceptor：负责和服务器建立连接</li><li>CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应数据</li></ul><p>这是典型的责任链模式，通过<code>Interceptor</code>，把Request转换为Response，每个<code>Interceptor</code>都有各自的责任和逻辑。   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interceptors.addAll(client.interceptors());</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>开发者可以自己定义<code>Interceptor</code>，在最开始或者发送请求前，对Request和Response进行处理。</p><h2 id="HTTP实现"><a href="#HTTP实现" class="headerlink" title="HTTP实现"></a>HTTP实现</h2><p>OKHttp中实现HTTP主要是在<code>ConnectInterceptor</code>和<code>CallServerInterceptor</code>。<br><code>ConnectInterceptor</code>建立服务器之间的连接，<code>CallServerInterceptor</code>发送请求和读取响应。<br>OKHttp请求一个URL的流程：</p><blockquote><ol><li>根据请求的URL，createAddress方法会创建一个Address，用于连接服务器</li><li>检查address和routes，是否可以从ConnectionPool获取一个连接</li><li>如果没有获取到连接，会进行下一个路由选择(<code>routeSelector</code>)，并且重新尝试从ConnectionPool获取一个连接。重试还是获取不到，就会重新创建一个连接(<code>RealConnection</code>)</li><li>获取连接后，它会与服务器建立一个直接的Socket连接、使用TLS安全通道（基于HTTP代理的HTTPS），或直接TLS连接</li><li>发送HTTP请求，并获取响应</li></ol></blockquote><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p>在请求发送前的逻辑，都是<code>ConnectInterceptor</code>中实现，<code>ConnectInterceptor</code>的intercept，这个是3.14.2版本源码，和以前多版本稍微有些区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">RealInterceptorChain</span> <span class="variable">realChain</span> <span class="operator">=</span> (RealInterceptorChain) chain;</span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> realChain.request();</span><br><span class="line">  <span class="type">Transmitter</span> <span class="variable">transmitter</span> <span class="operator">=</span> realChain.transmitter();</span><br><span class="line">  <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">doExtensiveHealthChecks</span> <span class="operator">=</span> !request.method().equals(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">  <span class="type">Exchange</span> <span class="variable">exchange</span> <span class="operator">=</span> transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line">  <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Exchange</code>可以传输HTTP请求和响应，并管理连接和事件。<br>newExchange方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns a new exchange to carry a new request and response. */</span></span><br><span class="line">Exchange <span class="title function_">newExchange</span><span class="params">(Interceptor.Chain chain, <span class="type">boolean</span> doExtensiveHealthChecks)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (noMoreExchanges) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;released&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exchange != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;cannot make a new request because the previous response &quot;</span></span><br><span class="line">          + <span class="string">&quot;is still open: please call response.close()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">ExchangeCodec</span> <span class="variable">codec</span> <span class="operator">=</span> exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line">  <span class="type">Exchange</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exchange</span>(<span class="built_in">this</span>, call, eventListener, exchangeFinder, codec);</span><br><span class="line">  ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find方法会最终执行<code>ExchangeFinder</code>的<code>findConnection</code>方法，在发送HTTP请求之前的逻辑，都是这个方法中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class="line"><span class="comment"> * then the pool, finally building a new connection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RealConnection <span class="title function_">findConnection</span><span class="params">(<span class="type">int</span> connectTimeout, <span class="type">int</span> readTimeout, <span class="type">int</span> writeTimeout,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> pingIntervalMillis, <span class="type">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">foundPooledConnection</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">RealConnection</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">Route</span> <span class="variable">selectedRoute</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  RealConnection releasedConnection;</span><br><span class="line">  Socket toClose;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//2.根据 Address 从连接池获取连接</span></span><br><span class="line">      <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="literal">null</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">        foundPooledConnection = <span class="literal">true</span>;</span><br><span class="line">        result = transmitter.connection;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="literal">null</span>) &#123;</span><br><span class="line">        selectedRoute = nextRouteToTry;</span><br><span class="line">        nextRouteToTry = <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">        selectedRoute = transmitter.connection.route();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 3. 重新选择路由</span></span><br><span class="line">  <span class="comment">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">newRouteSelection</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span> &amp;&amp; (routeSelection == <span class="literal">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">    newRouteSelection = <span class="literal">true</span>;</span><br><span class="line">    routeSelection = routeSelector.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;Route&gt; routes = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">      <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">      <span class="comment">// the pool. This could match due to connection coalescing.</span></span><br><span class="line">      routes = routeSelection.getAll();</span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(</span><br><span class="line">          address, transmitter, routes, <span class="literal">false</span>)) &#123;</span><br><span class="line">        foundPooledConnection = <span class="literal">true</span>;</span><br><span class="line">        result = transmitter.connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">      <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span>) &#123;</span><br><span class="line">        selectedRoute = routeSelection.next();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 3. 重新选择路由，创建新的 `RealConnection`</span></span><br><span class="line">      <span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class="line">      <span class="comment">// for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do.</span></span><br><span class="line">      result = <span class="keyword">new</span> <span class="title class_">RealConnection</span>(connectionPool, selectedRoute);</span><br><span class="line">      connectingConnection = result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 4. 进行 Socket 连接</span></span><br><span class="line">  <span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class="line">  result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled, call, eventListener);</span><br><span class="line">  connectionPool.routeDatabase.connected(result.route());</span><br><span class="line"></span><br><span class="line">  <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    connectingConnection = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Last attempt at connection coalescing, which only occurs if we attempted multiple</span></span><br><span class="line">    <span class="comment">// concurrent connections to the same host.</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="literal">true</span>)) &#123;</span><br><span class="line">      <span class="comment">// We lost the race! Close the connection we created and return the pooled connection.</span></span><br><span class="line">      result.noNewExchanges = <span class="literal">true</span>;</span><br><span class="line">      socket = result.socket();</span><br><span class="line">      result = transmitter.connection;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//把连接放入连接池中</span></span><br><span class="line">      connectionPool.put(result);</span><br><span class="line">      transmitter.acquireConnectionNoEvents(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTTP 的连接主要是result.connect方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> connectTimeout, <span class="type">int</span> readTimeout, <span class="type">int</span> writeTimeout,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> pingIntervalMillis, <span class="type">boolean</span> connectionRetryEnabled, Call call,</span></span><br><span class="line"><span class="params">      EventListener eventListener)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (protocol != <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;already connected&quot;</span>);</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">          <span class="keyword">if</span> (rawSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);</span><br><span class="line">        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 for 循环中检查这个连接是否是隧道协议连接。<br><code>connectSocket</code>连接socket，<code>establishProtocol</code>根据HTTP协议版本进行连接处理。<br>重点分析下<code>connectSocket</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connectSocket</span><span class="params">(<span class="type">int</span> connectTimeout, <span class="type">int</span> readTimeout, Call call,</span></span><br><span class="line"><span class="params">   EventListener eventListener)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//连接 socket</span></span><br><span class="line">      Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">      <span class="type">ConnectException</span> <span class="variable">ce</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectException</span>(<span class="string">&quot;Failed to connect to &quot;</span> + route.socketAddress());</span><br><span class="line">      ce.initCause(e);</span><br><span class="line">      <span class="keyword">throw</span> ce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">      sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">      <span class="keyword">if</span> (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(npe);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Okio，封装了Socket的读写操作， 建立连接后，就可以发送请求和获取响应。</p><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>CallServerInterceptor的intercept()方法里负责发送请求和获取响应。<br>具体操作都是通过Exchange来执行，Exchange通过各个功能模块再进行分发处理。<br>通过 Socket 发送 HTTP消息，会按照以下声明周期：</p><ul><li>writeRequestHeaders发送 request Headers</li><li>如果有 request body，就通过 Sink 发送request body，然后关闭 Sink</li><li>readResponseHeaders获取 response Headers</li><li>通过Source读取 response body，然后关闭 Source</li></ul><h4 id="writeRequestHeaders"><a href="#writeRequestHeaders" class="headerlink" title="writeRequestHeaders"></a>writeRequestHeaders</h4><p>Exchange 调用writeRequestHeaders方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeRequestHeaders</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      eventListener.requestHeadersStart(call);</span><br><span class="line">      codec.writeRequestHeaders(request);</span><br><span class="line">      eventListener.requestHeadersEnd(call, request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      eventListener.requestFailed(call, e);</span><br><span class="line">      trackFailure(e);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际执行的方法codec实现类<code>Http1ExchangeCodec</code>(前面根据HTTP协议版本选择)的writeRequest方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns bytes of a request header for sending on an HTTP transport. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeRequest</span><span class="params">(Headers headers, String requestLine)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">if</span> (state != STATE_IDLE) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;state: &quot;</span> + state);</span><br><span class="line">  sink.writeUtf8(requestLine).writeUtf8(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">    sink.writeUtf8(headers.name(i))</span><br><span class="line">        .writeUtf8(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        .writeUtf8(headers.value(i))</span><br><span class="line">        .writeUtf8(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sink.writeUtf8(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">  state = STATE_OPEN_REQUEST_BODY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="readResponseHeaders"><a href="#readResponseHeaders" class="headerlink" title="readResponseHeaders"></a>readResponseHeaders</h4><p>读取响应头部，<code>Http1ExchangeCodec</code>的readResponseHeaders方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Response.Builder <span class="title function_">readResponseHeaders</span><span class="params">(<span class="type">boolean</span> expectContinue)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">if</span> (state != STATE_OPEN_REQUEST_BODY &amp;&amp; state != STATE_READ_RESPONSE_HEADERS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;state: &quot;</span> + state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">StatusLine</span> <span class="variable">statusLine</span> <span class="operator">=</span> StatusLine.parse(readHeaderLine());</span><br><span class="line">    Response.<span class="type">Builder</span> <span class="variable">responseBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Response</span>.Builder()</span><br><span class="line">        .protocol(statusLine.protocol)</span><br><span class="line">        .code(statusLine.code)</span><br><span class="line">        .message(statusLine.message)</span><br><span class="line">        .headers(readHeaders());</span><br><span class="line">    <span class="keyword">if</span> (expectContinue &amp;&amp; statusLine.code == HTTP_CONTINUE) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusLine.code == HTTP_CONTINUE) &#123;</span><br><span class="line">      state = STATE_READ_RESPONSE_HEADERS;</span><br><span class="line">      <span class="keyword">return</span> responseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    state = STATE_OPEN_RESPONSE_BODY;</span><br><span class="line">    <span class="keyword">return</span> responseBuilder;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (EOFException e) &#123;</span><br><span class="line">    <span class="comment">// Provide more context if the server ends the stream before sending a response.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (realConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">      address = realConnection.route().address().url().redact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;unexpected end of stream on &quot;</span></span><br><span class="line">        + address, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatusLine解析HTTP版本信息，<code>readHeaders()</code>读取response header 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Reads headers or trailers. */</span></span><br><span class="line"><span class="keyword">private</span> Headers <span class="title function_">readHeaders</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  Headers.<span class="type">Builder</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Headers</span>.Builder();</span><br><span class="line">  <span class="comment">// parse the result headers until the first blank line</span></span><br><span class="line">  <span class="keyword">for</span> (String line; (line = readHeaderLine()).length() != <span class="number">0</span>; ) &#123;</span><br><span class="line">    Internal.instance.addLenient(headers, line);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> headers.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="response-body"><a href="#response-body" class="headerlink" title="response body"></a>response body</h4><p>解析 response body 内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">  <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">  response = response.newBuilder()</span><br><span class="line">      .body(Util.EMPTY_RESPONSE)</span><br><span class="line">      .build();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  response = response.newBuilder()</span><br><span class="line">      .body(exchange.openResponseBody(response))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不是websocket，调用Exchange的openResponseBody方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ResponseBody <span class="title function_">openResponseBody</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    eventListener.responseBodyStart(call);</span><br><span class="line">    <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span> response.header(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">contentLength</span> <span class="operator">=</span> codec.reportedContentLength(response);</span><br><span class="line">    <span class="type">Source</span> <span class="variable">rawSource</span> <span class="operator">=</span> codec.openResponseBodySource(response);</span><br><span class="line">    <span class="type">ResponseBodySource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseBodySource</span>(rawSource, contentLength);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RealResponseBody</span>(contentType, contentLength, Okio.buffer(source));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    eventListener.responseFailed(call, e);</span><br><span class="line">    trackFailure(e);</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取返回的 body，通过 Source 转换为需要的数据类型，ResponseBody提供的 string()，转换为 String 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">string</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">try</span> (<span class="type">BufferedSource</span> <span class="variable">source</span> <span class="operator">=</span> source()) &#123;</span><br><span class="line">    <span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Util.bomAwareCharset(source, charset());</span><br><span class="line">    <span class="keyword">return</span> source.readString(charset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述的分析，OKHttp是通过Okio操作Socket实现了Http协议，凭借高效的性能，Android系统从4.4版本开始，HTTP的实现已经替换为OKHttp。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/82f74db14a18">OKHttp源码解析(一)–初阶</a></li><li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html">拆轮子系列：拆 OkHttp</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面介绍了网络的基础知识，这篇主要从&lt;code&gt;OKHttp&lt;/code&gt;源码角度来分析Http。&lt;br&gt;&lt;a href=&quot;https://github.com/square/okhttp/&quot;&gt;OKHttp&lt;/a&gt;是一个优秀的网络请求框架，有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持HTTP2&amp;#x2F;SPDY&lt;/li&gt;
&lt;li&gt;Socket自动选择最好路线，并支持自动重连&lt;/li&gt;
&lt;li&gt;拥有自动维护的Socket连接池，减少握手次数&lt;/li&gt;
&lt;li&gt;拥有队列线程池，轻松写并发&lt;/li&gt;
&lt;li&gt;拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩）&lt;/li&gt;
&lt;li&gt;实现基于Headers的缓存策略&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
    <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
    <category term="Http" scheme="http://yeungeek.github.io/tags/Http/"/>
    
    <category term="OKHttp" scheme="http://yeungeek.github.io/tags/OKHttp/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-Cookie，Session，Token</title>
    <link href="http://yeungeek.github.io/2019/07/15/Network-Cookie-Session-Token/"/>
    <id>http://yeungeek.github.io/2019/07/15/Network-Cookie-Session-Token/</id>
    <published>2019-07-15T23:04:35.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议是无状态的，每次HTTP请求响应后，就会断开这次连接。如果客户端再次发送请求，服务端也不能识别出这个客户端是不是上次请求过的客户端，HTTP协议不能进行会话跟踪。而Cookie，Session，Token正是为了解决HTTP协议无状态问题。</p><span id="more"></span><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>Cookie机制是在客户端实现，采用客户端保持状态的方案。<br>Cookie由服务端生成，发送给客户端(Set-Cookie)，客户端请求的时候会带上这个Cookie。<br>请求流程：<br><img src="https://s2.ax1x.com/2019/07/16/ZH7XAf.png" alt="请求流程"><br>Cookie字段：名字、值、过期时间、路径和域。路径与域一起构成Cookie的作用范围。<br>通过Chrome的开发者工具中看到，在github.com上保存在客户端的Cookie信息。<br><img src="https://s2.ax1x.com/2019/07/17/ZqcVOS.png" alt="ZqcVOS.png"></p><ul><li>Name：名字</li><li>Value：值</li><li>Domain：域</li><li>Path：路径</li><li>Expaires&#x2F;Max-Age：过期时间</li></ul><p>上图中<code>logged_in</code>和<code>user_session</code>两个Cookie值表示登录github.com后保存下来的登录状态和Session。</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session是在服务端实现，当客户端请求服务端时，服务端会检查请求中是否包含Session标识(Session id)，</p><ul><li>如果没有,那么服务端就生成一个随机的Session以及和它匹配的Session id,并将Session id返回给客户端。</li><li>如果有,那么服务器就在存储中根据Session id 查找到对应的Session。</li></ul><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>Token也称作令牌，由uid+time+sign[+固定参数]组成:</p><ul><li>uid：用户唯一身份标识</li><li>time：当前时间的时间戳</li><li>sign：签名, 使用 hash&#x2F;encrypt 压缩成定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器</li></ul><p>以下几点特性会让你在程序中使用基于Token的身份验证：</p><ul><li>无状态、可扩展</li><li>支持移动设备</li><li>跨程序调用</li><li>安全</li></ul><p>Token是有客户端来保存，用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。而认证的具体流程如下：</p><blockquote><p>客户端使用用户名跟密码请求登录<br>服务端收到请求，去验证用户名与密码<br>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端<br>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里<br>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token<br>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据  </p></blockquote><h2 id="第三方授权登录"><a href="#第三方授权登录" class="headerlink" title="第三方授权登录"></a>第三方授权登录</h2><p>这是Token的一种应用场景，使用OAuth实现。<br>OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。<br>OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。<br>我们看下github的授权流程：<br><img src="https://s2.ax1x.com/2019/07/17/Zq5gJg.png" alt="Zq5gJg.png"></p><blockquote><p>图片来源：<a href="https://juejin.im/post/5c7bd93751882545194f88cb">github 授权登录教程与如何设计第三方授权登录的用户表</a></p></blockquote><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><table><thead><tr><th align="left">维度</th><th align="left">Cookie</th><th align="left">Sesson</th></tr></thead><tbody><tr><td align="left">存放位置</td><td align="left">客户端</td><td align="left">服务端</td></tr><tr><td align="left">存取方式</td><td align="left">只能保管ASCII字符串</td><td align="left">任何类型的数据</td></tr><tr><td align="left">安全性</td><td align="left">对客户端是可见的，<br>客户端的一些程序可能会窥探、<br>复制以至修正Cookie中的内容</td><td align="left">对客户端是透明的，<br>不存在敏感信息泄露的风险</td></tr><tr><td align="left">有效期</td><td align="left">可以保持很长时间不过期</td><td align="left">依赖于JSESSIONID的Cookie，<br>默许过期时间为–1，<br>只需关闭了浏览器，该Session就会失效</td></tr><tr><td align="left">跨域支持</td><td align="left">支持跨域名访问</td><td align="left">仅在它所在的域名内有效</td></tr></tbody></table><h2 id="Token和Session"><a href="#Token和Session" class="headerlink" title="Token和Session"></a>Token和Session</h2><p>作为身份认证Token安全性比Session好。<br>Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。<br>Token,如果指的是OAuth Token 或类似的机制的话，提供的是<code>认证</code>和<code>授权</code> ，认证是针对用户，授权是针对App。 </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/bd1be47a16c1">Cookie、Session、Token那点事儿</a></li><li><a href="https://www.cnblogs.com/moyand/p/9047978.html">彻底理解cookie，session，token</a></li><li><a href="https://juejin.im/post/5b32f82a518825749e4a218b">精读《图解HTTP》</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTTP协议是无状态的，每次HTTP请求响应后，就会断开这次连接。如果客户端再次发送请求，服务端也不能识别出这个客户端是不是上次请求过的客户端，HTTP协议不能进行会话跟踪。而Cookie，Session，Token正是为了解决HTTP协议无状态问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
    <category term="Session" scheme="http://yeungeek.github.io/tags/Session/"/>
    
    <category term="Cookie" scheme="http://yeungeek.github.io/tags/Cookie/"/>
    
    <category term="Token" scheme="http://yeungeek.github.io/tags/Token/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-HTTP/HTTPS</title>
    <link href="http://yeungeek.github.io/2019/07/12/Network-Http/"/>
    <id>http://yeungeek.github.io/2019/07/12/Network-Http/</id>
    <published>2019-07-12T10:09:56.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,在TCP&#x2F;IP体系中属于最高层(应用层)是用于从万维网服务器传输超文本到本地浏览器的传送协议。<br>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。<span id="more"></span><br>这是最基本的HTTP工作原理，如图所示:<br><img src="https://s2.ax1x.com/2019/07/12/ZfgnTU.jpg" alt="C/S架构"></p><h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>HTTP属于应用层，应用层传输的数据单位是报文。<br>HTTP报文分为请求报文和响应报文。  </p><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p><img src="https://s2.ax1x.com/2019/07/13/Zhv4AO.jpg" alt="请求报文"><br>HTTP请求报文由以下4个部分组成:</p><ul><li>请求行：请求类型,要访问的资源以及所使用的HTTP版本。</li><li>请求头部：服务器要使用的附加信息。</li><li>空行：请求头部后面的空行是必须的</li><li>请求包体：可以添加任意的其他数据</li></ul><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行组成：请求方法，请求URL，协议版本。</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><table><thead><tr><th align="left">方法</th><th align="left">作用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">获取资源</td><td align="left">用来请求访问已被URI标识的</td></tr><tr><td align="left">POST</td><td align="left">传输实体主体</td><td align="left">POST主要用来传输数据，而GET主要用来获取资源</td></tr><tr><td align="left">HEAD</td><td align="left">获取报文首部</td><td align="left">和GET方法类似，但是不返回报文实体主体部分</td></tr><tr><td align="left">PUT</td><td align="left">上传文件</td><td align="left">用来传输文件，由于自身不带验证机制，任何人都可以上传文件</td></tr><tr><td align="left">DELETE</td><td align="left">删除文件</td><td align="left">与PUT功能相反，并且同样不带验证机制</td></tr><tr><td align="left">OPTIONS</td><td align="left">查询支持的方法</td><td align="left">用来查询针对请求URI请求的资源支持的方法</td></tr><tr><td align="left">TRACE</td><td align="left">追踪路径</td><td align="left">服务器会将通信路径返回给客户端</td></tr><tr><td align="left">CONNECT</td><td align="left">要求用隧道协议连接代理</td><td align="left">使用 SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输</td></tr></tbody></table><h4 id="请求URL"><a href="#请求URL" class="headerlink" title="请求URL"></a>请求URL</h4><p>URL(Uniform Resource Locator)统一资源定位符，表示资源的地点(互联网上的地址)。<br>URI(Uniform Resource Identifier)统一资源标识符，用字符串标识某一互联网资源，URL是URI的子集。  </p><h4 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h4><ul><li>HTTP&#x2F;1.0：HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用</li><li>HTTP&#x2F;1.1：HTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本</li><li>HTTP&#x2F;2.0：HTTP 2.0是下一代HTTP协议，目前应用还非常少</li></ul><h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><p>请求头部由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。<br>有4种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段，<a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP?id=%e5%9b%9b%e3%80%81http-%e9%a6%96%e9%83%a8">所有完整首部</a><br>这里我们先了解下常用的请求首部。   </p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Accept</td><td align="left">用户代理可处理的媒体类型</td></tr><tr><td align="left">Accept-Encoding</td><td align="left">优先的内容编码<br/>Accept-Encoding: gzip, deflate, br</td></tr><tr><td align="left">Authorization</td><td align="left">Web 认证信息</td></tr><tr><td align="left">Cache-Control</td><td align="left">控制缓存的行为</td></tr><tr><td align="left">Connection</td><td align="left">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="left">Content-Encoding</td><td align="left">实体主体适用的编码方式</td></tr><tr><td align="left">Content-Type</td><td align="left">实体主体的媒体类型</td></tr><tr><td align="left">Content-Length</td><td align="left">实体主体的大小</td></tr><tr><td align="left">Host</td><td align="left">请求资源所在服务器</td></tr><tr><td align="left">If-Modified-Since</td><td align="left">服务器上次返回的<code>Last-Modified</code>日期，如果在这个日期之后，<br/>请求的资源都没有更新过，则返回304 Not Modified响应</td></tr><tr><td align="left">If-None-Match</td><td align="left">比较实体标记，值为上一次返回的ETag，<br/>一般会和<code>If-Modified-Since</code>一起返回</td></tr><tr><td align="left">Referer</td><td align="left">对请求中URI的原始获取方</td></tr><tr><td align="left">User-Agent</td><td align="left">HTTP 客户端程序的信息</td></tr><tr><td align="left">Cookie</td><td align="left">保存状态信息</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">指定报文主体的传输编码方式</td></tr></tbody></table><h3 id="请求包体"><a href="#请求包体" class="headerlink" title="请求包体"></a>请求包体</h3><p>请求包体不在 GET 方法中使用，而是在POST 方法中使用。<br>HTTP请求的请求体有三种不同的形式：</p><ul><li>任意类型：服务器不会解析请求体，请求体的处理需要自己解析，比如JSON</li><li>键值对(application&#x2F;x-www-form-urlencoded)：最常见的 POST 提交数据的方式，表单模式</li><li>文件分割：请求体被分成为多个部分，文件上传时会被使用</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用抓包工具或者Chrome来查看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /getconfig HTTP/<span class="number">1.1</span></span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Dalvik/<span class="number">2.1</span><span class="number">.0</span> (Linux; U; Android <span class="number">9</span>; Redmi Note <span class="number">7</span> MIUI/V10<span class="number">.3</span><span class="number">.2</span><span class="number">.0</span>.PFGCNXM)</span><br><span class="line">Host: data.mistat.xiaomi.com</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">205</span></span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">app_id=<span class="number">1000274</span>&amp;app_version=<span class="number">10.8</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><ul><li>请求行：显示Post请求，协议版本为HTTP&#x2F;1.1</li><li>请求头部：<code>Content-Type</code>,<code>User-Agent</code>,<code>Host</code>,<code>Accept-Encoding</code>,<code>Content-Length</code>,<code>Connection</code></li><li>请求体：Content-Type声明为键值对</li></ul><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p><img src="https://s2.ax1x.com/2019/07/13/Zhv5ND.jpg" alt="响应报文"><br>HTTP 响应报文由状态行、响应头部、空行和响应包体4个部分组成。</p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>状态行由HTTP协议版本字段、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;<br>协议版本和请求中的对应，状态码和描述会一一对应。</p><h4 id="状态码、描述"><a href="#状态码、描述" class="headerlink" title="状态码、描述"></a>状态码、描述</h4><p>状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类：</p><ul><li>1xx：Informational（信息性状态码），接收的请求正在处理;</li><li>2xx：Success（成功状态码），请求正常处理完毕;</li><li>3xx：Redirection（重定向状态码），需要进行附加操作以完成请求;</li><li>4xx：Client Error（客户端错误状态码），服务器无法处理请求;</li><li>5xx：Server Error（服务器错误状态码），服务器处理请求出错;</li></ul><p>常用的一些状态码和描述</p><h5 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">100 Continue</td><td align="left">表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</td></tr></tbody></table><h5 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">200 OK</td><td align="left">请求成功</td></tr><tr><td align="left">204 No Content</td><td align="left">请求已经成功处理，但是返回的响应报文不包含实体的主体部分</td></tr><tr><td align="left">206 Partial Content</td><td align="left">表示客户端进行了范围请求，<br>响应报文包含由Content-Range指定范围的实体内容</td></tr></tbody></table><h5 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">301 Moved Permanently</td><td align="left">永久性重定向</td></tr><tr><td align="left">302 Found</td><td align="left">临时性重定向</td></tr><tr><td align="left">304 Not Modified</td><td align="left">如果请求报文首部包含一些条件，If-Match，If-Range, <br/>If-Modified-Since，If-None-Match，，If-Unmodified-Since。<br/>如果不满足条件，则服务器会返回 304 状态码</td></tr><tr><td align="left">307 Temporary Redirect</td><td align="left">临时重定向，与 302 的含义类似，<br/>但是307要求浏览器不会把重定向请求的POST方法改成GET方法</td></tr></tbody></table><h5 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">400 Bad Request</td><td align="left">请求报文中存在语法错误</td></tr><tr><td align="left">401 Unauthorized</td><td align="left">请求需要验证用户</td></tr><tr><td align="left">403 Forbidden</td><td align="left">访问权限问题</td></tr><tr><td align="left">404 Not Found</td><td align="left"></td></tr></tbody></table><h5 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h5><table><thead><tr><th align="left">状态码、描述</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">500 Internal Server Error</td><td align="left">服务器正在执行请求时发生错误</td></tr><tr><td align="left">503 Service Unavailable</td><td align="left">服务器正在执行请求时发生错误</td></tr></tbody></table><h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><p>和请求头部一样，由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。<br>常用的请求首部  </p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Cache-Control</td><td align="left">控制缓存的行为</td></tr><tr><td align="left">Connection</td><td align="left">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">指定报文主体的传输编码方式</td></tr><tr><td align="left">Content-Encoding</td><td align="left">实体主体适用的编码方式</td></tr><tr><td align="left">Content-Type</td><td align="left">实体主体的媒体类型</td></tr><tr><td align="left">Content-Length</td><td align="left">实体主体的大小</td></tr><tr><td align="left">Expires</td><td align="left">实体主体过期的日期时间</td></tr><tr><td align="left">ETag</td><td align="left">资源的匹配信息，和<code>If-Nome-Match</code>对应</td></tr><tr><td align="left">Date</td><td align="left">服务端</td></tr><tr><td align="left">Location</td><td align="left">令客户端重定向至指定 URI</td></tr><tr><td align="left">Server</td><td align="left">HTTP 服务器的安装信息</td></tr><tr><td align="left">Last-Modified</td><td align="left">资源的最后修改日期时间</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置Cookie，客户端得到响应报文后把 Cookie 内容保存到浏览器中</td></tr></tbody></table><p>其他更详细的首部信息，可以参考<a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP?id=%e5%9b%9b%e3%80%81http-%e9%a6%96%e9%83%a8">这里</a>   </p><h3 id="响应包体"><a href="#响应包体" class="headerlink" title="响应包体"></a>响应包体</h3><p>服务器返回给客户端的文本信息。<br>和请求包体的分类一样。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date: Sat, <span class="number">13</span> Jul <span class="number">2019</span> 08:<span class="number">40</span>:<span class="number">52</span> GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-<span class="number">8</span></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;errorCode&quot;</span>:-<span class="number">2</span>,<span class="string">&quot;reason&quot;</span>:<span class="string">&quot;no changing&quot;</span>,<span class="string">&quot;result&quot;</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>响应行：返回响应码200 Ok，表示服务端返回数据成功</li><li>响应头部：Content-Type设置返回的类型为JSON格式</li><li>响应包体：返回具体JSON数据</li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。<br>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）<br><img src="https://s2.ax1x.com/2019/07/13/Z42xPO.jpg" alt="HTTPS"></p><h2 id="与HTTP区别"><a href="#与HTTP区别" class="headerlink" title="与HTTP区别"></a>与HTTP区别</h2><table><thead><tr><th align="left">协议</th><th align="left">原理</th><th align="left">数据格式</th><th align="left">传输速度</th><th align="left">端口</th></tr></thead><tbody><tr><td align="left">HTTP</td><td align="left">应用层</td><td align="left">明文传输</td><td align="left">三次握手，传输三个包</td><td align="left">80</td></tr><tr><td align="left">HTTPS</td><td align="left">传输层</td><td align="left">SSL加密</td><td align="left">三次握手基础上增加ssl握手(9个包)，<br>传输12个包</td><td align="left">443</td></tr></tbody></table><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h1 id="HTTP框架"><a href="#HTTP框架" class="headerlink" title="HTTP框架"></a>HTTP框架</h1><h2 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a><a href="https://github.com/google/volley">Volley</a></h2><p>Volley是Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持 HttpClient、HttpUrlConnection，甚至支持OKHttp。</p><h2 id="OKHttp"><a href="#OKHttp" class="headerlink" title="OKHttp"></a><a href="https://github.com/square/okhttp/">OKHttp</a></h2><p>OKHttp是Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库，所以它的职责跟 HttpUrlConnection 是一样的，支持 spdy、http 2.0、websocket ，支持同步、异步。<br>已被谷歌加入到Android的源码中。</p><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a><a href="https://github.com/square/retrofit">Retrofit</a></h2><p>Retrofit是Square公司出品的默认基于OKHttp 封装的一套 RESTful 网络请求框架</p><p>后续文章会从OKHttp、Retrofit角度来分析Http。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/HTTP">Http</a></li><li><a href="https://juejin.im/post/5c98306bf265da60ed6eedbc">这是一份全面&amp; 详细 HTTP协议 学习攻略</a></li><li><a href="https://juejin.im/post/5b32f82a518825749e4a218b">精读《图解HTTP》</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP 协议入门</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,在TCP&amp;#x2F;IP体系中属于最高层(应用层)是用于从万维网服务器传输超文本到本地浏览器的传送协议。&lt;br&gt;HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</summary>
    
    
    
    <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
    <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
    <category term="Http" scheme="http://yeungeek.github.io/tags/Http/"/>
    
    <category term="Https" scheme="http://yeungeek.github.io/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-Socket</title>
    <link href="http://yeungeek.github.io/2019/06/26/Network-Socket/"/>
    <id>http://yeungeek.github.io/2019/06/26/Network-Socket/</id>
    <published>2019-06-26T20:18:07.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<p>Socket在Android网络编程中，有着非常重要的作用。</p><h1 id="Socket基本概念"><a href="#Socket基本概念" class="headerlink" title="Socket基本概念"></a>Socket基本概念</h1><p>即套接字，是应用层 与 TCP&#x2F;IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP &#x2F; IP协议族 的编程接口（API）。<br>从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><span id="more"></span><p>借用下网上结构图:<br><img src="https://s2.ax1x.com/2019/07/10/Z6bGHx.png" alt="Socket"><br>IP地址和端口号组成了Socket，都是成对出现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket =&#123;(IP地址<span class="number">1</span>:PORT端口号)，(IP地址<span class="number">2</span>:PORT端口号)&#125;</span><br></pre></td></tr></table></figure><p>单独的Socke是没用任何作用的,基于一定的协议（TCP或者UDP）下的Socket编程才能进行数据传输。</p><h1 id="Socket工作流程"><a href="#Socket工作流程" class="headerlink" title="Socket工作流程"></a>Socket工作流程</h1><p><img src="https://s2.ax1x.com/2019/07/11/ZR3W2n.jpg" alt="Socket工作流程"><br>服务端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。<br>客户端初始化一个socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务端的连接就建立了。<br>客户端发送数据请求，服务端接收请求并处理请求，然后把回应数据发给客户端，客户端读取数据，最后关闭数据，一次交互结束。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Socket使用类型有两种：</p><ul><li>基于TCP协议，流套接字，采用流的方式提供可靠的字节流服务</li><li>基于UDP协议，数据报套接字，采用数据报文提供数据打包发送的服务</li></ul><h1 id="基于TCP的Socket编程"><a href="#基于TCP的Socket编程" class="headerlink" title="基于TCP的Socket编程"></a>基于TCP的Socket编程</h1><h2 id="主要API"><a href="#主要API" class="headerlink" title="主要API"></a>主要API</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Socket</span><span class="params">(String host, <span class="type">int</span> port)</span></span><br><span class="line">        <span class="keyword">throws</span> UnknownHostException, IOException</span><br></pre></td></tr></table></figure><p>创建流套接字并将其连接到指定主机上的指定端口号。</p><ul><li><code>host</code>: 主机地址</li><li><code>port</code>: 端口号</li></ul><h4 id="getInputStream"><a href="#getInputStream" class="headerlink" title="getInputStream"></a>getInputStream</h4><p>返回Socket的输入流，用户接受数据。</p><h4 id="getOutputStream"><a href="#getOutputStream" class="headerlink" title="getOutputStream"></a>getOutputStream</h4><p>返回Socket的输出流，用于发送数据。</p><h3 id="ServerSocket"><a href="#ServerSocket" class="headerlink" title="ServerSocket"></a>ServerSocket</h3><p>Socket的服务端实现</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ServerSocket</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure><p>创建服务端Socket，绑定到指定端口。</p><ul><li><code>port</code>: 端口号</li></ul><h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Socket <span class="title function_">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure><p>监听并接受到此套接字的连接。该方法将阻塞，直到建立连接。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 创建ServerSocket</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//2. 监听</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;server start listen&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span> ((content = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;server receiver: &quot;</span> + sb.toString());</span><br><span class="line"></span><br><span class="line">        socket.shutdownInput();</span><br><span class="line"></span><br><span class="line">        br.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单的Socket服务端，接收到客户端的数据，就会关闭当前的连接。这个示例只是展示了一个完整的流程。<br>如果需要复杂的服务端实现，可以使用Netty、Mina或者其他Socket框架。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建客户端</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;your ip&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"><span class="comment">//2. 输出流</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">//3. 发送数据</span></span><br><span class="line">os.write(<span class="string">&quot;Hello world&quot;</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;send message&quot;</span>);</span><br><span class="line">os.flush();</span><br><span class="line"></span><br><span class="line">socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">os.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>客户端就是连接后，发送了一份数据，就关闭连接了。<br>这样就实现了客户端和服务端的通信。</p><h1 id="基于UDP的Socket编程"><a href="#基于UDP的Socket编程" class="headerlink" title="基于UDP的Socket编程"></a>基于UDP的Socket编程</h1><h2 id="主要API-1"><a href="#主要API-1" class="headerlink" title="主要API"></a>主要API</h2><h3 id="DatagramPacket"><a href="#DatagramPacket" class="headerlink" title="DatagramPacket"></a>DatagramPacket</h3><p>用来包装接收和发送的数据。</p><ul><li>构造接收数据包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DatagramPacket</span><span class="params">(<span class="type">byte</span>[] buf,<span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure><p>用来接收长度为 length 的数据包。</p><ul><li>构造发送数据包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> length,SocketAddress address)</span><br><span class="line">DatagramPacket(<span class="type">byte</span>[] buf, <span class="type">int</span> length, InetAddress address, <span class="type">int</span> port)</span><br></pre></td></tr></table></figure><p>用来将长度为 length 的包发送到指定主机上的指定端口号。</p><h3 id="DatagramSocket"><a href="#DatagramSocket" class="headerlink" title="DatagramSocket"></a>DatagramSocket</h3><p>用来发送和接收数据报包的套接字。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建数据报套接字并将其绑定到本地主机上的指定端口</span></span><br><span class="line">DatagramSocket(<span class="type">int</span> port)  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据报套接字，将其绑定到指定的本地地址</span></span><br><span class="line">DatagramSocket(<span class="type">int</span> port, InetAddress laddr)     </span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">send</span><span class="params">(DatagramPacket p)</span></span><br></pre></td></tr></table></figure><p>DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号</p><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(DatagramPacket p)</span> </span><br></pre></td></tr></table></figure><p>当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// receive</span></span><br><span class="line">        <span class="comment">// 1.create</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        <span class="comment">// 2.create udp socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">// 3. receive start</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line">        <span class="comment">// 4. receive data</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sever: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, buf.length));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// send</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, </span><br><span class="line">                        packet.getAddress(), packet.getPort());</span><br><span class="line">        socket.send(p);</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;your ip&quot;</span>);</span><br><span class="line"><span class="comment">//1.create packet</span></span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length, address, <span class="number">8888</span>);</span><br><span class="line"><span class="comment">//2.create socket</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"><span class="comment">//3.send data</span></span><br><span class="line">socket.send(packet);</span><br><span class="line"><span class="comment">// receive</span></span><br><span class="line"><span class="comment">//1.create packet</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">receiverPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line">socket.receive(receiverPacket);</span><br><span class="line">System.out.println(<span class="string">&quot;client: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, bytes.length));</span><br><span class="line"></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><p>客户端和服务端的实现，都比较简单。</p><p>关于Socket编程，就介绍好了，这篇只是开了头，最主要的还是得去项目中实践。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/089fb79e308b">Android：这是一份很详细的Socket使用攻略</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/network/Socket-Programming-Basic.html">Scoket编程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Socket在Android网络编程中，有着非常重要的作用。&lt;/p&gt;
&lt;h1 id=&quot;Socket基本概念&quot;&gt;&lt;a href=&quot;#Socket基本概念&quot; class=&quot;headerlink&quot; title=&quot;Socket基本概念&quot;&gt;&lt;/a&gt;Socket基本概念&lt;/h1&gt;&lt;p&gt;即套接字，是应用层 与 TCP&amp;#x2F;IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP &amp;#x2F; IP协议族 的编程接口（API）。&lt;br&gt;从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP&amp;#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。&lt;/p&gt;</summary>
    
    
    
    <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
    <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
    <category term="Socket" scheme="http://yeungeek.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-TCP/IP协议</title>
    <link href="http://yeungeek.github.io/2019/06/21/Network-TCP-IP/"/>
    <id>http://yeungeek.github.io/2019/06/21/Network-TCP-IP/</id>
    <published>2019-06-21T11:28:07.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2019/06/14/Network-Basic/">Android网络编程-计算机网络基础</a>一文中得知，IP协议属于网络层，TCP、UDP协议属于传输层。<br>IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。<br>TCP协议是面向连接的传输层协议，提供一种面向连接的、可靠的字节流服务。<br>UDP协议是面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。</p><span id="more"></span><h1 id="数据报文"><a href="#数据报文" class="headerlink" title="数据报文"></a>数据报文</h1><p>在不同层传输的数据单位名称不同，在网络层传输的叫数据报，在传输层传输的叫报文段。</p><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p>IP数据报格式如下图:<br><a href="https://imgchr.com/i/ZkNR7d"><img src="https://s2.ax1x.com/2019/06/24/ZkNR7d.jpg" alt="IP数据报"></a><br>各个字段的详细说明：</p><table><thead><tr><th align="left">名称</th><th align="left">长度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">版本</td><td align="left">4bit</td><td align="left">IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6</td></tr><tr><td align="left">首部长度</td><td align="left">4bit</td><td align="left">IP报头的长度，最大长度60字节(15*4)，<br>分为固定部分的长度(20字节)和可变部分的长度</td></tr><tr><td align="left">服务类型</td><td align="left">8bit</td><td align="left">Type Of Service</td></tr><tr><td align="left">总长度</td><td align="left">16bit</td><td align="left">IP报文的总长度。数据报的最大长度为 65535 字节</td></tr><tr><td align="left">标识</td><td align="left">16bit</td><td align="left">它是一个计数器，用来产生数据报的标识。<br>当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，<br>此标识表示同一个数据报的分片。</td></tr><tr><td align="left">标志</td><td align="left">3bit</td><td align="left">R、DF、MF三位，目前只有后两位有效。<br>DF位：为1表示不分片，为0表示分片。<br>MF：为1表示“更多的片”，为0表示这是最后一片。</td></tr><tr><td align="left">片偏移</td><td align="left">13bit</td><td align="left">本分片在原先数据报文中相对首位的偏移位。<br>片偏移以8个字节为偏移单位。</td></tr><tr><td align="left">生存时间</td><td align="left">8bit</td><td align="left">TTL (Time To Live)表示数据报在网络中的寿命，其单位为秒。<br>在目前的实际应用中，常以“跳”为单位。</td></tr><tr><td align="left">协议</td><td align="left">8bit</td><td align="left">指出IP报文携带的数据使用的哪种协议，<br>以便目的主机的IP层能知道要将数据报上交到哪个进程。<br>TCP的协议号为6，UDP的协议号为17。<br>ICMP的协议号为1，IGMP的协议号为2.</td></tr><tr><td align="left">首部校验和</td><td align="left">16bit</td><td align="left">计算IP头部的校验和，检查IP报头的完整性。</td></tr><tr><td align="left">源地址</td><td align="left">32bit</td><td align="left">标识IP数据报的源端设备。</td></tr><tr><td align="left">目的地址</td><td align="left">32bit</td><td align="left">标识IP数据报的目的地址。</td></tr><tr><td align="left">可选字段</td><td align="left">长度可变</td><td align="left">1～40 字节，用于增加IP数据报的控制功能。</td></tr><tr><td align="left">填充</td><td align="left"></td><td align="left">保证IP首部长度是4字节的整倍数</td></tr></tbody></table><h2 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h2><p><a href="https://imgchr.com/i/Zkc0N8"><img src="https://s2.ax1x.com/2019/06/24/Zkc0N8.md.png" alt="TCP报文"></a></p><table><thead><tr><th align="left">名称</th><th align="left">长度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">源端口</td><td align="left">16bit</td><td align="left">数据发送方的端口号</td></tr><tr><td align="left">目的端口</td><td align="left">16bit</td><td align="left">数据接受方的端口号</td></tr><tr><td align="left">序号</td><td align="left">32bit</td><td align="left">本数据报文中的的第一个字节的序号<br>(在数据流中每个字节都对应一个序号)</td></tr><tr><td align="left">确认号</td><td align="left">32bit</td><td align="left">希望收到的下一个数据报文中的第一个字节的序号</td></tr><tr><td align="left">数据偏移</td><td align="left">4bit</td><td align="left">表示本报文数据段距离报文段有多远</td></tr><tr><td align="left">保留字段</td><td align="left">6bit</td><td align="left">保留为今后使用，但目前应置为0</td></tr><tr><td align="left">紧急比特URG</td><td align="left"></td><td align="left">当值为1时表示次报文段中有需要紧急处理</td></tr><tr><td align="left">确认比特ACK</td><td align="left"></td><td align="left">值为1时确认号有效，值为0时确认号无效</td></tr><tr><td align="left">复位比特RST</td><td align="left"></td><td align="left">值为1时表示TCP连接存在严重的错误，需要重新进行连接</td></tr><tr><td align="left">同步比特SYN</td><td align="left"></td><td align="left">值为1表示这是一个连接请求或连接接受报文</td></tr><tr><td align="left">终止比特FIN</td><td align="left"></td><td align="left">值为1表示要发送的数据报已经发送完毕，需要释放传送连接</td></tr><tr><td align="left">窗口</td><td align="left">16bit</td><td align="left">TCP连接的一端根据缓存空间的大小来确定自己接受窗口的大小<br>限制发送放的窗口上限</td></tr><tr><td align="left">检验和</td><td align="left">16bit</td><td align="left">用来检验首部和数据两部分的正确性</td></tr><tr><td align="left">紧急指针字段</td><td align="left">16bit</td><td align="left">紧急指针指出在本报文段中的紧急数据的最后一个字节的序号</td></tr><tr><td align="left">选项字段</td><td align="left">长度可变</td><td align="left">TCP 首部可以有多达40字节的可选信息，<br>用于把附加信息传递给终点，或用来对齐其它选项</td></tr></tbody></table><h2 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h2><p>相对于TCP报文，UDP报文简单了很多。<br><img src="https://s2.ax1x.com/2019/06/24/ZEKjVP.png" alt="UDP报文"></p><table><thead><tr><th align="left">名称</th><th align="left">长度</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">源端口</td><td align="left">16bit</td><td align="left">数据发送方的端口号</td></tr><tr><td align="left">目的端口</td><td align="left">16bit</td><td align="left">数据接受方的端口号</td></tr><tr><td align="left">包长度</td><td align="left">16bit</td><td align="left">UDP首部的长度和数据的长度之和。单位为字节</td></tr><tr><td align="left">校验和</td><td align="left">16bit</td><td align="left">用来检验首部和数据两部分的正确性</td></tr></tbody></table><h1 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h1><p>TCP用三次握手来创建连接，使用四次分手来释放连接。<br><a href="https://imgchr.com/i/ZEMwMd"><img src="https://s2.ax1x.com/2019/06/24/ZEMwMd.md.png" alt="三次握手"></a></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小的信息。<br>握手过程：</p><blockquote><ol><li>第一次握手：建立连接，客户端先发送连接请求报文，将SYN设置为1，Sequence Number为x。客户端进入SYN+SEND状态，等待服务器确认。</li><li>第二次握手：服务器收到SYN报文。服务器收到客户端的SYN报文，需要对这个SYN报文进行确认，设置Acknowledgment Number为x+1(Sequence+1)；同时，自己还要送法SYN消息，将SYN位置为1，Sequence Number为y；服务器将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN+RECV状态。</li><li>第三次握手：客户端收到服务器的 SYN+ACK报文段。然后将Acknowlegment Number设为y+1,向服务器发送ACK报文段，这个报文段发送完毕后，客户端端服务器都进入ESTABLISHED状态，完成TCP三次握手。</li></ol></blockquote><p>完成了三次握手，客户端和服务器就可以开始传送数据了。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>当客户端和服务端传输数据完毕后，需要断开TCP连接。TCP断开的过程，就是四次挥手。</p><blockquote><ol><li>第一次挥手：客户端(也可以是服务器)，设置Sequence Number和Acknowledgment Number，向服务器发送一个FIN报文段。此时客户端进入FIN_WAIT_1状态；这表示客户端没有数据发送给主机了。</li><li>第二次挥手：服务器收到客户端发来的FIN报文段，向客户端回一个ACK报文段，Acknowledgement Number为Sequence Number加1；客户端进入FIN_WAIT_2状态，服务器进入CLOSE_WAIT状态；服务器告诉客户端，我同意你的”关闭”请求。</li><li>第三次挥手：服务器向客户端发送FIN报文段，请求关闭连接，同时服务器进入LAST_ACK状态。</li><li>第四次挥手：客户端收到服务器发送的FIN报文段，向主机发送ACK报文段，然后客户端进入TIME_WAIT状态，服务器收到客户端的ACK报文段以后，就关闭连接，此时，客户端等待2MSL后一次没有到收到回复，则证明服务端已正常关闭，那好，客户端也可以关闭连接了。</li></ol></blockquote><h2 id="TCP三次握手的必要性"><a href="#TCP三次握手的必要性" class="headerlink" title="TCP三次握手的必要性"></a>TCP三次握手的必要性</h2><p>防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源。</p><h2 id="TCP四次挥手的必要性"><a href="#TCP四次挥手的必要性" class="headerlink" title="TCP四次挥手的必要性"></a>TCP四次挥手的必要性</h2><p>为了保证通信双方都能通知对方，需释放、断开连接。</p><h3 id="为什么客户端关闭连接前要等待2MSL时间"><a href="#为什么客户端关闭连接前要等待2MSL时间" class="headerlink" title="为什么客户端关闭连接前要等待2MSL时间"></a>为什么客户端关闭连接前要等待2MSL时间</h3><blockquote><p>MSL: 最大报文段生存时间</p></blockquote><p>四个报文发送完毕后，就可以直接进入CLOSE状态了，但是有可能网络是不可靠的，一切都可能发生，比如有可能最后一个ACK丢失。所以TIME_WAIT状态是用来重发可能丢失的ACK报文。展开具体来讲：  </p><ul><li>为了保证客户端发送的最后1个连接释放确认报文 能到达服务器，从而使得服务器能正常释放连接。</li><li>防止早已失效的连接请求报文，出现在本连接中。客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。</li></ul><h1 id="TCP、UDP比较"><a href="#TCP、UDP比较" class="headerlink" title="TCP、UDP比较"></a>TCP、UDP比较</h1><table><thead><tr><th align="left"></th><th align="left">TCP</th><th align="left">UDP</th></tr></thead><tbody><tr><td align="left">可靠性</td><td align="left">可靠</td><td align="left">不可靠</td></tr><tr><td align="left">连接性</td><td align="left">面向连接</td><td align="left">无连接</td></tr><tr><td align="left">报文</td><td align="left">面向字节流</td><td align="left">面向报文</td></tr><tr><td align="left">效率</td><td align="left">低效</td><td align="left">高效</td></tr><tr><td align="left">双工性</td><td align="left">全双工</td><td align="left">一对一，一对多，多对一，多对多<br>支持多播和广播</td></tr><tr><td align="left">流量控制</td><td align="left">滑动窗口机制</td><td align="left"></td></tr><tr><td align="left">拥塞控制</td><td align="left">慢开始&#x2F;拥塞避免<br>快重传&#x2F;快恢复</td><td align="left"></td></tr><tr><td align="left">传输速度</td><td align="left">慢</td><td align="left">快</td></tr><tr><td align="left">应用场景</td><td align="left">效率要求相对低，准确要求相对高。<br>要求有连接的场景</td><td align="left">效率要求相对高，准确要求相对低</td></tr><tr><td align="left">应用</td><td align="left">SMTP，TELNET，HTTP，FTP</td><td align="left">DNS，RIP，NFS，SNMP，<br>IP电话，流媒体</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.jianshu.com/p/65605622234b">计算机网络：这是一份全面 &amp; 详细 的TCP协议攻略</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/5987827.html">《图解TCP&#x2F;IP》读书笔记</a></li><li><a href="https://juejin.im/post/5a2614b8f265da432652af7d">Android网络编程：基础理论汇总</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/2019/06/14/Network-Basic/&quot;&gt;Android网络编程-计算机网络基础&lt;/a&gt;一文中得知，IP协议属于网络层，TCP、UDP协议属于传输层。&lt;br&gt;IP协议是TCP&amp;#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。&lt;br&gt;TCP协议是面向连接的传输层协议，提供一种面向连接的、可靠的字节流服务。&lt;br&gt;UDP协议是面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。&lt;/p&gt;</summary>
    
    
    
    <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
    <category term="TCP" scheme="http://yeungeek.github.io/tags/TCP/"/>
    
    <category term="UDP" scheme="http://yeungeek.github.io/tags/UDP/"/>
    
    <category term="IP" scheme="http://yeungeek.github.io/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-计算机网络基础</title>
    <link href="http://yeungeek.github.io/2019/06/14/Network-Basic/"/>
    <id>http://yeungeek.github.io/2019/06/14/Network-Basic/</id>
    <published>2019-06-14T22:58:01.000Z</published>
    <updated>2023-09-27T11:45:23.478Z</updated>
    
    <content type="html"><![CDATA[<p>从本篇开始，真正进入我们的Android网络编程学习之旅。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>计算机网络是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统。</p><span id="more"></span><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><blockquote><p>计算机网络体系结构可以定义为是网络协议的层次划分与各层协议的集合，同一层中的协议根据该层所要实现的功能来确定。各对等层之间的协议功能由相应的底层提供服务完成。<br>—— 百度百科</p></blockquote><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>对于复杂的计算机网络协议，结构分层很有必要。就像Android开发中，把应用分层各个模块。<br><img src="https://s2.ax1x.com/2019/06/19/VOlsPS.png" alt="VOlsPS.png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li><code>各层之间相互独立。</code>某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间接口（即界面）所提供的服务</li><li><code>灵活性好。</code>当任何一层发送变化时（例如由于技术的变化），只要层间接口关系保持不变，则在这层以上或以下各层均不受影响</li><li><code>结构上可分割开。</code>各层都可以采用最合适的技术来实现</li><li><code>易于实现和维护。</code> 这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统</li><li><code>能促进标准化工作。</code>因为每一层的功能及其所提供的服务都已有了精确的说明</li></ul><p>缺点：<br>各层之间会有相同的功能出现，产生额外开销。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>目前有3种体系结构:</p><ul><li>OSI参考模型，概念清楚，理论也较完整，但它既复杂又不实用</li><li>TCP&#x2F;IP体系结构，是一系列网络协议的总称，目前应用最广泛</li><li>五层体系结构，综合OSI和TCP&#x2F;IP的优点,既简洁又能将概念阐述清楚</li></ul><p><a href="https://imgchr.com/i/VjDXwV"><img src="https://s2.ax1x.com/2019/06/20/VjDXwV.md.png" alt="体系结构"></a></p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><table><thead><tr><th align="center">分层</th><th align="left">功能</th><th align="left">数据单位</th><th align="left">协议栈</th></tr></thead><tbody><tr><td align="center">物理层</td><td align="left">屏蔽传输媒体和通信手段的差异</td><td align="left">比特(bit)</td><td align="left"></td></tr><tr><td align="center">数据链路层</td><td align="left">互连设备之间传送和识别数据帧</td><td align="left">帧(frame)</td><td align="left">点对点协议<br>以太网协议 <br>高级数据链路协议<br>帧中继</td></tr><tr><td align="center">网络层</td><td align="left">地址管理和路由选择</td><td align="left">数据报(datagram)</td><td align="left">IP协议<br>路由选择协议</td></tr><tr><td align="center">传输层</td><td align="left">管理两个节点之间的数据传输 <br> 负责可靠传输（确保数据被可靠地传送到目标地址）</td><td align="left">报文段(segment)</td><td align="left">TCP协议<br>UDP协议</td></tr><tr><td align="center">会话层</td><td align="left">通信管理。负责建立和断开通信连接（数据流动的逻辑通路）<br> 提供了数据交换定界和同步功能 <br>管理传输层一下的分层</td><td align="left"></td><td align="left"></td></tr><tr><td align="center">表示层</td><td align="left">数据压缩、加密以及数据描述</td><td align="left"></td><td align="left"></td></tr><tr><td align="center">应用层</td><td align="left">针对特定应用的协议</td><td align="left">报文(message)</td><td align="left">HTTP<br>DNS<br>FTP<br>SMTP<br>SSH</td></tr></tbody></table><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><p>TCP&#x2F;IP的体系结构比较简单，只有四层。<br>它并不是遵循严格的 OSI 分层概念，应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。可以演化成如下图所示:<br><a href="https://imgchr.com/i/Vjvt4f"><img src="https://s2.ax1x.com/2019/06/20/Vjvt4f.png" alt="tcp/ip"></a></p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><p>OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。TCP&#x2F;IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP&#x2F;IP 是一个四层的体系结构。在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><h2 id="五层协议中各层的主要功能"><a href="#五层协议中各层的主要功能" class="headerlink" title="五层协议中各层的主要功能"></a>五层协议中各层的主要功能</h2><p>五层协议中，没有表示层和会话层，这两层的功能留给开发者来处理。</p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p><img src="https://s2.ax1x.com/2019/06/20/VxGwmF.png" alt="物理层"><br>在物理层，定义了以下内容：  </p><ul><li>接口特性<ul><li>机械特性：规定了接口的几何形状等</li><li>电器特性：规定了接口使用的电平大小等</li><li>功能特性：规定了接口引脚个数及各项功能等</li><li>规程特性：定义了接口在工作过程中遵循的相应过程。</li></ul></li><li>比特编码：用比特对信息按照一定规则进行编码，用于传输</li><li>数据率：即数据传输速率</li><li>比特同步：时钟同步</li><li>通讯方式:<ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>双工通信：双向同时传输</li></ul></li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p><a href="https://imgchr.com/i/VxJzDO"><img src="https://s2.ax1x.com/2019/06/20/VxJzDO.png" alt="数据链路层"></a><br>功能：</p><ul><li>负责结点-结点数据传输</li><li>组桢：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</li><li>物理寻址：在桢头添加发送端或接收端的物理地址标识数据帧的发送端或接收端。</li><li>流量控制：匹配发送端与接收端的发送速度与接收速度，避免数据淹没接收端。</li><li>差错控制：检测并重传损坏或丢失帧，并避免重复帧。</li><li>访问（接入）控制：在任一给定时刻决定哪个设备拥有链路（物理介质）的控制使用权。</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p><a href="https://imgchr.com/i/VxYDR1"><img src="https://s2.ax1x.com/2019/06/21/VxYDR1.md.png" alt="网络层"></a><br>功能:</p><ul><li>负责源主机到目的主机数据分组（packet）的交付（可能穿越多个网络）。</li><li>逻辑寻址：全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址（穿越多个网络时，链路层的物理寻址并不能用）。</li><li>路由：路由器（或网关）互连网络，并路由分组至最终目的主机，进行路径选择。</li><li>分组转发</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节。<br><a href="https://imgchr.com/i/VxYHL8"><img src="https://s2.ax1x.com/2019/06/21/VxYHL8.md.png" alt="传输层"></a><br>功能:</p><ul><li>负责源-目的（端-端）（进程间）完整报文传输</li><li>报文分段与重组</li><li>SAP寻址：确保将完整报文提交给正确进程，如端口号</li><li>连接控制：负责端-端的连接控制（建立连接、拆除连接），是一种逻辑连接</li><li>流量控制：控制端-端传输的速度</li><li>差错控制：差错检测与纠正</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p><a href="https://imgchr.com/i/VznKBR"><img src="https://s2.ax1x.com/2019/06/21/VznKBR.png" alt="应用层"></a><br>应用层直接为用户的应用进程提供服务</p><h2 id="主要协议"><a href="#主要协议" class="headerlink" title="主要协议"></a>主要协议</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。<br>IP的主要作用就是在复杂的网络环境中将数据包发给最终的目标地址。<br>相关技术：  </p><ul><li>DNS：域名系统，一种分布式的网络目录服务，主要用于域名与IP地址的要互转换。</li><li>ARP：ARP是一种解决地址问题的协议，以目标地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。不过，ARP只适用于IPv4，不适用于IPv6。</li><li>ICMP：Internet控制报文协议，作用是报告一些网络传输过程中的错误与做一些同步工作。</li><li>DHCP：动态主机配置协议，实现自动设置IP地址、统一管理IP地址分配。</li><li>NAT：网络地址转换，作用是将IP数据报头中的IP地址转换为另一个IP地址。</li><li>IP隧道：是一种数据包封装技术，它是将原始IP包（其报头包含原始发送者和最终目的地）封装在另一个数据包（称为封装的IP包）的数据净荷中进行传输。</li></ul><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>传输控制协议(Transmission Control Protocol)，面向连接的、可靠的流协议，提供可靠的通信传输。</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>用户数据报协议(User Datagram Protocol)，面向无连接的，具有不可靠性的数据报协议。</p><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><p>Routing protocol，是一种指定数据包转送方式的网上协议。</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>即套接字，是应用层 与 TCP&#x2F;IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP &#x2F; IP协议族 的编程接口（API）。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议(Hyper Text Transfer Protocol)，用于从万维网服务器传输超文本到本地浏览器的传送协议。</p><p><a href="/2019/06/13/Network-Series/#%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">系列文章目录</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://time.geekbang.org/column/intro/85">趣谈网络协议</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">互联网协议入门（一）</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/5987827.html">《图解TCP&#x2F;IP》读书笔记</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md">计算机网络</a></li><li><a href="https://juejin.im/post/5ad7e6c35188252ebd06acfa">面试带你飞：这是一份全面的 计算机网络基础 总结攻略</a></li><li><a href="https://www.cnblogs.com/hithongming/p/9315907.html">计算机网络的体系结构</a></li><li><a href="https://blog.maplemark.cn/2019/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.html">计算机网络体系结构</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;从本篇开始，真正进入我们的Android网络编程学习之旅。&lt;/p&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;计算机网络是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统。&lt;/p&gt;</summary>
    
    
    
    <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Android网络编程-系列文章</title>
    <link href="http://yeungeek.github.io/2019/06/13/Network-Series/"/>
    <id>http://yeungeek.github.io/2019/06/13/Network-Series/</id>
    <published>2019-06-13T23:34:10.000Z</published>
    <updated>2023-09-27T11:45:23.482Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发过程中，网络编程是必不可少的。<br>大家接触的<code>Volley</code>,<code>Retrofit</code>,<code>OKHttp</code>等网络框架，很好地封装了底层实现的细节，在使用过程中非常的方便。但是掌握其中的细节，对我们来说真的非常重要，只有掌握了网络编程的原理，才能真正理解这些网络框架的源码实现。</p><span id="more"></span><p>本系列会介绍计算机网络的基础、TCP&#x2F;UDP、Http协议、Socket等，并从源码角度分析<code>Retrofit</code>、<code>OKHttp</code>，它们是如何实现Http的。  </p><blockquote><p>千里之行，始于足下。不管何时，我相信，扎实的功底和过硬的技术，都会是你职业发展的助力器。<br>                                           —- 极客时间《趣谈网络协议》刘超</p></blockquote><h1 id="系列文章目录"><a href="#系列文章目录" class="headerlink" title="系列文章目录"></a>系列文章目录</h1><ul><li><a href="/2019/06/14/Network-Basic/">01.Android网络编程-计算机网络基础</a></li><li><a href="/2019/06/21/Network-TCP-IP/">02.Android网络编程-TCP&#x2F;IP协议</a></li><li><a href="/2019/06/26/Network-Socket/">03.Android网络编程-Socket</a></li><li><a href="/2019/07/12/Network-Http/">04.Android网络编程-HTTP&#x2F;HTTPS</a></li><li><a href="/2019/07/15/Network-Cookie-Session-Token/">05.Android网络编程-Cookie，Session，Token</a></li><li><a href="/2019/07/17/Network-OKHttp/">06.Android网络编程-OKHttp源码角度分析Http</a></li><li><a href="/2019/07/25/Network-Retrofit/">07.Android网络编程-Retrofit源码角度分析Http</a></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5a2614b8f265da432652af7d">Android网络编程：基础理论汇总</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md">计算机网络</a></li><li><a href="https://juejin.im/post/5ad7e6c35188252ebd06acfa">面试带你飞：这是一份全面的 计算机网络基础 总结攻略</a></li><li><a href="http://liuwangshu.cn/tags/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Android网络编程系列</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Android开发过程中，网络编程是必不可少的。&lt;br&gt;大家接触的&lt;code&gt;Volley&lt;/code&gt;,&lt;code&gt;Retrofit&lt;/code&gt;,&lt;code&gt;OKHttp&lt;/code&gt;等网络框架，很好地封装了底层实现的细节，在使用过程中非常的方便。但是掌握其中的细节，对我们来说真的非常重要，只有掌握了网络编程的原理，才能真正理解这些网络框架的源码实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Android应用层" scheme="http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="Android" scheme="http://yeungeek.github.io/tags/Android/"/>
    
    <category term="Network" scheme="http://yeungeek.github.io/tags/Network/"/>
    
    <category term="Http" scheme="http://yeungeek.github.io/tags/Http/"/>
    
    <category term="OKHttp" scheme="http://yeungeek.github.io/tags/OKHttp/"/>
    
    <category term="Retrofit" scheme="http://yeungeek.github.io/tags/Retrofit/"/>
    
  </entry>
  
</feed>
