{"meta":{"title":"Yeungeek","subtitle":"技术沉思录","description":"It's my Androad","author":"Yeungeek","url":"http://yeungeek.github.io","root":"/"},"pages":[{"title":"[404]","date":"2023-07-31T03:59:35.728Z","updated":"2023-07-31T03:40:56.492Z","comments":true,"path":"404.html","permalink":"http://yeungeek.github.io/404.html","excerpt":"","text":""},{"title":"About Me","date":"2019-06-13T06:51:46.000Z","updated":"2023-07-31T03:40:56.497Z","comments":true,"path":"about/index.html","permalink":"http://yeungeek.github.io/about/index.html","excerpt":"","text":"这是Yeungeek的个人站点. 现在是一枚Android攻城师，关注移动互联网."}],"posts":[{"title":"Android知识体系","slug":"Android-Knowledge-System","date":"2020-05-09T02:13:46.000Z","updated":"2023-07-31T03:40:56.493Z","comments":true,"path":"2020/05/09/Android-Knowledge-System/","link":"","permalink":"http://yeungeek.github.io/2020/05/09/Android-Knowledge-System/","excerpt":"建立一套比较完整的 Android 知识体系，对Android开发或者面试都有裨益，以及后面对某个垂直领域的深入，或者成为该领域的技术专家，甚至是架构师，也有一定的路线指导作用。夯实基础是重中之重，深入某个垂直领域，都是根据当前的业务需求，一步步深入，从而成为该领域专家。下面列表的内容，都是经过实例验证，做到真正掌握才会写到自己的博客里。比较完整的提纲是在最后的思维导图中，提纲中的内容，如果经过了自己验证，就会更新到博客里(持续更新)。","text":"建立一套比较完整的 Android 知识体系，对Android开发或者面试都有裨益，以及后面对某个垂直领域的深入，或者成为该领域的技术专家，甚至是架构师，也有一定的路线指导作用。夯实基础是重中之重，深入某个垂直领域，都是根据当前的业务需求，一步步深入，从而成为该领域专家。下面列表的内容，都是经过实例验证，做到真正掌握才会写到自己的博客里。比较完整的提纲是在最后的思维导图中，提纲中的内容，如果经过了自己验证，就会更新到博客里(持续更新)。 Android基础四大组件View体系JNI Android NDK-深入理解JNI Android框架层(Framework)开源框架网络OkHttp Android网络编程-OKHttp源码角度分析Http Retrofit Android网络编程-Retrofit源码角度分析Http 性能优化推荐资源书籍 《Android开发艺术探索》 《Android进阶解密》 在线课程 Android开发高手课 Android 工程师进阶 34 讲 深入拆解Java虚拟机 Android知识体系思维导图的内容并不是需要全部掌握，根据当前的业务需求，在某些领域进行深入，不过基础是必须掌握的。 参考 Android应用开发原创知识体系 请收好这一份全面 &amp; 详细的Android学习指南 这些年“崛起”的Android技术博主们","categories":[{"name":"Android框架层","slug":"Android框架层","permalink":"http://yeungeek.github.io/categories/Android%E6%A1%86%E6%9E%B6%E5%B1%82/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"}]},{"title":"Android Camera-CameraX源码分析","slug":"AndroidCamera-CameraXSource","date":"2020-02-28T13:35:11.000Z","updated":"2023-07-31T03:40:56.494Z","comments":true,"path":"2020/02/28/AndroidCamera-CameraXSource/","link":"","permalink":"http://yeungeek.github.io/2020/02/28/AndroidCamera-CameraXSource/","excerpt":"在前面一篇文章中，已经介绍了如何使用 CameraX，这篇文章就分析下 CameraX 主要流程的源码。","text":"在前面一篇文章中，已经介绍了如何使用 CameraX，这篇文章就分析下 CameraX 主要流程的源码。 本篇分析的源码版本是1.0.0-alpha06，目前最新的 CameraX 版本是1.0.0-alpha10。 引用在 build.gradle 中声明 1234567891011def camerax_version = &quot;1.0.0-alpha06&quot;implementation &quot;androidx.camera:camera-core:$&#123;camerax_version&#125;&quot;implementation &quot;androidx.camera:camera-camera2:$&#123;camerax_version&#125;&quot;def camerax_view_version = &quot;1.0.0-alpha03&quot;def camerax_ext_version = &quot;1.0.0-alpha03&quot;//other// If you to use the Camera View classimplementation &quot;androidx.camera:camera-view:$camerax_view_version&quot;// If you to use Camera Extensionsimplementation &quot;androidx.camera:camera-extensions:$camerax_ext_version&quot; camera-core：Camera核心库，设计架构的实现 camera-camera2：Camera2的配置和操作封装 camera-view：自定义的 CameraView 组件 camera-extensions：Camera的扩展，用于访问设备专属供应商效果（例如散景、HDR 及其他功能）的 API 其中camera-core和camera-camera2是必须使用的库，使用该库，可以轻松地使用Camera2 API的功能 CameraX结构首先看下 CameraX 的属性： 123456789private static final CameraX INSTANCE = new CameraX();final CameraRepository mCameraRepository = new CameraRepository();private final AtomicBoolean mInitialized = new AtomicBoolean(false);private final UseCaseGroupRepository mUseCaseGroupRepository = new UseCaseGroupRepository();private final ErrorHandler mErrorHandler = new ErrorHandler();private CameraFactory mCameraFactory;private CameraDeviceSurfaceManager mSurfaceManager;private UseCaseConfigFactory mDefaultConfigFactory;private Context mContext; 主要看其中几个重要属性： CameraRepository：Camera仓库，保存可用 Camera 的列表 UseCaseGroupRepository：UseCaseGroupLifecycleController实例仓库，每个UseCaseGroupLifecycleController都与一个LifecycleOwner相关联，该LifecycleOwner调节组中所有用例共享的通用生命周期 CameraFactory：Camera抽象工厂，Camera2CameraFactory是具体的实现类 CameraDeviceSurfaceManager：Camera设备与对应数据流管理，具体实现是Camera2DeviceSurfaceManager UseCaseConfigFactory：UseCase配置工厂 CameraX主要使用UseCase的概念与相机设备进行交互，目前提供的UseCase： 预览(Preview) 图片拍摄(ImageCapture) 图片分析(ImageAnalysis) CameraX初始化 Camera2InitializerCameraX初始化方法：init 123public static void init(Context context, @NonNull AppConfig appConfig) &#123; INSTANCE.initInternal(context, appConfig);&#125; init 是通过ContentProvier配置初始化，具体实现类Camera2Initializer 123456789101112public final class Camera2Initializer extends ContentProvider &#123; private static final String TAG = &quot;Camera2Initializer&quot;; @Override public boolean onCreate() &#123; Log.d(TAG, &quot;CameraX initializing with Camera2 ...&quot;); CameraX.init(getContext(), Camera2AppConfig.create(getContext())); return false; &#125; ...&#125; 在AndroidMainifest.xml会自动生成provider配置，ContentProvider的OnCreate调用比Applicantion的 onCreate调用更早。 123456&lt;provider android:name=&quot;androidx.camera.camera2.impl.Camera2Initializer&quot; android:exported=&quot;false&quot; android:multiprocess=&quot;true&quot; android:authorities=&quot;$&#123;applicationId&#125;.camerax-init&quot; android:initOrder=&quot;100&quot; /&gt; Camera2AppConfiginit 方法传入的 AppConfig 的 create： 1234567891011121314151617181920212223242526public static AppConfig create(Context context) &#123; // Create the camera factory for creating Camera2 camera objects CameraFactory cameraFactory = new Camera2CameraFactory(context); // Create the DeviceSurfaceManager for Camera2 CameraDeviceSurfaceManager surfaceManager = new Camera2DeviceSurfaceManager(context); // Create default configuration factory ExtendableUseCaseConfigFactory configFactory = new ExtendableUseCaseConfigFactory(); configFactory.installDefaultProvider( ImageAnalysisConfig.class, new ImageAnalysisConfigProvider(cameraFactory, context)); configFactory.installDefaultProvider( ImageCaptureConfig.class, new ImageCaptureConfigProvider(cameraFactory, context)); configFactory.installDefaultProvider( VideoCaptureConfig.class, new VideoCaptureConfigProvider(cameraFactory, context)); configFactory.installDefaultProvider( PreviewConfig.class, new PreviewConfigProvider(cameraFactory, context)); AppConfig.Builder appConfigBuilder = new AppConfig.Builder() .setCameraFactory(cameraFactory) .setDeviceSurfaceManager(surfaceManager) .setUseCaseConfigFactory(configFactory); return appConfigBuilder.build();&#125; 通过 AppConfig.Builder 进行构建，CameraX中的默认属性都在这里初始化。后面具体讲到某个 UseCase 的时候，详细分析下具体的ConfigProvider CameraX.initInternalCameraX真正初始化方法：initInternal 1234567891011121314151617181920212223242526private void initInternal(Context context, AppConfig appConfig) &#123; if (mInitialized.getAndSet(true)) &#123; return; &#125; mContext = context.getApplicationContext(); mCameraFactory = appConfig.getCameraFactory(null); if (mCameraFactory == null) &#123; throw new IllegalStateException( &quot;Invalid app configuration provided. Missing CameraFactory.&quot;); &#125; mSurfaceManager = appConfig.getDeviceSurfaceManager(null); if (mSurfaceManager == null) &#123; throw new IllegalStateException( &quot;Invalid app configuration provided. Missing CameraDeviceSurfaceManager.&quot;); &#125; mDefaultConfigFactory = appConfig.getUseCaseConfigRepository(null); if (mDefaultConfigFactory == null) &#123; throw new IllegalStateException( &quot;Invalid app configuration provided. Missing UseCaseConfigFactory.&quot;); &#125; mCameraRepository.init(mCameraFactory);&#125; 直接从 AppConfig 中获取到具体实例，mCameraFactory对应的实例是Camera2CameraFactory，mCameraRepository.init(mCameraFactory)进行 Camera 相关的初始化 CameraRepository.init1234567891011public void init(CameraFactory cameraFactory) &#123; synchronized (mCamerasLock) &#123; try &#123; Set&lt;String&gt; camerasList = cameraFactory.getAvailableCameraIds(); for (String id : camerasList) &#123; Log.d(TAG, &quot;Added camera: &quot; + id); mCameras.put(id, cameraFactory.getCamera(id)); &#125; ... &#125;&#125; getAvailableCameraIds获取可用 Camera Id列表，Camera2CameraFactory的getCamera真正初始化Camera 123456public BaseCamera getCamera(@NonNull String cameraId) &#123; Camera camera = new Camera(mCameraManager, cameraId, mAvailabilityRegistry.getAvailableCameraCount(), sHandler); mAvailabilityRegistry.registerCamera(camera); return camera;&#125; 通过CameraAvailabilityRegistry的registerCamera方法进行Camera注册到此为止，CameraX 相关属性就初始化完成了 bindToLifecycle从第一个UseCase预览(preview)来讲解CameraX 生命周期过程，以及数据传输流程。前面一篇文章已经讲解过 CameraX 的使用，其中预览(preivew)，会先声明PreviewConfig,通过 config 生成Preivew，preview.setOnPreviewOutputUpdateListener设置监听Camera数据流。这一系列流程能够实现，主要通过CameraX.bindToLifecycle实现具体流程： 12345678910111213141516171819202122232425262728293031323334353637public static void bindToLifecycle(LifecycleOwner lifecycleOwner, UseCase... useCases) &#123; Threads.checkMainThread(); UseCaseGroupLifecycleController useCaseGroupLifecycleController = INSTANCE.getOrCreateUseCaseGroup(lifecycleOwner); UseCaseGroup useCaseGroupToBind = useCaseGroupLifecycleController.getUseCaseGroup(); Collection&lt;UseCaseGroupLifecycleController&gt; controllers = INSTANCE.mUseCaseGroupRepository.getUseCaseGroups(); //检查UseCase 只能在一个lifecycle上 for (UseCase useCase : useCases) &#123; for (UseCaseGroupLifecycleController controller : controllers) &#123; UseCaseGroup useCaseGroup = controller.getUseCaseGroup(); if (useCaseGroup.contains(useCase) &amp;&amp; useCaseGroup != useCaseGroupToBind) &#123; throw new IllegalStateException( String.format( &quot;Use case %s already bound to a different lifecycle.&quot;, useCase)); &#125; &#125; &#125; //onBind监听回调 for (UseCase useCase : useCases) &#123; useCase.onBind(); &#125; calculateSuggestedResolutions(lifecycleOwner, useCases); for (UseCase useCase : useCases) &#123; useCaseGroupToBind.addUseCase(useCase); for (String cameraId : useCase.getAttachedCameraIds()) &#123; attach(cameraId, useCase); &#125; &#125; useCaseGroupLifecycleController.notifyState();&#125; UseCaseGroupLifecycleController创建 UseCaseGroupLifecycleController，UseCaseGroup控制器，通过Lifecycle组件进行 start 和 stop 操作 123456789101112UseCaseGroupLifecycleController useCaseGroupLifecycleController = INSTANCE.getOrCreateUseCaseGroup(lifecycleOwner);...private UseCaseGroupLifecycleController getOrCreateUseCaseGroup(LifecycleOwner lifecycleOwner) &#123; return mUseCaseGroupRepository.getOrCreateUseCaseGroup( lifecycleOwner, new UseCaseGroupRepository.UseCaseGroupSetup() &#123; @Override public void setup(UseCaseGroup useCaseGroup) &#123; useCaseGroup.setListener(mCameraRepository); &#125; &#125;);&#125; 通过UseCaseGroupRepository创建UseCaseGroupLifecycleController 1234567891011121314151617181920212223242526272829UseCaseGroupLifecycleController getOrCreateUseCaseGroup( LifecycleOwner lifecycleOwner, UseCaseGroupSetup groupSetup) &#123; UseCaseGroupLifecycleController useCaseGroupLifecycleController; synchronized (mUseCasesLock) &#123; //如果有缓存，则直接返回，否则进行创建 useCaseGroupLifecycleController = mLifecycleToUseCaseGroupControllerMap.get( lifecycleOwner); if (useCaseGroupLifecycleController == null) &#123; useCaseGroupLifecycleController = createUseCaseGroup(lifecycleOwner); groupSetup.setup(useCaseGroupLifecycleController.getUseCaseGroup()); &#125; &#125; return useCaseGroupLifecycleController;&#125;... private UseCaseGroupLifecycleController createUseCaseGroup(LifecycleOwner lifecycleOwner) &#123; ... // Need to add observer before creating UseCaseGroupLifecycleController to make sure // UseCaseGroups can be stopped before the latest active one is started. lifecycleOwner.getLifecycle().addObserver(createLifecycleObserver()); UseCaseGroupLifecycleController useCaseGroupLifecycleController = new UseCaseGroupLifecycleController(lifecycleOwner.getLifecycle()); //创建后，放入 map 缓存 synchronized (mUseCasesLock) &#123; mLifecycleToUseCaseGroupControllerMap.put(lifecycleOwner, useCaseGroupLifecycleController); &#125; return useCaseGroupLifecycleController;&#125; 创建UseCaseGroupLifecycleController，并增加Lifecycle生命周期控制： 1234567891011121314151617181920212223242526272829303132UseCaseGroupLifecycleController(Lifecycle lifecycle) &#123; this(lifecycle, new UseCaseGroup());&#125;/** Wraps an existing &#123;@link UseCaseGroup&#125; so it is controlled by lifecycle transitions. */UseCaseGroupLifecycleController(Lifecycle lifecycle, UseCaseGroup useCaseGroup) &#123; this.mUseCaseGroup = useCaseGroup; this.mLifecycle = lifecycle; //绑定Lifecycle lifecycle.addObserver(this);&#125;@OnLifecycleEvent(Lifecycle.Event.ON_START)public void onStart(LifecycleOwner lifecycleOwner) &#123; synchronized (mUseCaseGroupLock) &#123; mUseCaseGroup.start(); &#125;&#125;@OnLifecycleEvent(Lifecycle.Event.ON_STOP)public void onStop(LifecycleOwner lifecycleOwner) &#123; synchronized (mUseCaseGroupLock) &#123; mUseCaseGroup.stop(); &#125;&#125;@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)public void onDestroy(LifecycleOwner lifecycleOwner) &#123; synchronized (mUseCaseGroupLock) &#123; mUseCaseGroup.clear(); &#125;&#125; 上面的代码，增加了ON_START，ON_STOP，ON_DESTROY的生命周期监听 calculateSuggestedResolutions根据传入的配置，生成各个UseCase的最佳解决方案。后面的代码会以Preview这个 UseCase 展开，其他 UseCase 代码逻辑类似。 1234567891011121314151617181920212223242526272829303132333435private static void calculateSuggestedResolutions(LifecycleOwner lifecycleOwner, UseCase... useCases) &#123; // There will only one lifecycleOwner active. Therefore, only collect use cases belong to // same lifecycleOwner and calculate the suggested resolutions. ... // Collect new use cases for different camera devices for (UseCase useCase : useCases) &#123; String cameraId = null; try &#123; cameraId = getCameraWithCameraDeviceConfig( (CameraDeviceConfig) useCase.getUseCaseConfig()); &#125; catch (CameraInfoUnavailableException e) &#123; throw new IllegalArgumentException( &quot;Unable to get camera id for the camera device config.&quot;, e); &#125; &#125; ... // Get suggested resolutions and update the use case session configuration for (String cameraId : newCameraIdUseCaseMap.keySet()) &#123; Map&lt;UseCase, Size&gt; suggestResolutionsMap = getSurfaceManager() .getSuggestedResolutions( cameraId, originalCameraIdUseCaseMap.get(cameraId), newCameraIdUseCaseMap.get(cameraId)); for (UseCase useCase : newCameraIdUseCaseMap.get(cameraId)) &#123; Size resolution = suggestResolutionsMap.get(useCase); Map&lt;String, Size&gt; suggestedCameraSurfaceResolutionMap = new HashMap&lt;&gt;(); suggestedCameraSurfaceResolutionMap.put(cameraId, resolution); //更新配置 useCase.updateSuggestedResolution(suggestedCameraSurfaceResolutionMap); &#125; &#125;&#125; 每个 UseCase 会去更新对应配置 updateSuggestedResolution-&gt;onSuggestedResolutionUpdated 1234public void updateSuggestedResolution(Map&lt;String, Size&gt; suggestedResolutionMap) &#123; Map&lt;String, Size&gt; resolutionMap = onSuggestedResolutionUpdated(suggestedResolutionMap); ...&#125; onSuggestedResolutionUpdated针对不同的 UseCase 有不同的实现，这里以Preview为例 12345678910111213141516171819protected Map&lt;String, Size&gt; onSuggestedResolutionUpdated( Map&lt;String, Size&gt; suggestedResolutionMap) &#123; //获取前面配置的 config PreviewConfig config = (PreviewConfig) getUseCaseConfig(); String cameraId = getCameraIdUnchecked(config); Size resolution = suggestedResolutionMap.get(cameraId); ... //设置 config updateConfigAndOutput(config, resolution); return suggestedResolutionMap;&#125;...private void updateConfigAndOutput(PreviewConfig config, Size resolution) &#123; String cameraId = getCameraIdUnchecked(config); //初始化pipeline mSessionConfigBuilder = createPipeline(config, resolution); attachToCamera(cameraId, mSessionConfigBuilder.build()); updateOutput(mSurfaceTextureHolder.getSurfaceTexture(), resolution);&#125; Preview.createPipeline创建Preview管道，通过 PreviewConfig 的配置，创建对应的显示Surface和SessionConfig 123456789101112131415161718192021222324252627282930313233SessionConfig.Builder createPipeline(PreviewConfig config, Size resolution) &#123; Threads.checkMainThread(); SessionConfig.Builder sessionConfigBuilder = SessionConfig.Builder.createFrom(config); final CaptureProcessor captureProcessor = config.getCaptureProcessor(null); //扩展的 extensions实现 if (captureProcessor != null) &#123; CaptureStage captureStage = new CaptureStage.DefaultCaptureStage(); // TODO: To allow user to use an Executor for the processing. ... &#125; else &#123; final ImageInfoProcessor processor = config.getImageInfoProcessor(null); if (processor != null) &#123; sessionConfigBuilder.addCameraCaptureCallback(new CameraCaptureCallback() &#123; @Override public void onCaptureCompleted( @NonNull CameraCaptureResult cameraCaptureResult) &#123; super.onCaptureCompleted(cameraCaptureResult); if (processor.process( new CameraCaptureResultImageInfo(cameraCaptureResult))) &#123; notifyUpdated(); &#125; &#125; &#125;); &#125; //默认的 Surface CheckedSurfaceTexture checkedSurfaceTexture = new CheckedSurfaceTexture(resolution); mSurfaceTextureHolder = checkedSurfaceTexture; sessionConfigBuilder.addSurface(checkedSurfaceTexture); &#125; ...&#125; 这里就可以看到我们熟悉的味道，在Camera2中 用到的Surface，Session相关配置，后面会用到相关配置。在CheckedSurfaceTexture中会创建FixedSizeSurfaceTexture用来显示图像。 Preview.updateOutput增加数据的监听 123456789101112131415161718192021void updateOutput(SurfaceTexture surfaceTexture, Size resolution) &#123; PreviewConfig useCaseConfig = (PreviewConfig) getUseCaseConfig(); ... PreviewOutput newOutput = PreviewOutput.create(surfaceTexture, resolution, relativeRotation); // Only update the output if something has changed if (!Objects.equals(mLatestPreviewOutput, newOutput)) &#123; SurfaceTexture oldTexture = (mLatestPreviewOutput == null) ? null : mLatestPreviewOutput.getSurfaceTexture(); OnPreviewOutputUpdateListener outputListener = getOnPreviewOutputUpdateListener(); ... if (outputListener != null) &#123; mSurfaceDispatched = true; updateListener(outputListener, newOutput); &#125; &#125;&#125; 根据Preview设置的setOnPreviewOutputUpdateListener，获取到对应的Listener，通过updateListener方法回调数据。 12345private void updateListener(OnPreviewOutputUpdateListener listener, PreviewOutput output) &#123; ... mOutputUpdateExecutor.execute(() -&gt; listener.onUpdated(output)); ...&#125; notifyState调用UseCaseGroupLifecycleController的notifyState，激活 UseCase 状态，在UseCaseGroupLifecycleController中有增加生命周期的监听，在ON_START状态会调用mUseCaseGroup.start方法。 12345678910void notifyState() &#123; synchronized (mUseCaseGroupLock) &#123; if (mLifecycle.getCurrentState().isAtLeast(State.STARTED)) &#123; mUseCaseGroup.start(); &#125; for (UseCase useCase : mUseCaseGroup.getUseCases()) &#123; useCase.notifyState(); &#125; &#125;&#125; UseCaseGroup.start12345678void start() &#123; synchronized (mListenerLock) &#123; if (mListener != null) &#123; mListener.onGroupActive(this); &#125; mIsActive = true; &#125;&#125; 启动 start 状态，调用CameraRepository的onGroupActive方法： 1234567891011121314public void onGroupActive(UseCaseGroup useCaseGroup) &#123; synchronized (mCamerasLock) &#123; Map&lt;String, Set&lt;UseCase&gt;&gt; cameraIdToUseCaseMap = useCaseGroup.getCameraIdToUseCaseMap(); for (Map.Entry&lt;String, Set&lt;UseCase&gt;&gt; cameraUseCaseEntry : cameraIdToUseCaseMap.entrySet()) &#123; BaseCamera camera = getCamera(cameraUseCaseEntry.getKey()); attachUseCasesToCamera(camera, cameraUseCaseEntry.getValue()); &#125; &#125;&#125;...private void attachUseCasesToCamera(BaseCamera camera, Set&lt;UseCase&gt; useCases) &#123; camera.addOnlineUseCase(useCases);&#125; camera.addOnlineUseCase关联UseCase 和 Camera。 Camera.addOnlineUseCase123456789101112131415161718192021222324252627282930313233public void addOnlineUseCase(@NonNull final Collection&lt;UseCase&gt; useCases) &#123; if (useCases.isEmpty()) &#123; return; &#125; // Attaches the surfaces of use case to the Camera (prevent from surface abandon crash) // addOnlineUseCase could be called with duplicate use case, so we need to filter out // use cases that are either pending for addOnline or are already online. // It&#x27;s ok for two thread to run here, since it‘ll do nothing if use case is already // pending. synchronized (mPendingLock) &#123; for (UseCase useCase : useCases) &#123; boolean isOnline = isUseCaseOnline(useCase); if (mPendingForAddOnline.contains(useCase) || isOnline) &#123; continue; &#125; notifyAttachToUseCaseSurfaces(useCase); mPendingForAddOnline.add(useCase); &#125; &#125; ... updateCaptureSessionConfig(); resetCaptureSession(/*abortInFlightCaptures=*/false); if (mState == InternalState.OPENED) &#123; openCaptureSession(); &#125; else &#123; open(); &#125; updateCameraControlPreviewAspectRatio(useCases);&#125; 在addOnlineUseCase方法中，open会去打开Camera设备。 Camera.open123456789101112131415161718192021222324252627282930313233343536373839404142public void open() &#123; ... switch (mState) &#123; case INITIALIZED: openCameraDevice(); break; case CLOSING: setState(InternalState.REOPENING); // If session close has not yet completed, then the camera is still open. We // can move directly back into an OPENED state. // If session close is already complete, then the camera is closing. We&#x27;ll reopen // the camera in the camera state callback. // If the camera device is currently in an error state, we need to close the // camera before reopening, so we cannot directly reopen. if (!isSessionCloseComplete() &amp;&amp; mCameraDeviceError == ERROR_NONE) &#123; Preconditions.checkState(mCameraDevice != null, &quot;Camera Device should be open if session close is not complete&quot;); setState(InternalState.OPENED); openCaptureSession(); &#125; break; default: Log.d(TAG, &quot;open() ignored due to being in state: &quot; + mState); &#125;&#125;...void openCameraDevice() &#123; // Check that we have an available camera to open here before attempting // to open the camera again. if (!mCameraAvailability.isCameraAvailable()) &#123; Log.d(TAG, &quot;No cameras available. Waiting for available camera before opening camera: &quot; + mCameraId); setState(InternalState.PENDING_OPEN); return; &#125; else &#123; setState(InternalState.OPENING); &#125; ... //真正打开相机 mCameraManager.openCamera(mCameraId, mExecutor, createDeviceStateCallback()); ...&#125; 接下来就是Camera2的预览流程 CameraCameraX封装了Camera2的标准预览流程，这些类都是在 CameraX 库中 CameraDevice.StateCallbackopenCameraDevice的stateCallback 1234567891011121314151617181920212223242526272829303132final class StateCallback extends CameraDevice.StateCallback &#123; @Override public void onOpened(CameraDevice cameraDevice) &#123; Log.d(TAG, &quot;CameraDevice.onOpened(): &quot; + cameraDevice.getId()); mCameraDevice = cameraDevice; mCameraDeviceError = ERROR_NONE; switch (mState) &#123; case CLOSING: case RELEASING: // No session should have yet been opened, so close camera directly here. Preconditions.checkState(isSessionCloseComplete()); mCameraDevice.close(); mCameraDevice = null; break; case OPENING: case REOPENING: setState(InternalState.OPENED); openCaptureSession(); break; default: throw new IllegalStateException( &quot;onOpened() should not be possible from state: &quot; + mState); &#125; &#125; ...&#125;...void openCaptureSession() &#123; ... mCaptureSession.open(validatingBuilder.build(), mCameraDevice); ...&#125; CaptureSession.open创建CaptureSession 12345678910111213141516171819202122232425262728293031323334353637void open(SessionConfig sessionConfig, CameraDevice cameraDevice) throws CameraAccessException, DeferrableSurface.SurfaceClosedException &#123; synchronized (mStateLock) &#123; switch (mState) &#123; case UNINITIALIZED: throw new IllegalStateException( &quot;open() should not be possible in state: &quot; + mState); case INITIALIZED: //Camera中传入的essionConfig，默认有TEMPLATE_PREVIEW的 surface 实现 List&lt;DeferrableSurface&gt; surfaces = sessionConfig.getSurfaces(); ... //状态更新 notifySurfaceAttached(); mState = State.OPENING; ... SessionConfigurationCompat sessionConfigCompat = new SessionConfigurationCompat( SessionConfigurationCompat.SESSION_REGULAR, outputConfigList, getExecutor(), comboCallback); CaptureRequest captureRequest = Camera2CaptureRequestBuilder.buildWithoutTarget( captureConfigBuilder.build(), cameraDevice); if (captureRequest != null) &#123; sessionConfigCompat.setSessionParameters(captureRequest); &#125; //创建CaptureSession，CameraDeviceCompat根据 Android 版本有不同的实现 CameraDeviceCompat.createCaptureSession(cameraDevice, sessionConfigCompat); ... &#125; &#125;&#125; 在Camera2的使用中，CameraDevice的createCaptureSession可以创建预览画面，CameraX的CaptureSession很好的封装了这些实现。在CaptureSession.open传入的SessionConfig，是在Camera2AppConfig.create创建的时候生成 1234567891011121314151617181920212223242526272829303132333435public static AppConfig create(Context context) &#123; // Create the camera factory for creating Camera2 camera objects CameraFactory cameraFactory = new Camera2CameraFactory(context); // PreviewConfig 配置 configFactory.installDefaultProvider( PreviewConfig.class, new PreviewConfigProvider(cameraFactory, context)); AppConfig.Builder appConfigBuilder = new AppConfig.Builder() .setCameraFactory(cameraFactory) .setDeviceSurfaceManager(surfaceManager) .setUseCaseConfigFactory(configFactory); return appConfigBuilder.build();&#125;//PreviewConfigProvider配置getConfig@Overridepublic PreviewConfig getConfig(LensFacing lensFacing) &#123; PreviewConfig.Builder builder = PreviewConfig.Builder.fromConfig(Preview.DEFAULT_CONFIG.getConfig(lensFacing)); // SessionConfig containing all intrinsic properties needed for Preview SessionConfig.Builder sessionBuilder = new SessionConfig.Builder(); // createCaptureSession中的 preview 设置 sessionBuilder.setTemplateType(CameraDevice.TEMPLATE_PREVIEW); // Add options to UseCaseConfig builder.setDefaultSessionConfig(sessionBuilder.build()); builder.setSessionOptionUnpacker(Camera2SessionOptionUnpacker.INSTANCE); CaptureConfig.Builder captureBuilder = new CaptureConfig.Builder(); captureBuilder.setTemplateType(CameraDevice.TEMPLATE_PREVIEW); builder.setDefaultCaptureConfig(captureBuilder.build()); builder.setCaptureOptionUnpacker(Camera2CaptureOptionUnpacker.INSTANCE); ...&#125; CameraDeviceCompat.createCaptureSession的CameraCaptureSession回调 1234567891011121314151617181920212223242526272829303132333435final class StateCallback extends CameraCaptureSession.StateCallback &#123; @Override public void onConfigured(@NonNull CameraCaptureSession session) &#123; synchronized (mStateLock) &#123; switch (mState) &#123; case UNINITIALIZED: case INITIALIZED: case OPENED: case RELEASED: throw new IllegalStateException( &quot;onConfigured() should not be possible in state: &quot; + mState); case OPENING: ... // Issue capture request of enableSession if exists. if (mSessionConfig != null) &#123; Config implOptions = mSessionConfig.getImplementationOptions(); CameraEventCallbacks eventCallbacks = new Camera2Config( implOptions).getCameraEventCallback( CameraEventCallbacks.createEmptyCallback()); //可配置CameraEventCallback的EnableSession回调 List&lt;CaptureConfig&gt; list = eventCallbacks.createComboCallback().onEnableSession(); if (!list.isEmpty()) &#123; issueCaptureRequests(setupConfiguredSurface(list)); &#125; &#125; // issueRepeatingCaptureRequests(); issueBurstCaptureRequest(); break; ... &#125; &#125; &#125;&#125; CaptureSession.issueRepeatingCaptureRequests开启Camera预览 123456789101112131415161718192021222324252627void issueRepeatingCaptureRequests() &#123; ... CaptureConfig captureConfig = mSessionConfig.getRepeatingCaptureConfig(); ... // The override priority for implementation options // P1 CameraEventCallback onRepeating options // P2 SessionConfig options CaptureConfig.Builder captureConfigBuilder = CaptureConfig.Builder.from(captureConfig); //创建CaptureRequest CaptureRequest captureRequest = Camera2CaptureRequestBuilder.build( captureConfigBuilder.build(), mCameraCaptureSession.getDevice(), mConfiguredSurfaceMap); if (captureRequest == null) &#123; Log.d(TAG, &quot;Skipping issuing empty request for session.&quot;); return; &#125; //设置Capture回调 CameraCaptureSession.CaptureCallback comboCaptureCallback = createCamera2CaptureCallback( captureConfig.getCameraCaptureCallbacks(), mCaptureCallback); CameraCaptureSessionCompat.setSingleRepeatingRequest(mCameraCaptureSession, captureRequest, mExecutor, comboCaptureCallback);&#125; CameraCaptureSessionCompat.setSingleRepeatingRequest 也是区分 Android 版本 1234567891011121314151617181920212223242526272829private static CameraCaptureSessionCompatImpl chooseImplementation() &#123; if (Build.VERSION.SDK_INT &gt;= 28) &#123; return new CameraCaptureSessionCompatApi28Impl(); &#125; return new CameraCaptureSessionCompatBaseImpl();&#125;//CameraCaptureSessionCompatBaseImpl，和平时使用的一样public int setSingleRepeatingRequest(@NonNull CameraCaptureSession captureSession, @NonNull CaptureRequest request, @NonNull Executor executor, @NonNull CameraCaptureSession.CaptureCallback listener) throws CameraAccessException &#123; Preconditions.checkNotNull(captureSession); // Wrap the executor in the callback CameraCaptureSession.CaptureCallback cb = new CameraCaptureSessionCompat.CaptureCallbackExecutorWrapper(executor, listener); return captureSession.setRepeatingRequest( request, cb, MainThreadAsyncHandler.getInstance());&#125;//CameraCaptureSessionCompatApi28Impl，新版本 API 有些变化public int setSingleRepeatingRequest(@NonNull CameraCaptureSession captureSession, @NonNull CaptureRequest request, @NonNull Executor executor, @NonNull CameraCaptureSession.CaptureCallback listener) throws CameraAccessException &#123; Preconditions.checkNotNull(captureSession); // Call through directly to executor API return captureSession.setSingleRepeatingRequest(request, executor, listener);&#125; 从Camera的开启到预览，以及读取各种配置，整个过程到此就完成了，接下来介绍如何拍照，这个流程相对来说比较简单 ImageCapture.takePicture拍照的流程： sendImageCaptureRequest创建 ImageCaptureRequest，设置cameraId、targetRatio、回调等 12345678910111213141516171819202122232425private void sendImageCaptureRequest( @Nullable Executor listenerExecutor, OnImageCapturedListener listener) &#123; String cameraId = getCameraIdUnchecked(mConfig); // Get the relative rotation or default to 0 if the camera info is unavailable int relativeRotation = 0; try &#123; CameraInfoInternal cameraInfoInternal = CameraX.getCameraInfo(cameraId); relativeRotation = cameraInfoInternal.getSensorRotationDegrees( mConfig.getTargetRotation(Surface.ROTATION_0)); &#125; catch (CameraInfoUnavailableException e) &#123; Log.e(TAG, &quot;Unable to retrieve camera sensor orientation.&quot;, e); &#125; Rational targetRatio = mConfig.getTargetAspectRatioCustom(null); targetRatio = ImageUtil.rotate(targetRatio, relativeRotation); mImageCaptureRequests.offer( new ImageCaptureRequest(relativeRotation, targetRatio, listenerExecutor, listener)); if (mImageCaptureRequests.size() == 1) &#123; issueImageCaptureRequests(); &#125;&#125; takePictureInternal123456789101112131415161718192021222324void issueImageCaptureRequests() &#123; if (mImageCaptureRequests.isEmpty()) &#123; return; &#125; takePictureInternal();&#125;...//拍照流程private void takePictureInternal() &#123; //自定义 Future 调用链 FutureChain.from(preTakePicture(state)) .transformAsync&#123; ... return ImageCapture.this.issueTakePicture(state); &#125;) .transformAsync&#123; ... return ImageCapture.this.postTakePicture(state); &#125;) .addCallback( ... onTakePictureFinish(null); )&#125; 自定义了整个拍照工作流，通过issueTakePicture进行拍照，postTakePicture是拍照成功，释放资源，取消3A。下面重点看下issueTakePicture流程 issueTakePicture12345ListenableFuture&lt;Void&gt; issueTakePicture(TakePictureState state) &#123; ... getCurrentCameraControl().submitCaptureRequests(captureConfigs); ...&#125; 通过CameraControl提交Capture 请求，CameraControl具体实现是Camera2CameraControl。 submitCaptureRequests123456789101112131415161718192021222324252627public void submitCaptureRequests(@NonNull final List&lt;CaptureConfig&gt; captureConfigs) &#123; mExecutor.execute(new Runnable() &#123; @Override public void run() &#123; submitCaptureRequestsInternal(captureConfigs); &#125; &#125;);&#125;...void submitCaptureRequestsInternal(final List&lt;CaptureConfig&gt; captureConfigs) &#123; mControlUpdateListener.onCameraControlCaptureRequests(captureConfigs); //mControlUpdateListener是Camera 的回调，onCameraControlCaptureRequests 真正实现在 Camera 中&#125;//Camera.javapublic void onCameraControlUpdateSessionConfig(@NonNull SessionConfig sessionConfig) &#123; mCameraControlSessionConfig = sessionConfig; updateCaptureSessionConfig();&#125;...private void updateCaptureSessionConfig() &#123; ... SessionConfig sessionConfig = validatingBuilder.build(); mCaptureSession.setSessionConfig(sessionConfig); ... &#125;&#125;Camera 获取 Capture的SessionConfig，通过`CaptureSession`进行状态控制 CaptureSession.setSessionConfig1234567891011121314151617181920212223242526272829void setSessionConfig(SessionConfig sessionConfig) &#123; synchronized (mStateLock) &#123; switch (mState) &#123; case UNINITIALIZED: throw new IllegalStateException( &quot;setSessionConfig() should not be possible in state: &quot; + mState); case INITIALIZED: case OPENING: mSessionConfig = sessionConfig; break; case OPENED: mSessionConfig = sessionConfig; if (!mConfiguredSurfaceMap.keySet().containsAll(sessionConfig.getSurfaces())) &#123; Log.e(TAG, &quot;Does not have the proper configured lists&quot;); return; &#125; Log.d(TAG, &quot;Attempting to submit CaptureRequest after setting&quot;); issueRepeatingCaptureRequests(); break; case CLOSED: case RELEASING: case RELEASED: throw new IllegalStateException( &quot;Session configuration cannot be set on a closed/released session.&quot;); &#125; &#125;&#125; 在Camera的OPENED状态，则进行拍照流程 issueRepeatingCaptureRequests1234567891011void issueRepeatingCaptureRequests() &#123; ... CameraCaptureSession.CaptureCallback comboCaptureCallback = createCamera2CaptureCallback( captureConfig.getCameraCaptureCallbacks(), mCaptureCallback); CameraCaptureSessionCompat.setSingleRepeatingRequest(mCameraCaptureSession, captureRequest, mExecutor, comboCaptureCallback); ...&#125; CameraCaptureSessionCompat根据 Android 版本有CameraCaptureSessionCompatBaseImpl和CameraCaptureSessionCompatApi28Impl两种实现，最终通过CameraCaptureSession实现真正的拍照。拍照完成后，通过最开始设置的 Listener 进行回调 ImageCapture.createPipeline在 Preview 那小节，讲解过 bindToLifecycle 流程，这里的ImageCapture也是一个UseCase。在CameraX中的calculateSuggestedResolutions方法，最终会调用到各个UseCase的onSuggestedResolutionUpdated方法。在ImageCapture的onSuggestedResolutionUpdated方法，通过createPipeline创建了拍照数据的回调 12345678910111213141516171819202122232425262728293031323334353637SessionConfig.Builder createPipeline(ImageCaptureConfig config, Size resolution) &#123; ... //和 Camera2的流程一致 mProcessingImageResultThread = new HandlerThread(&quot;OnImageAvailableHandlerThread&quot;); mProcessingImageResultThread.start(); mProcessingImageResultHandler = new Handler(mProcessingImageResultThread.getLooper()); ... mImageReader.setOnImageAvailableListener( new ImageReaderProxy.OnImageAvailableListener() &#123; @Override public void onImageAvailable(ImageReaderProxy imageReader) &#123; ImageProxy image = null; try &#123; image = imageReader.acquireLatestImage(); &#125; catch (IllegalStateException e) &#123; Log.e(TAG, &quot;Failed to acquire latest image.&quot;, e); &#125; finally &#123; if (image != null) &#123; // Call the head request listener to process the captured image. ImageCaptureRequest imageCaptureRequest; if ((imageCaptureRequest = mImageCaptureRequests.peek()) != null) &#123; SingleCloseImageProxy wrappedImage = new SingleCloseImageProxy( image); wrappedImage.addOnImageCloseListener(mOnImageCloseListener); //ImageCaptureRequest设置 Listener imageCaptureRequest.dispatchImage(wrappedImage); &#125; else &#123; // Discard the image if we have no requests. image.close(); &#125; &#125; &#125; &#125; &#125;, mProcessingImageResultHandler); ...&#125; ImageReader设置了 Camera 数据会调用，并通过ImageCaptureRequest的dispatchImage方法进行分发 ImageCaptureRequest.dispatchImage12345678910111213141516171819202122void dispatchImage(final ImageProxy image) &#123; try &#123; mListenerExecutor.execute(new Runnable() &#123; @Override public void run() &#123; Size sourceSize = new Size(image.getWidth(), image.getHeight()); if (ImageUtil.isAspectRatioValid(sourceSize, mTargetRatio)) &#123; image.setCropRect( ImageUtil.computeCropRectFromAspectRatio(sourceSize, mTargetRatio)); &#125; //真正的回调 mListener.onCaptureSuccess(image, mRotationDegrees); &#125; &#125;); &#125; catch (RejectedExecutionException e) &#123; Log.e(TAG, &quot;Unable to post to the supplied executor.&quot;); // Unable to execute on the supplied executor, close the image. image.close(); &#125;&#125; mListener是一个封装Listener，在ImageCapture中实现 ListenerListener的关系图： 1234567891011121314+-----------------------+| ||ImageCapture. ||OnImageCapturedListener|| |+-----------+-----------+ | |+-----------v-----------+ +----------------------+| | | || ImageSaver. | | ImageCapture. || OnImageSavedListener +------&gt; OnImageSavedListener || | | |+-----------------------+ +----------------------+ OnImageCapturedListener的实现，其中通过ImageSaver设置的OnImageSavedListener回调到最上层的OnImageSavedListener 12345678910111213141516171819202122232425262728293031323334353637383940414243OnImageCapturedListener imageCaptureCallbackWrapper = new OnImageCapturedListener() &#123; @Override public void onCaptureSuccess(ImageProxy image, int rotationDegrees) &#123; CameraXExecutors.ioExecutor() .execute( new ImageSaver( image, saveLocation, rotationDegrees, metadata.isReversedHorizontal, metadata.isReversedVertical, metadata.location, executor, imageSavedListenerWrapper)); &#125; ... &#125;;// ImageSaver是一个 Runnable，主要 run 的实现final class ImageSaver implements Runnable &#123; ... @Override public void run() &#123; ... //图像处理 ... if (saveError != null) &#123; postError(saveError, errorMessage, exception); &#125; else &#123; postSuccess(); &#125; &#125; ... private void postSuccess() &#123; mExecutor.execute(new Runnable() &#123; @Override public void run() &#123; //最外层回调 mListener.onImageSaved(mFile); &#125; &#125;); &#125;&#125; 整个拍照流程和数据回调就讲解完毕了。通过对 CameraX的 Preview 和 ImageCapture的分析，CameraX对Camera2进行完整的封装，统一参数配置，自动计算Resolution，简化Camera2的开发，并增加了生命周期控制，对外只暴露了简单接口。使用该库，只需要简单的几行代码就可以实现以前Camera2复杂的操作。 参考 CameraX 架构 Core Principles Behind CameraX Jetpack Library","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"CameraX","slug":"CameraX","permalink":"http://yeungeek.github.io/tags/CameraX/"}]},{"title":"Android Camera-CameraView源码分析","slug":"AndroidCamera-CameraViewAnalysis","date":"2020-01-29T07:54:31.000Z","updated":"2023-07-31T03:40:56.494Z","comments":true,"path":"2020/01/29/AndroidCamera-CameraViewAnalysis/","link":"","permalink":"http://yeungeek.github.io/2020/01/29/AndroidCamera-CameraViewAnalysis/","excerpt":"在前面文章中已经介绍了如何使用 CameraView，这是 Google 官方提供的库，并有相关 demo，因为 Android 的碎片化太严重，官方也是考虑到这些，才提供了CameraView供大家学习和参考。","text":"在前面文章中已经介绍了如何使用 CameraView，这是 Google 官方提供的库，并有相关 demo，因为 Android 的碎片化太严重，官方也是考虑到这些，才提供了CameraView供大家学习和参考。 源码分析源码结构根据官方的说明： API Level Camera API Preview View 9-13 Camera1 SurfaceView 14-20 Camera1 TextureView 21-23 Camera2 TextureView 24 Camera2 SurfaceView 具体的实现都在CameraView类中。 类图源码中涉及到的主要类之间的关系，是从最新的源码中查看到(跟官网的表格不太一样，最新的源码sdk最低版本为14)： Camera 区分：Android5.0(21)以下使用 Camera1，以上使用 Camera2 Preview View：Android6.0(23)以上使用SurfaceView(SurfaceView在Android7.0上增加了新特性(平移、旋转等))，这里应该是 Android7.0以上(&gt;23)使用SurfaceView，其他都使用TextureView，最新的源码sdk最低版本要求14。 CameraViewCameraView使用非常简单，在 CameraView 使用那篇文章已经做过详细说明。 初始化12345678910&lt;com.google.android.cameraview.CameraView android:id=&quot;@+id/camera&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:keepScreenOn=&quot;true&quot; android:adjustViewBounds=&quot;true&quot; app:autoFocus=&quot;true&quot; app:aspectRatio=&quot;4:3&quot; app:facing=&quot;back&quot; app:flash=&quot;auto&quot;/&gt; 直接看下CameraView的构造函数： 123456789101112131415161718192021222324252627282930313233343536373839public CameraView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); ... // Internal setup // 1.创建预览视图 final PreviewImpl preview = createPreviewImpl(context); mCallbacks = new CallbackBridge(); // 2.根据 Android SDK 版本选择不同的 Camera if (Build.VERSION.SDK_INT &lt; 21) &#123; mImpl = new Camera1(mCallbacks, preview); &#125; else if (Build.VERSION.SDK_INT &lt; 23) &#123; mImpl = new Camera2(mCallbacks, preview, context); &#125; else &#123; mImpl = new Camera2Api23(mCallbacks, preview, context); &#125; // Attributes // 3. 读取自定义 View 属性, 设置相机摄像头位置、预览画面比例、对焦方式、闪光灯 TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CameraView, defStyleAttr, R.style.Widget_CameraView); mAdjustViewBounds = a.getBoolean(R.styleable.CameraView_android_adjustViewBounds, false); setFacing(a.getInt(R.styleable.CameraView_facing, FACING_BACK)); String aspectRatio = a.getString(R.styleable.CameraView_aspectRatio); if (aspectRatio != null) &#123; setAspectRatio(AspectRatio.parse(aspectRatio)); &#125; else &#123; setAspectRatio(Constants.DEFAULT_ASPECT_RATIO); &#125; setAutoFocus(a.getBoolean(R.styleable.CameraView_autoFocus, true)); setFlash(a.getInt(R.styleable.CameraView_flash, Constants.FLASH_AUTO)); a.recycle(); // Display orientation detector // 4. 增加旋转方向监听，设置相机的旋转方向 mDisplayOrientationDetector = new DisplayOrientationDetector(context) &#123; @Override public void onDisplayOrientationChanged(int displayOrientation) &#123; mImpl.setDisplayOrientation(displayOrientation); &#125; &#125;;&#125; createPreviewImpl实现： 123456789private PreviewImpl createPreviewImpl(Context context) &#123; PreviewImpl preview; if (Build.VERSION.SDK_INT &gt;= 23) &#123; preview = new SurfaceViewPreview(context, this); &#125; else &#123; preview = new TextureViewPreview(context, this); &#125; return preview;&#125; 这里主要代码角度看下CameraView版本选择策略，在最开始的已经说明。Camera的选择：api &lt;21的，使用Camera1，&gt;&#x3D;21使用 Camera2，这里完全没有问题。Camera Preview的选择，存在几个疑问，api &gt;&#x3D;23使用SurfaceView，不过api 24的时候使用SurfaceView才是官方推荐的。 Starting in platform version N, SurfaceView’s window position is updated synchronously with other View rendering. This means that translating and scaling a SurfaceView on screen will not cause rendering artifacts. Such artifacts may occur on previous versions of the platform when its window is positioned asynchronously. 这里应该 api &gt;23使用SurfaceView，其他情况使用TextureView，因为在工程中 定义了minSdkVersion = 14，api 14-23使用TextureView，表格可以更新为： API Level Camera API Preview View 14-20 Camera1 TextureView 21-23 Camera2 TextureView 24 Camera2 SurfaceView Preview定义PreviewImpl封装了预览控件的操作方法，SurfaceViewPreview和TextureViewPreview分别对应SurfaceView和TextureView的PreviewImpl实现。 SurfaceViewPreview实现很简单，直接加载有SurfaceView控件的布局，并封装了SurfaceHolder操作 TextureViewPreview直接加载有TextureView控件布局，并监听TextureView.SurfaceTextureListener。 Camera定义CameraViewImpl定义了相机的各种操作，Camera1、Camera2、Camera2Api23都是CameraViewImpl的具体实现。看下它们的构造函数:Camera1 123456789101112Camera1(Callback callback, PreviewImpl preview) &#123; super(callback, preview); preview.setCallback(new PreviewImpl.Callback() &#123; @Override public void onSurfaceChanged() &#123; if (mCamera != null) &#123; setUpPreview(); adjustCameraParameters(); &#125; &#125; &#125;);&#125; 增加了 Callback，当SurfaceChanged的时候，设置预览和 Camera 参数。Camera2 12345678910Camera2(Callback callback, PreviewImpl preview, Context context) &#123; super(callback, preview); mCameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE); mPreview.setCallback(new PreviewImpl.Callback() &#123; @Override public void onSurfaceChanged() &#123; startCaptureSession(); &#125; &#125;);&#125; 1.初始化了CameraManager2.增加Callback，当SurfaceChanged的时候，对CaptureSession进行设置 Camera2Api23继承了Camera2，重用了Camera2的构造。Camera1和 Camera2的实现和使用流程，可以参考前面的几篇文章，接下来介绍CameraView的几个重要方法的实现。 start12345678910public void start() &#123; if (!mImpl.start()) &#123; //store the state ,and restore this state after fall back o Camera1 Parcelable state = onSaveInstanceState(); // Camera2 uses legacy hardware layer; fall back to Camera1 mImpl = new Camera1(mCallbacks, createPreviewImpl(getContext())); onRestoreInstanceState(state); mImpl.start(); &#125;&#125; 开启相机，首先判断是否可以开启，如果不能开启，默认会使用 Camera1。 Camera1.start1234567891011121314boolean start() &#123; //1. 选择摄像头 chooseCamera(); //2. 打开摄像头 openCamera(); //3. 设置预览 if (mPreview.isReady()) &#123; setUpPreview(); &#125; mShowingPreview = true; //4. 开始预览 mCamera.startPreview(); return true;&#125; 具体的流程，可以参考Camera1使用，这里介绍几个重要的方法。1.chooseCamera会遍历所有摄像头，然后根据CameraView初始化时传入的值进行对比，默认是FACING_BACK后置摄像头。2.openCamera方法，这里具体展开介绍下： 1234567891011121314151617181920212223242526272829303132private void openCamera() &#123; if (mCamera != null) &#123; releaseCamera(); &#125; //1. 打开摄像头 mCamera = Camera.open(mCameraId); mCameraParameters = mCamera.getParameters(); // Supported preview sizes mPreviewSizes.clear(); //2. 获取所有支持的预览尺寸 for (Camera.Size size : mCameraParameters.getSupportedPreviewSizes()) &#123; Log.d(&quot;DEBUG&quot;, &quot;###### SupportedPreviewSizes: width=&quot; + size.width + &quot;, height=&quot; + size.height); mPreviewSizes.add(new Size(size.width, size.height)); &#125; // Supported picture sizes; mPictureSizes.clear(); //3. 获取所有支持的拍照尺寸 for (Camera.Size size : mCameraParameters.getSupportedPictureSizes()) &#123; Log.d(&quot;DEBUG&quot;, &quot;###### SupportedPictureSizes: width=&quot; + size.width + &quot;, height=&quot; + size.height); mPictureSizes.add(new Size(size.width, size.height)); &#125; // AspectRatio if (mAspectRatio == null) &#123; mAspectRatio = Constants.DEFAULT_ASPECT_RATIO; &#125; //4. 设置预览比例 adjustCameraParameters(); mCamera.setDisplayOrientation(calcDisplayOrientation(mDisplayOrientation)); mCallback.onCameraOpened();&#125; 3.setUpPreview设置预览 1234567891011void setUpPreview() &#123; try &#123; if (mPreview.getOutputClass() == SurfaceHolder.class) &#123; mCamera.setPreviewDisplay(mPreview.getSurfaceHolder()); &#125; else &#123; mCamera.setPreviewTexture((SurfaceTexture) mPreview.getSurfaceTexture()); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125;&#125; 根据mPreview类型的不同，使用SurfaceView预览或者TextureView预览。4.mCamera.startPreview()开启预览 Camera2.start12345678910111213boolean start() &#123; //1. 选择摄像头，默认后置摄像头 if (!chooseCameraIdByFacing()) &#123; return false; &#125; //2. 设置预览尺寸，预览尺寸比例，拍照尺寸，其他相关设置 collectCameraInfo(); //3. 初始化 ImageReader，并设置回调 prepareImageReader(); //4. 打开摄像头 startOpeningCamera(); return true;&#125; 具体流程可以参考Camera2使用，这里只介绍重要方法说明。1.chooseCameraIdByFacing遍历支持的摄像头列表，根据条件筛选获取到指定的摄像头，默认后置摄像头。2.collectCameraInfo方法，获取所有支持预览尺寸，和拍照尺寸，并获取支持的预览尺寸比例3.prepareImageReader方法，初始化ImageReader 123456789private void prepareImageReader() &#123; if (mImageReader != null) &#123; mImageReader.close(); &#125; Size largest = mPictureSizes.sizes(mAspectRatio).last(); mImageReader = ImageReader.newInstance(largest.getWidth(), largest.getHeight(), ImageFormat.JPEG, /* maxImages */ 2); mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, null);&#125; 设置输出格式为 JPEG，并增加ImageAvailableListener回调监听。4.startOpeningCamera方法，打开摄像头，并设置CameraDevice.StateCallback监听 123456789101112131415161718192021222324252627282930313233343536private void startOpeningCamera() &#123; try &#123; mCameraManager.openCamera(mCameraId, mCameraDeviceCallback, null); &#125; catch (CameraAccessException e) &#123; throw new RuntimeException(&quot;Failed to open camera: &quot; + mCameraId, e); &#125;&#125;private final CameraDevice.StateCallback mCameraDeviceCallback = new CameraDevice.StateCallback() &#123; @Override public void onOpened(@NonNull CameraDevice camera) &#123; mCamera = camera; mCallback.onCameraOpened(); //相机打开，开启预览画面 startCaptureSession(); &#125; @Override public void onClosed(@NonNull CameraDevice camera) &#123; mCallback.onCameraClosed(); &#125; @Override public void onDisconnected(@NonNull CameraDevice camera) &#123; mCamera = null; &#125; @Override public void onError(@NonNull CameraDevice camera, int error) &#123; Log.e(TAG, &quot;onError: &quot; + camera.getId() + &quot; (&quot; + error + &quot;)&quot;); mCamera = null; &#125;&#125;; 监听相机打开后，开启预览画面，startCaptureSession 1234567891011121314151617181920void startCaptureSession() &#123; if (!isCameraOpened() || !mPreview.isReady() || mImageReader == null) &#123; return; &#125; //1. 选择最合适的预览尺寸 Size previewSize = chooseOptimalSize(); mPreview.setBufferSize(previewSize.getWidth(), previewSize.getHeight()); Surface surface = mPreview.getSurface(); try &#123; //2. 创建预览请求 mPreviewRequestBuilder = mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); //3. 请求管理 target surface mPreviewRequestBuilder.addTarget(surface); //4. 创建CaptureSession，并增加Session监听 mCamera.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()), mSessionCallback, null); &#125; catch (CameraAccessException e) &#123; throw new RuntimeException(&quot;Failed to start camera session&quot;); &#125;&#125; 监听CameraCaptureSession状态的回调声明： 1234567891011121314151617181920212223242526272829303132333435private final CameraCaptureSession.StateCallback mSessionCallback = new CameraCaptureSession.StateCallback() &#123; @Override public void onConfigured(@NonNull CameraCaptureSession session) &#123; if (mCamera == null) &#123; return; &#125; mCaptureSession = session; updateAutoFocus(); updateFlash(); try &#123; //1. 开启预览，并设置监听回调 mCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(), mCaptureCallback, null); &#125; catch (CameraAccessException e) &#123; Log.e(TAG, &quot;Failed to start camera preview because it couldn&#x27;t access camera&quot;, e); &#125; catch (IllegalStateException e) &#123; Log.e(TAG, &quot;Failed to start camera preview.&quot;, e); &#125; &#125; @Override public void onConfigureFailed(@NonNull CameraCaptureSession session) &#123; Log.e(TAG, &quot;Failed to configure capture session.&quot;); &#125; @Override public void onClosed(@NonNull CameraCaptureSession session) &#123; if (mCaptureSession != null &amp;&amp; mCaptureSession.equals(session)) &#123; mCaptureSession = null; &#125; &#125;&#125;; takePicture123public void takePicture() &#123; mImpl.takePicture();&#125; 根据 api 选择不同的实现 Camera1.takePicture1234567891011121314151617181920void takePicture() &#123; if (!isCameraOpened()) &#123; throw new IllegalStateException( &quot;Camera is not ready. Call start() before takePicture().&quot;); &#125; //1. 判断是否自动对焦 if (getAutoFocus()) &#123; mCamera.cancelAutoFocus(); mCamera.autoFocus(new Camera.AutoFocusCallback() &#123; @Override public void onAutoFocus(boolean success, Camera camera) &#123; //2. 拍照 takePictureInternal(); &#125; &#125;); &#125; else &#123; //2.拍照 takePictureInternal(); &#125;&#125; 真正执行拍照的方法takePictureInternal： 123456789101112131415void takePictureInternal() &#123; if (!isPictureCaptureInProgress.getAndSet(true)) &#123; //1. 拍照增加回调 mCamera.takePicture(null, null, null, new Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123; isPictureCaptureInProgress.set(false); //2. 把 data 传到上层的回调 mCallback.onPictureTaken(data); camera.cancelAutoFocus(); camera.startPreview(); &#125; &#125;); &#125;&#125; takePicture中增加的 jpeg 的PictureCallback回调，返回的data通过callback回调到上层 Camera2.takePicture1234567891011121314151617181920212223242526272829303132333435363738394041424344void takePicture() &#123; //1.判断自动对焦 if (mAutoFocus) &#123; lockFocus(); &#125; else &#123; //2. 拍照请求 captureStillPicture(); &#125;&#125;//设置对焦private void lockFocus() &#123; mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_START); try &#123; mCaptureCallback.setState(PictureCaptureCallback.STATE_LOCKING); mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, null); &#125; catch (CameraAccessException e) &#123; Log.e(TAG, &quot;Failed to lock focus.&quot;, e); &#125;&#125;//PictureCaptureCallbackPictureCaptureCallback mCaptureCallback = new PictureCaptureCallback() &#123; @Override public void onPrecaptureRequired() &#123; mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START); setState(STATE_PRECAPTURE); try &#123; mCaptureSession.capture(mPreviewRequestBuilder.build(), this, null); mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER, CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_IDLE); &#125; catch (CameraAccessException e) &#123; Log.e(TAG, &quot;Failed to run precapture sequence.&quot;, e); &#125; &#125; @Override public void onReady() &#123; //2. 拍照请求 captureStillPicture(); &#125;&#125;; 判断是否自动对焦，最后调用captureStillPicture方法进行拍照请求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void captureStillPicture() &#123; try &#123; //1. 创建TEMPLATE_STILL_CAPTURE的Capture请求 CaptureRequest.Builder captureRequestBuilder = mCamera.createCaptureRequest( CameraDevice.TEMPLATE_STILL_CAPTURE); //2. 添加target captureRequestBuilder.addTarget(mImageReader.getSurface()); //3. 设置 AF mode captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, mPreviewRequestBuilder.get(CaptureRequest.CONTROL_AF_MODE)); //4.flash模式设置 ... // Calculate JPEG orientation. //5. 计算拍照图片的方向 @SuppressWarnings(&quot;ConstantConditions&quot;) int sensorOrientation = mCameraCharacteristics.get( CameraCharacteristics.SENSOR_ORIENTATION); captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION, (sensorOrientation + mDisplayOrientation * (mFacing == Constants.FACING_FRONT ? 1 : -1) + 360) % 360); // Stop preview and capture a still picture. //6. 停止预览 mCaptureSession.stopRepeating(); //7. 拍照 mCaptureSession.capture(captureRequestBuilder.build(), new CameraCaptureSession.CaptureCallback() &#123; @Override public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) &#123; //8. 取消对焦 unlockFocus(); &#125; &#125;, null); &#125; catch (CameraAccessException e) &#123; Log.e(TAG, &quot;Cannot capture a still picture.&quot;, e); &#125;&#125;//取消对焦，重新设置预览void unlockFocus() &#123; mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_CANCEL); try &#123; mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, null); updateAutoFocus(); updateFlash(); mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, CaptureRequest.CONTROL_AF_TRIGGER_IDLE); mCaptureSession.setRepeatingRequest(mPreviewRequestBuilder.build(), mCaptureCallback, null); mCaptureCallback.setState(PictureCaptureCallback.STATE_PREVIEW); &#125; catch (CameraAccessException e) &#123; Log.e(TAG, &quot;Failed to restart camera preview.&quot;, e); &#125;&#125; 拍照后真正的数据回调，是在初始化 ImageReader 的OnImageAvailableListener中 12345678910111213141516private final ImageReader.OnImageAvailableListener mOnImageAvailableListener = new ImageReader.OnImageAvailableListener() &#123; @Override public void onImageAvailable(ImageReader reader) &#123; try (Image image = reader.acquireNextImage()) &#123; Image.Plane[] planes = image.getPlanes(); if (planes.length &gt; 0) &#123; ByteBuffer buffer = planes[0].getBuffer(); byte[] data = new byte[buffer.remaining()]; buffer.get(data); //1. 数据回调到上层 mCallback.onPictureTaken(data); &#125; &#125; &#125;&#125;; stop如果不用拍照，或者退出应用，调用 stop 方法 123public void stop() &#123; mImpl.stop();&#125; Camera1.stop12345678910111213141516171819void stop() &#123; if (mCamera != null) &#123; //1. 停止预览 mCamera.stopPreview(); &#125; mShowingPreview = false; //2. 释放相机资源 releaseCamera();&#125;//释放相机资源private void releaseCamera() &#123; if (mCamera != null) &#123; mCamera.release(); mCamera = null; //1. 回调上层 mCallback.onCameraClosed(); &#125;&#125; Camera2.stop123456789101112131415161718void stop() &#123; //1. 关闭 session if (mCaptureSession != null) &#123; mCaptureSession.close(); mCaptureSession = null; &#125; //2. 关闭 Camera if (mCamera != null) &#123; mCamera.close(); mCamera = null; &#125; //3. 关闭 ImageReader if (mImageReader != null) &#123; mImageReader.close(); mImageReader = null; &#125;&#125; CameraView源码相关的分析就结束了，该库很好的封装了 Camera1和 Camera2的使用，本篇文章对其中的重点方法进行了分析，讲解了它的实现原理，希望对大家有所帮助。 参考： Android相机开发——CameraView源码解析 Android Camera 编程从入门到精通 Android——谷歌cameraview详解","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"SurfaceView","slug":"SurfaceView","permalink":"http://yeungeek.github.io/tags/SurfaceView/"},{"name":"TextureView","slug":"TextureView","permalink":"http://yeungeek.github.io/tags/TextureView/"},{"name":"CameraView","slug":"CameraView","permalink":"http://yeungeek.github.io/tags/CameraView/"}]},{"title":"Android Camera-相机尺寸、方向和图像数据","slug":"AndroidCamera-Orientation","date":"2020-01-23T16:14:31.000Z","updated":"2023-07-31T03:40:56.495Z","comments":true,"path":"2020/01/24/AndroidCamera-Orientation/","link":"","permalink":"http://yeungeek.github.io/2020/01/24/AndroidCamera-Orientation/","excerpt":"前面几篇文章介绍了Camera1，Camera2，CameraView和CameraX的使用，对各个API的使用，应该问题不大，不过在真正开发过程中，也会遇到各种不同的问题，本篇文章继续介绍相机开发过程中遇到的问题，主要是相机预览、拍照尺寸，方向，以及图像数据的处理。","text":"前面几篇文章介绍了Camera1，Camera2，CameraView和CameraX的使用，对各个API的使用，应该问题不大，不过在真正开发过程中，也会遇到各种不同的问题，本篇文章继续介绍相机开发过程中遇到的问题，主要是相机预览、拍照尺寸，方向，以及图像数据的处理。 尺寸这里的尺寸，主要是预览尺寸、拍照尺寸和显示预览画面的View大小。 预览尺寸如何获取预览尺寸?我们可以从cameraview的源码中获取到，分为了Camera1和Camera2。 Camera112345678mCameraParameters = mCamera.getParameters();// Supported preview sizesmPreviewSizes.clear();for (Camera.Size size : mCameraParameters.getSupportedPreviewSizes()) &#123; Log.d(&quot;DEBUG&quot;, &quot;###### SupportedPreviewSizes: width=&quot; + size.width + &quot;, height=&quot; + size.height); mPreviewSizes.add(new Size(size.width, size.height));&#125; Camera212345678mPreviewSizes.clear();for (android.util.Size size : map.getOutputSizes(mPreview.getOutputClass())) &#123; int width = size.getWidth(); int height = size.getHeight(); if (width &lt;= MAX_PREVIEW_WIDTH &amp;&amp; height &lt;= MAX_PREVIEW_HEIGHT) &#123; mPreviewSizes.add(new Size(width, height)); &#125;&#125; 不同的厂商和系统所支持的预览尺寸是不一样，下面是红米Note 5A手机上支持的所有预览尺寸： 123456789101112131415161718192021SupportedPreviewSizes: width=1280, height=720SupportedPreviewSizes: width=960, height=720SupportedPreviewSizes: width=864, height=480SupportedPreviewSizes: width=800, height=480SupportedPreviewSizes: width=768, height=432SupportedPreviewSizes: width=720, height=480SupportedPreviewSizes: width=640, height=640SupportedPreviewSizes: width=640, height=480SupportedPreviewSizes: width=480, height=640SupportedPreviewSizes: width=640, height=360SupportedPreviewSizes: width=576, height=432SupportedPreviewSizes: width=480, height=360SupportedPreviewSizes: width=480, height=320SupportedPreviewSizes: width=384, height=288SupportedPreviewSizes: width=352, height=288SupportedPreviewSizes: width=320, height=240SupportedPreviewSizes: width=240, height=320SupportedPreviewSizes: width=240, height=160SupportedPreviewSizes: width=176, height=144SupportedPreviewSizes: width=144, height=176SupportedPreviewSizes: width=160, height=120 这里尺寸的比例一般都是4:3、16:9，其他比例是在此基础上裁剪出来的 选取预览尺寸在相同宽高比下，选择最接近View的宽高，避免过大的预览尺寸, 造成性能损耗, 引起预览卡顿。在cameraview源码中，默认定义的宽高比AspectRatio DEFAULT_ASPECT_RATIO = AspectRatio.of(4, 3) Camera112345678910111213141516171819202122232425private Size chooseOptimalSize(SortedSet&lt;Size&gt; sizes) &#123; if (!mPreview.isReady()) &#123; // Not yet laid out return sizes.first(); // Return the smallest size &#125; int desiredWidth; int desiredHeight; final int surfaceWidth = mPreview.getWidth(); final int surfaceHeight = mPreview.getHeight(); if (isLandscape(mDisplayOrientation)) &#123; desiredWidth = surfaceHeight; desiredHeight = surfaceWidth; &#125; else &#123; desiredWidth = surfaceWidth; desiredHeight = surfaceHeight; &#125; Size result = null; for (Size size : sizes) &#123; // Iterate from small to large if (desiredWidth &lt;= size.getWidth() &amp;&amp; desiredHeight &lt;= size.getHeight()) &#123; return size; &#125; result = size; &#125; return result;&#125; 区分了横竖屏，然后得到尺寸中宽和高等于或者大于View的宽高的尺寸。 Camera212345678910111213141516171819202122private Size chooseOptimalSize() &#123; int surfaceLonger, surfaceShorter; final int surfaceWidth = mPreview.getWidth(); final int surfaceHeight = mPreview.getHeight(); if (surfaceWidth &lt; surfaceHeight) &#123; surfaceLonger = surfaceHeight; surfaceShorter = surfaceWidth; &#125; else &#123; surfaceLonger = surfaceWidth; surfaceShorter = surfaceHeight; &#125; SortedSet&lt;Size&gt; candidates = mPreviewSizes.sizes(mAspectRatio); // Pick the smallest of those big enough for (Size size : candidates) &#123; if (size.getWidth() &gt;= surfaceLonger &amp;&amp; size.getHeight() &gt;= surfaceShorter) &#123; return size; &#125; &#125; // If no size is big enough, pick the largest one. return candidates.last();&#125; 先判断View宽高，区分其中较大值和较小值，然后再得到尺寸中宽和高大于或者等于View的较大值和较小值的尺寸。 拍照尺寸代码也是从cameraview中截取出来的 Camera1123456mPictureSizes.clear();for (Camera.Size size : mCameraParameters.getSupportedPictureSizes()) &#123; Log.d(&quot;DEBUG&quot;, &quot;###### SupportedPictureSizes: width=&quot; + size.width + &quot;, height=&quot; + size.height); mPictureSizes.add(new Size(size.width, size.height));&#125; Camera212345protected void collectPictureSizes(SizeMap sizes, StreamConfigurationMap map) &#123; for (android.util.Size size : map.getOutputSizes(ImageFormat.JPEG)) &#123; mPictureSizes.add(new Size(size.getWidth(), size.getHeight())); &#125;&#125; 在红米Note 5A手机支持的拍照尺寸： 1234567891011121314151617181920212223242526272829303132333435SupportedPictureSizes: width=4160, height=3120SupportedPictureSizes: width=4160, height=2340SupportedPictureSizes: width=4096, height=3072SupportedPictureSizes: width=4096, height=2304SupportedPictureSizes: width=4000, height=3000SupportedPictureSizes: width=3840, height=2160SupportedPictureSizes: width=3264, height=2448SupportedPictureSizes: width=3200, height=2400SupportedPictureSizes: width=2976, height=2976SupportedPictureSizes: width=2592, height=1944SupportedPictureSizes: width=2592, height=1458SupportedPictureSizes: width=2688, height=1512SupportedPictureSizes: width=2304, height=1728SupportedPictureSizes: width=2048, height=1536SupportedPictureSizes: width=2336, height=1314SupportedPictureSizes: width=1920, height=1080SupportedPictureSizes: width=1600, height=1200SupportedPictureSizes: width=1440, height=1080SupportedPictureSizes: width=1280, height=960SupportedPictureSizes: width=1280, height=768SupportedPictureSizes: width=1280, height=720SupportedPictureSizes: width=1200, height=1200SupportedPictureSizes: width=1024, height=768SupportedPictureSizes: width=800, height=600SupportedPictureSizes: width=864, height=480SupportedPictureSizes: width=800, height=480SupportedPictureSizes: width=720, height=480SupportedPictureSizes: width=640, height=480SupportedPictureSizes: width=640, height=360SupportedPictureSizes: width=480, height=640SupportedPictureSizes: width=480, height=360SupportedPictureSizes: width=480, height=320SupportedPictureSizes: width=352, height=288SupportedPictureSizes: width=320, height=240SupportedPictureSizes: width=240, height=320 这里尺寸的比例一般也是4:3、16:9 选取拍照尺寸Camaer1和Camera2都是一样的逻辑，选取固定宽高比例中的最大尺寸，这样拍摄的图片最清晰。 1Size largest = mPictureSizes.sizes(mAspectRatio).last(); 方向这里的设置方向有两种：图像预览方向和拍照方向。在这之前，需要先介绍几个概念： 屏幕坐标方向 设备自然方向 摄像头传感器方向 相机预览方向 屏幕坐标方向在Android系统中，以屏幕左上角为坐标系统的原点(0,0)坐标，该坐标系是固定不变的，不会因为设备方向的变化而改变。 屏幕自然方向每个设备都有一个自然方向，手机和平板自然方向不一样，如图所示，这里盗个图：默认情况下，平板的自然方向是横屏，而手机的自然方向是竖屏方向。Android系统可以通过View的OrientationEventListener监听设备方向，回调方法： 1abstract public void onOrientationChanged(int orientation); onOrientationChanged返回0到359的角度，其中0表示自然方向。 摄像头传感器方向手机相机的图像数据都是来自于摄像头硬件的图像传感器，这个传感器在被固定到手机上后有一个默认的取景方向，方向一般是和手机横屏方向一致，如上图所示。 相机预览方向将摄像头传感器捕获的图像，显示在屏幕上的方向，就是相机预览方向。默认情况下，和摄像头传感器方向一致，可以通过Camera API进行改变。Camaer1可以使用setDisplayOrientation设置预览方向，Camera2则可以通过TextureView来实现。不同的摄像头位置，orientation是不一样的，orientation就是摄像头传感器方向顺时针旋转到屏幕自然方向的角度。 后置后置的orientation90对横屏来说，屏幕的自然方向和相机的摄像头传感器方向一致的。对竖屏来说，看到的图像逆时针旋转了90度，因此预览方向需要顺时针旋转90度，才能与屏幕的自然方向保持一致。 前置前置的orientation270，收集到图像后(没有经过镜像处理)，但是要显示到屏幕上，就要按照屏幕自然方向的坐标系来进行显示，需要顺时针旋转270度，才能和设备自然方向一致。预览的时候，做了镜像处理，所以只需要顺时针旋转90度，就能和设置自然方向一致。那么Camera1和Camera2具体设置预览方向的代码，来自cameraview： Camera1 1234567private int calcDisplayOrientation(int screenOrientationDegrees) &#123; if (mCameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; return (360 - (mCameraInfo.orientation + screenOrientationDegrees) % 360) % 360; // compensate the mirror &#125; else &#123; // back-facing return (mCameraInfo.orientation - screenOrientationDegrees + 360) % 360; &#125;&#125; 代码中区分了前置和后置摄像头。 后置：(mCameraInfo.orientation - screenOrientationDegrees + 360) % 360，恢复到自然方向需要顺时针旋转，而屏幕逆时针旋转正好抵掉了摄像头的旋转，两者差值+360取模。 前置：(mCameraInfo.orientation + screenOrientationDegrees) % 360，屏幕竖直方向看到的是一个镜像，360-(mCameraInfo.orientation + screenOrientationDegrees) % 360，顺时针旋转这个差值可以到自然方向，只不过这是个镜像，左右翻转了 Camera2使用的TextureView的setTransform进行旋转，并有区分横竖屏。 1234567891011121314151617181920212223242526272829303132333435363738/*** Configures the transform matrix for TextureView based on &#123;@link #mDisplayOrientation&#125; and* the surface size.*/void configureTransform() &#123; Matrix matrix = new Matrix(); if (mDisplayOrientation % 180 == 90) &#123; final int width = getWidth(); final int height = getHeight(); // Rotate the camera preview when the screen is landscape. matrix.setPolyToPoly( new float[]&#123; 0.f, 0.f, // top left width, 0.f, // top right 0.f, height, // bottom left width, height, // bottom right &#125;, 0, mDisplayOrientation == 90 ? // Clockwise new float[]&#123; 0.f, height, // top left 0.f, 0.f, // top right width, height, // bottom left width, 0.f, // bottom right &#125; : // mDisplayOrientation == 270 // Counter-clockwise new float[]&#123; width, 0.f, // top left width, height, // top right 0.f, 0.f, // bottom left 0.f, height, // bottom right &#125;, 0, 4); &#125; else if (mDisplayOrientation == 180) &#123; matrix.postRotate(180, getWidth() / 2, getHeight() / 2); &#125; mTextureView.setTransform(matrix);&#125; 拍照方向设置预览方向并不会改变拍出照片的方向。对于后置相机，相机采集到的图像和相机预览的图像是一样的，只需要旋转后置相机orientation度。对于前置相机来说，相机预览的图像和相机采集到的图像是镜像关系。采集的图像：顺时针旋转270度后，与屏幕自然方向一致。预览的图像：顺时针旋转90度后，与屏幕自然方向一致。最后盗用一张图来说明： Camera1使用mCameraParameters.setRotation()设置拍照后图像方向： 123456789101112131415161718192021mCameraParameters.setRotation(calcCameraRotation(displayOrientation));....../*** Calculate camera rotation** This calculation is applied to the output JPEG either via Exif Orientation tag* or by actually transforming the bitmap. (Determined by vendor camera API implementation)** Note: This is not the same calculation as the display orientation** @param screenOrientationDegrees Screen orientation in degrees* @return Number of degrees to rotate image in order for it to view correctly.*/private int calcCameraRotation(int screenOrientationDegrees) &#123; if (mCameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; return (mCameraInfo.orientation + screenOrientationDegrees) % 360; &#125; else &#123; // back-facing final int landscapeFlip = isLandscape(screenOrientationDegrees) ? 180 : 0; return (mCameraInfo.orientation + screenOrientationDegrees + landscapeFlip) % 360; &#125;&#125; 相机采集到的图像，只需要旋转相机orientation度。 Camera2根据CameraCharacteristics.SENSOR_ORIENTATION，使用captureRequest设置了JPEG图像的旋转方向。 12345678// Calculate JPEG orientation.@SuppressWarnings(&quot;ConstantConditions&quot;)int sensorOrientation = mCameraCharacteristics.get( CameraCharacteristics.SENSOR_ORIENTATION);captureRequestBuilder.set(CaptureRequest.JPEG_ORIENTATION, (sensorOrientation + mDisplayOrientation * (mFacing == Constants.FACING_FRONT ? 1 : -1) + 360) % 360); 图像数据Android Camera默认返回的数据格式是NV21。Camera1通过mParameters.setPreviewFormat()设置，Camera2通过ImageReader.newInstance()设置。ImageFormat枚举了很多种图片格式，其中ImageFormat.NV21和ImageFormat.YV12是官方推荐的格式，NV21、YV12格式都属于 YUV 格式，也可以表示为YCbCr，Cb、Cr的含义等同于U、V。 YUVYUV是一种颜色编码方法，和它类似的还有RGB颜色编码方法，主要应用于电视系统和模拟视频领域。其中YUV代表三个分量，Y 代表明亮度，U 和 V 表示的是色度，色度又定义了颜色的两个方面：色调和饱和度。将Y与UV分离，没有UV信息一样可以显示完整的图像，但是只能显示灰度图。 YUV采样格式YUV 图像的主流采样方式有如下三种： YUV 4:4:4 采样：每一个Y对应一组UV分量 YUV 4:2:2 采样：每两个Y共用一组UV分量 YUV 4:2:0 采样：每四个Y共用一组UV分量 盗个图说明比较清晰，黑点表示采样该像素点的Y分量，空心圆圈表示采用该像素点的UV分量 YUV存储格式有两种存储格式，planar和packed。 planar：先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V packed：每个像素点的Y,U,V是连续交替存储 YUV格式信息可以参考：YUV pixel formats根据采样方式和存储格式的不同，形成了多种YUV格式，常见的YUV格式： 采样&#x2F;格式 YUV422 YUVY 格式 UYVY 格式 YUV422P 格式 YUV420 YUV420P(YV12、YU12格式) YUV420P(NV12、NV21格式) YUVY格式YUVY格式属于packed存储格式，相邻的两个Y共用其相邻的两个U、V 1Y0 UO Y1 V0 Y2 U2 Y3 V2 Y0、Y1共用 U0、V0Y2、Y3共用 U2、V2 UYVY格式UYVY格式也属于packed存储格式，与YUYV格式不同的是UV的排列顺序不一样而已 YUV422P格式YUV422P格式属于planar存储格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V YV12、YU12格式YU12和YV12格式都属于YUV420P格式，YUV420P是planar存储格式。先存储所有Y，然后在存储U、V。YU12和YV12的区别在于YU12是先Y再U后V，而YV12是先Y再V后U。 NV12、NV21格式NV12、NV21格式YUV420SP格式，YUV420SP也是planar存储格式。先存储所有Y，然后按照UV或者VU的交替顺序进行存储。NV12格式先存储Y，然后UV再进行交替存储。NV21格式则是先存储Y，然后VU再进行交替存储。最后盗用一个数据格式的总结： 1234YV21: YYYYYYYY UU VV =&gt; YUV420P YV12: YYYYYYYY VV UU =&gt; YUV420P NV12: YYYYYYYY UV UV =&gt; YUV420SP NV21: YYYYYYYY VU VU =&gt; YUV420SP Android Camera 默认数据格式是 NV21，Camera1直接设置mParameters.setPreviewFormat(ImageFormat.NV21)，然后拍照回调中的 raw data 数据返回就是 NV21的。Camera2通过ImageReader.newInstance()设置，但是不能直接设置格式ImageFormat.NV21，在源码中有段代码： 1234if (format == ImageFormat.NV21) &#123; throw new IllegalArgumentException( &quot;NV21 format is not supported&quot;);&#125; 在最新的ImageFormat.NV21上有说明： 1234YCrCb format used for images, which uses the NV21 encoding format. This is the default format for android.hardware.Camera preview images,when not otherwise set with android.hardware.Camera.Parameters.setPreviewFormat(int).For the android.hardware.camera2 API, the YUV_420_888 format is recommended for YUV output instead. Camera2建议使用YUV_420_888来替代，所以要得到NV21的数据需要进行数据转化，具体可以参考Image类浅析(结合YUV_420_888) 参考 Android相机开发和遇到的坑 Android Camera2 教程 · 第三章 · 预览 Android 相机开发中的尺寸和方向问题 【腾讯优测干货分享】Android 相机预览方向及其适配探索 一文读懂 YUV 的采样与格式 图文详解YUV420数据格式 Image类浅析(结合YUV_420_888)","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"Orientation","slug":"Orientation","permalink":"http://yeungeek.github.io/tags/Orientation/"}]},{"title":"Android Camera-CameraView和CameraX使用","slug":"AndroidCamera-UsingCameraView","date":"2020-01-21T08:21:38.000Z","updated":"2023-07-31T03:40:56.495Z","comments":true,"path":"2020/01/21/AndroidCamera-UsingCameraView/","link":"","permalink":"http://yeungeek.github.io/2020/01/21/AndroidCamera-UsingCameraView/","excerpt":"前面两篇介绍了Camera1和Camera2的使用，发现Camera API从1到2的变化非常大，Camera2的复杂度提升了不少，官方为了让我们更容易使用Camera，出了个一个官方的库cameraview。不过这个库已经Deprecated，官方建议使用Jetpack CameraX 替代。本篇文章就介绍下CameraView和CameraX的使用","text":"前面两篇介绍了Camera1和Camera2的使用，发现Camera API从1到2的变化非常大，Camera2的复杂度提升了不少，官方为了让我们更容易使用Camera，出了个一个官方的库cameraview。不过这个库已经Deprecated，官方建议使用Jetpack CameraX 替代。本篇文章就介绍下CameraView和CameraX的使用 CameraViewCameraView的目的就是帮助开发者能够快速集成Camera1和Camera2的特性，可以用下面这张表来说明： API Level Camera API Preview View 9-13 Camera1 SurfaceView 14-20 Camera1 TextureView 21-23 Camera2 TextureView 24 Camera2 SurfaceView 开发流程CameraView定义xml中定义 12345678910&lt;com.google.android.cameraview.CameraView android:id=&quot;@+id/camera&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:keepScreenOn=&quot;true&quot; android:adjustViewBounds=&quot;true&quot; app:autoFocus=&quot;true&quot; app:aspectRatio=&quot;4:3&quot; app:facing=&quot;back&quot; app:flash=&quot;auto&quot;/&gt; xml中可以配置： autoFocus：是否自动对焦 aspectRatio：预览画面比例 facing：前后摄像头 flash：闪光灯模式 增加生命周期1234567891011@Overrideprotected void onResume() &#123; super.onResume(); mCameraView.start();&#125;@Overrideprotected void onPause() &#123; mCameraView.stop(); super.onPause();&#125; 这样声明后，就可以完成预览的工作了 相机状态回调在xml声明CameraView后，增加回调 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849if (mCameraView != null) &#123; mCameraView.addCallback(mCallback);&#125;...private CameraView.Callback mCallback = new CameraView.Callback() &#123; @Override public void onCameraOpened(CameraView cameraView) &#123; Log.d(TAG, &quot;onCameraOpened&quot;); &#125; @Override public void onCameraClosed(CameraView cameraView) &#123; Log.d(TAG, &quot;onCameraClosed&quot;); &#125; @Override public void onPictureTaken(CameraView cameraView, final byte[] data) &#123; Log.d(TAG, &quot;onPictureTaken &quot; + data.length); Toast.makeText(cameraView.getContext(), R.string.picture_taken, Toast.LENGTH_SHORT) .show(); getBackgroundHandler().post(new Runnable() &#123; @Override public void run() &#123; File file = new File(getExternalFilesDir(Environment.DIRECTORY_PICTURES), &quot;picture.jpg&quot;); Log.d(TAG, &quot;onPictureTaken file path: &quot; + file.getPath()); OutputStream os = null; try &#123; os = new FileOutputStream(file); os.write(data); os.close(); &#125; catch (IOException e) &#123; Log.w(TAG, &quot;Cannot write to &quot; + file, e); &#125; finally &#123; if (os != null) &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; // Ignore &#125; &#125; &#125; &#125; &#125;); &#125;&#125;; 有三个回调方法，相机打开，相机关闭，和拍照。 拍照1mCameraView.takePicture(); 就是这么简单，点击后拍照，然后回调中处理图像数据 CameraXCameraX 是一个 Jetpack 支持库，目的是简化Camera的开发工作，它是基于Camera2 API的基础，向后兼容至 Android 5.0（API 级别 21）。它有以下几个特性： 易用性，只需要几行代码就可以实现预览和拍照 保持设备的一致性，在不同相机设备上，对宽高比、屏幕方向、旋转、预览大小和高分辨率图片大小，做到都可以正常使用 相机特性的扩展，增加人像、HDR、夜间模式和美颜等功能 开发流程库引用目前CameraX最新版本是1.0.0-alpha06，在app的build.gradle引用： 123456789101112131415dependencies &#123; // CameraX core library. def camerax_version = &quot;1.0.0-alpha06&quot; implementation &quot;androidx.camera:camera-core:$&#123;camerax_version&#125;&quot; // If you want to use Camera2 extensions. implementation &quot;androidx.camera:camera-camera2:$&#123;camerax_version&#125;&quot; def camerax_view_version = &quot;1.0.0-alpha03&quot; def camerax_ext_version = &quot;1.0.0-alpha03&quot; //other // If you to use the Camera View class implementation &quot;androidx.camera:camera-view:$camerax_view_version&quot; // If you to use Camera Extensions implementation &quot;androidx.camera:camera-extensions:$camerax_ext_version&quot;&#125; 因为CameraX是一个 Jetpack 支持库，相机的打开和释放都是使用了Jetpack的Lifecycle来进行处理。 预览预览参数设置，使用PreviewConfig.Builder()实现： 1234567891011121314151617181920212223PreviewConfig config = new PreviewConfig.Builder() .setLensFacing(CameraX.LensFacing.BACK) .setTargetRotation(mTextureView.getDisplay().getRotation()) .setTargetResolution(new Size(640, 480)) .build();Preview preview = new Preview(config);preview.setOnPreviewOutputUpdateListener(new Preview.OnPreviewOutputUpdateListener() &#123; @Override public void onUpdated(@NonNull Preview.PreviewOutput output) &#123; if (mTextureView.getParent() instanceof ViewGroup) &#123; ViewGroup viewGroup = (ViewGroup) mTextureView.getParent(); viewGroup.removeView(mTextureView); viewGroup.addView(mTextureView, 0); mTextureView.setSurfaceTexture(output.getSurfaceTexture()); updateTransform(); &#125; &#125;&#125;);//lifecycleCameraX.bindToLifecycle(this, preview); PreivewConfig.Builder可以设置的属性很多，这里只设置了摄像头、旋转方向、预览分辨率，还有很多其他方法，大家可以自行试验。在preview回调监听中，把output的SurfaceTexture设置到mTextureView中，实现图像预览，最后增加Lifecycle的绑定。 拍照123456789101112131415161718192021222324ImageCaptureConfig captureConfig = new ImageCaptureConfig.Builder() .setTargetAspectRatio(AspectRatio.RATIO_16_9) .setCaptureMode(ImageCapture.CaptureMode.MIN_LATENCY) .setTargetRotation(getWindowManager().getDefaultDisplay().getRotation()) .build();ImageCapture imageCapture = new ImageCapture(captureConfig);mTakePicture.setOnClickListener((view) -&gt; &#123; final File file = new File(getExternalMediaDirs()[0], System.currentTimeMillis() + &quot;.jpg&quot;); Log.d(&quot;DEBUG&quot;, &quot;##### file path: &quot; + file.getPath()); imageCapture.takePicture(file, ContextCompat.getMainExecutor(getApplicationContext()), new ImageCapture.OnImageSavedListener() &#123; @Override public void onImageSaved(@NonNull File file) &#123; Log.d(&quot;DEBUG&quot;, &quot;##### onImageSaved: &quot; + file.getPath()); &#125; @Override public void onError(@NonNull ImageCapture.ImageCaptureError imageCaptureError, @NonNull String message, @Nullable Throwable cause) &#123; Log.d(&quot;DEBUG&quot;, &quot;##### onError: &quot; + message); &#125; &#125;);&#125;);CameraX.bindToLifecycle(this, preview, imageCapture); 拍照的参数通过ImageCaptureConfig.Builder设置，这里只设置了图片宽高比、拍摄模式和旋转方向，还有很多其他方法，大家可以自行试验。真正调用拍照的方法： takePicture(OnImageCapturedListener)：此方法为拍摄的图片提供内存缓冲区。 takePicture(File, OnImageSavedListener)：此方法将拍摄的图片保存到提供的文件位置。 takePicture(File, OnImageSavedListener, Metadata)：此方法可用于指定要嵌入已保存文件的 Exif 中的元数据。 例子调用的是takePicture(File, OnImageSavedListener)，直接存为文件。最后再增加Lifecycle的绑定。 图片分析12345678910111213141516171819202122ImageAnalysisConfig analysisConfig = new ImageAnalysisConfig.Builder() .setImageReaderMode(ImageAnalysis.ImageReaderMode.ACQUIRE_LATEST_IMAGE) .build();ImageAnalysis imageAnalysis = new ImageAnalysis(analysisConfig);imageAnalysis.setAnalyzer(ContextCompat.getMainExecutor(getApplicationContext()), new LuminosityAnalyzer());CameraX.bindToLifecycle(this, preview, imageCapture, imageAnalysis);...private class LuminosityAnalyzer implements ImageAnalysis.Analyzer &#123; private long lastAnalyzedTimestamp = 0L; @Override public void analyze(ImageProxy image, int rotationDegrees) &#123; final Image img = image.getImage(); if (img != null) &#123; Log.d(&quot;DEBUG&quot;, img.getWidth() + &quot;,&quot; + img.getHeight()); &#125; &#125;&#125; 图片分析，不是必要的步骤，但是ImageAnalysis，可以对每帧图像进行分析。设置参数通过ImageAnalysisConfig.Builder()，这里只设置了ImageReaderMode，它有两种模式： 阻止模式(ImageReaderMode.ACQUIRE_NEXT_IMAGE)：就是Camera2中的acquireNextImage()，获取下一个最新的可用Image 非阻止模式(ImageReaderMode.ACQUIRE_LATEST_IMAGE)：Camera2中的acquireLatestImage()，获得图像队列中最新的图片，并且会清空队列,删除已有的旧的图像 最后还是增加Lifecycle的绑定。CameraX的使用也非常简单，把Camera2中复杂的API封装到统一的config中，只需要几行代码，就实现需要的功能。文章中涉及到的代码 参考 CameraX Android Camera 编程从入门到精通 Google Jetpack 新组件 CameraX 介绍与实践","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"CameraX","slug":"CameraX","permalink":"http://yeungeek.github.io/tags/CameraX/"},{"name":"SurfaceView","slug":"SurfaceView","permalink":"http://yeungeek.github.io/tags/SurfaceView/"},{"name":"TextureView","slug":"TextureView","permalink":"http://yeungeek.github.io/tags/TextureView/"},{"name":"CameraView","slug":"CameraView","permalink":"http://yeungeek.github.io/tags/CameraView/"}]},{"title":"Android Camera-Camera2使用","slug":"AndroidCamera-UsingCamera2","date":"2020-01-19T11:30:54.000Z","updated":"2023-07-31T03:40:56.495Z","comments":true,"path":"2020/01/19/AndroidCamera-UsingCamera2/","link":"","permalink":"http://yeungeek.github.io/2020/01/19/AndroidCamera-UsingCamera2/","excerpt":"上篇文章介绍了Camera1的使用，本篇介绍Camera2的使用。Camera2(android.hardware.camera2)是从 Android 5.0 L 版本开始引入的，并且废弃了旧的相机框架Camera1(android.hardware.Camera)。相比于Camera1，Camera2架构上也发生了变化，API上的使用难度也增加了。Camera2将相机设备模拟成一个管道，它按顺序处理每一帧的请求并返回请求结果给客户端。","text":"上篇文章介绍了Camera1的使用，本篇介绍Camera2的使用。Camera2(android.hardware.camera2)是从 Android 5.0 L 版本开始引入的，并且废弃了旧的相机框架Camera1(android.hardware.Camera)。相比于Camera1，Camera2架构上也发生了变化，API上的使用难度也增加了。Camera2将相机设备模拟成一个管道，它按顺序处理每一帧的请求并返回请求结果给客户端。 设计框架来自官网的模型图，展示了相关的工作流程重新设计 Android Camera API 的目的在于大幅提高应用对于 Android 设备上的相机子系统的控制能力，同时重新组织 API，提高其效率和可维护性。在CaptureRequest中设置不同的Surface用于接收不同的图片数据，最后从不同的Surface中获取到图片数据和包含拍照相关信息的CaptureResult。 优点通过设计框架的改造和优化，Camera2具备了以下优点: 改进了新硬件的性能。Supported Hardware Level的概念，不同厂商对Camera2的支持程度不同，从低到高有LEGACY、LIMITED、FULL 和 LEVEL_3四个级别 以更快的间隔拍摄图像 显示来自多个摄像机的预览 直接应用效果和滤镜 开发流程框架上的变化，对整个使用流程变化也非常大，首先了解一些主要的开发类 类CameraManager相机系统服务，用于管理和连接相机设备 CameraDevice相机设备类，和Camera1中的Camera同级 CameraCharacteristics主要用于获取相机信息，内部携带大量的相机信息，包含摄像头的正反(LENS_FACING)、AE模式、AF模式等，和Camera1中的Camera.Parameters类似 CaptureRequest相机捕获图像的设置请求，包含传感器，镜头，闪光灯等 CaptureRequest.BuilderCaptureRequest的构造器，使用Builder模式，设置更加方便 CameraCaptureSession请求抓取相机图像帧的会话，会话的建立主要会建立起一个通道。一个CameraDevice一次只能开启一个CameraCaptureSession。源端是相机，另一端是 Target，Target可以是Preview，也可以是ImageReader。 ImageReader用于从相机打开的通道中读取需要的格式的原始图像数据，可以设置多个ImageReader。 流程 获取CameraManager1CameraManager cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); 获取相机信息123456789for (String cameraId : cameraManager.getCameraIdList()) &#123; CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId); Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING); if (null != facing &amp;&amp; facing == CameraCharacteristics.LENS_FACING_FRONT) &#123; continue; &#125; ....&#125; 这里默认选择前置摄像头，并获取相关相机信息。 初始化ImageReader12345678mImageReader = ImageReader.newInstance(largest.getWidth(), largest.getHeight(), ImageFormat.JPEG, 2);mImageReader.setOnImageAvailableListener(new ImageReader.OnImageAvailableListener() &#123; @Override public void onImageAvailable(ImageReader reader) &#123; Log.d(&quot;DEBUG&quot;, &quot;##### onImageAvailable: &quot; + mFile.getPath()); mBackgroundHandler.post(new ImageSaver(reader.acquireNextImage(), mFile)); &#125;&#125;, mBackgroundHandler); ImageReader是获取图像数据的重要途径，通过它可以获取到不同格式的图像数据，例如JPEG、YUV、RAW等。通过ImageReader.newInstance(int width, int height, int format, int maxImages)创建ImageReader对象，有4个参数： width：图像数据的宽度 height：图像数据的高度 format：图像数据的格式，例如ImageFormat.JPEG，ImageFormat.YUV_420_888等 maxImages：最大Image个数，Image对象池的大小，指定了能从ImageReader获取Image对象的最大值，过多获取缓冲区可能导致OOM，所以最好按照最少的需要去设置这个值 ImageReader其他相关的方法和回调： ImageReader.OnImageAvailableListener：有新图像数据的回调 acquireLatestImage()：从ImageReader的队列里面，获取最新的Image，删除旧的，如果没有可用的Image，返回null acquireNextImage()：获取下一个最新的可用Image，没有则返回null close()：释放与此ImageReader关联的所有资源 getSurface()：获取为当前ImageReader生成Image的Surface 打开相机设备123456789try &#123; if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) &#123; throw new RuntimeException(&quot;Time out waiting to lock camera opening.&quot;); &#125; cameraManager.openCamera(mCameraId, mStateCallback, mBackgroundHandler);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; cameraManager.openCamera(@NonNull String cameraId,@NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler)的三个参数: cameraId：摄像头的唯一标识 callback：设备连接状态变化的回调 handler：回调执行的Handler对象，传入null则使用当前的主线程Handler 其中callback回调： 123456789101112131415161718192021222324252627private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() &#123; @Override public void onOpened(@NonNull CameraDevice camera) &#123; mCameraOpenCloseLock.release(); mCameraDevice = camera; createCameraPreviewSession(); &#125; @Override public void onDisconnected(@NonNull CameraDevice camera) &#123; mCameraOpenCloseLock.release(); camera.close(); mCameraDevice = null; &#125; @Override public void onError(@NonNull CameraDevice camera, int error) &#123; mCameraOpenCloseLock.release(); camera.close(); mCameraDevice = null; &#125; @Override public void onClosed(@NonNull CameraDevice camera) &#123; super.onClosed(camera); &#125;&#125;; onOpened：表示相机打开成功，可以真正开始使用相机，创建Capture会话 onDisconnected：当相机断开连接时回调该方法，需要进行释放相机的操作 onError：当相机打开失败时，需要进行释放相机的操作 onClosed：调用Camera.close()后的回调方法 创建Capture会话在CameraDevice.StateCallback的onOpened回调中执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void createCameraPreviewSession() &#123; SurfaceTexture texture = mTextureView.getSurfaceTexture(); assert texture != null; texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight()); Surface surface = new Surface(texture); try &#123; mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); mPreviewRequestBuilder.addTarget(surface); // Here, we create a CameraCaptureSession for camera preview. mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()), new CameraCaptureSession.StateCallback() &#123; @Override public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) &#123; // The camera is already closed if (null == mCameraDevice) &#123; return; &#125; // When the session is ready, we start displaying the preview. mCaptureSession = cameraCaptureSession; try &#123; // Auto focus should be continuous for camera preview. mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE); // Flash is automatically enabled when necessary. setAutoFlash(mPreviewRequestBuilder); // Finally, we start displaying the camera preview. mPreviewRequest = mPreviewRequestBuilder.build(); mCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback, mBackgroundHandler); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onConfigureFailed( @NonNull CameraCaptureSession cameraCaptureSession) &#123; Toast.makeText(Camera2Activity.this, &quot;configureFailed&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;, null ); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125;&#125; 这段的代码核心方法是mCameraDevice.createCaptureSession()创建Capture会话，它接受了三个参数： outputs：用于接受图像数据的surface集合，这里传入的是一个preview的surface callback：用于监听 Session 状态的CameraCaptureSession.StateCallback对象 handler：用于执行CameraCaptureSession.StateCallback的Handler对象，传入null则使用当前的主线程Handler 创建CaptureRequestCaptureRequest是向CameraCaptureSession提交Capture请求时的信息载体，其内部包括了本次Capture的参数配置和接收图像数据的Surface。 12mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);mPreviewRequestBuilder.addTarget(surface); 通过CameraDevice.createCaptureRequest()创建CaptureRequest.Builder对象，传入一个templateType参数，templateType用于指定使用何种模板创建CaptureRequest.Builder对象，templateType的取值： TEMPLATE_PREVIEW：预览模式 TEMPLATE_STILL_CAPTURE：拍照模式 TEMPLATE_RECORD：视频录制模式 TEMPLATE_VIDEO_SNAPSHOT：视频截图模式 TEMPLATE_MANUAL：手动配置参数模式 除了模式的配置，CaptureRequest还可以配置很多其他信息，例如图像格式、图像分辨率、传感器控制、闪光灯控制、3A(自动对焦-AF、自动曝光-AE和自动白平衡-AWB)控制等。在createCaptureSession的回调中可以进行设置 12345678// Auto focus should be continuous for camera preview.mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);// Flash is automatically enabled when necessary.setAutoFlash(mPreviewRequestBuilder);// Finally, we start displaying the camera preview.mPreviewRequest = mPreviewRequestBuilder.build(); 代码中设置了AF为设置未图片模式下的连续对焦，并设置自动闪光灯。最后通过build()方法生成CaptureRequest对象。 预览Camera2中，通过连续重复的Capture实现预览功能，每次Capture会把预览画面显示到对应的Surface上。连续重复的Capture操作通过mCaptureSession.setRepeatingRequest(mPreviewRequest,mCaptureCallback, mBackgroundHandler)实现，该方法有三个参数： request：CaptureRequest对象 listener：监听Capture 状态的回调 handler：用于执行CameraCaptureSession.CaptureCallback的Handler对象，传入null则使用当前的主线程Handler 停止预览使用mCaptureSession.stopRepeating()方法。 拍照设置上面的request，session后，就可以真正的开始拍照操作 1mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback, mBackgroundHandler); 该方法也有三个参数，和mCaptureSession.setRepeatingRequest一样： request：CaptureRequest对象 listener：监听Capture 状态的回调 handler：用于执行CameraCaptureSession.CaptureCallback的Handler对象，传入null则使用当前的主线程Handler 这里设置了mCaptureCallback： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private CameraCaptureSession.CaptureCallback mCaptureCallback = new CameraCaptureSession.CaptureCallback() &#123; @Override public void onCaptureProgressed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureResult partialResult) &#123; process(partialResult); &#125; @Override public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) &#123; process(result); &#125; private void process(CaptureResult result) &#123; switch (mState) &#123; case STATE_PREVIEW: &#123; // We have nothing to do when the camera preview is working normally. break; &#125; case STATE_WAITING_LOCK: &#123; Integer afState = result.get(CaptureResult.CONTROL_AF_STATE); Log.d(&quot;DEBUG&quot;, &quot;##### process STATE_WAITING_LOCK: &quot; + afState); if (afState == null) &#123; captureStillPicture(); &#125; else if (CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED == afState || CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED == afState) &#123; // CONTROL_AE_STATE can be null on some devices Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE); if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) &#123; mState = STATE_PICTURE_TAKEN; captureStillPicture(); &#125; else &#123; runPrecaptureSequence(); &#125; &#125; break; &#125; case STATE_WAITING_PRECAPTURE: &#123; // CONTROL_AE_STATE can be null on some devices Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE); if (aeState == null || aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE || aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) &#123; mState = STATE_WAITING_NON_PRECAPTURE; &#125; break; &#125; case STATE_WAITING_NON_PRECAPTURE: &#123; // CONTROL_AE_STATE can be null on some devices Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE); if (aeState == null || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) &#123; mState = STATE_PICTURE_TAKEN; captureStillPicture(); &#125; break; &#125; &#125; &#125;&#125;; 通过设置mState来区分当前状态，是在预览还是拍照 关闭相机退到后台或者当前页面被关闭的时候，已经不需要使用相机了，需要进行相机关闭操作，释放资源， 123456789101112131415161718192021private void closeCamera() &#123; try &#123; mCameraOpenCloseLock.acquire(); if (null != mCaptureSession) &#123; mCaptureSession.close(); mCaptureSession = null; &#125; if (null != mCameraDevice) &#123; mCameraDevice.close(); mCameraDevice = null; &#125; if (null != mImageReader) &#123; mImageReader.close(); mImageReader = null; &#125; &#125; catch (InterruptedException e) &#123; throw new RuntimeException(&quot;Interrupted while trying to lock camera closing.&quot;, e); &#125; finally &#123; mCameraOpenCloseLock.release(); &#125;&#125; 先后对CaptureSession，CameraDevice，ImageReader进行close操作，释放资源。这里仅仅对Camera2基本使用流程做了介绍，一些更高级的用法需要大家自行去实践。在Camera1中需要对画面进行方向矫正，而Camera2是否需要呢，关于相机Orientation相关的知识，通过后面的章节再进行介绍。 文章中涉及到的代码 参考： Camera Detecting camera features with Camera2 Android Camera 编程从入门到精通 Android Camera2 教程 · 第一章 · 概览","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"SurfaceView","slug":"SurfaceView","permalink":"http://yeungeek.github.io/tags/SurfaceView/"},{"name":"TextureView","slug":"TextureView","permalink":"http://yeungeek.github.io/tags/TextureView/"}]},{"title":"Android Camera-Camera1使用","slug":"AndroidCamera-UsingCamera1","date":"2020-01-17T01:32:39.000Z","updated":"2023-07-31T03:40:56.495Z","comments":true,"path":"2020/01/17/AndroidCamera-UsingCamera1/","link":"","permalink":"http://yeungeek.github.io/2020/01/17/AndroidCamera-UsingCamera1/","excerpt":"Android Camera API和Android版本一样，也是碎片化比较严重，所以Google官方推出了CameraView，提供给开发者参考和学习，现在最新的可以使用Jetpack CameraX来开发，大大简化了开发的复杂度。本系列从Camera1-&gt;Camera2-&gt;CameraView-&gt;CameraX，一步步讲解Camera的进化过程，本篇先介绍Camera1的使用。","text":"Android Camera API和Android版本一样，也是碎片化比较严重，所以Google官方推出了CameraView，提供给开发者参考和学习，现在最新的可以使用Jetpack CameraX来开发，大大简化了开发的复杂度。本系列从Camera1-&gt;Camera2-&gt;CameraView-&gt;CameraX，一步步讲解Camera的进化过程，本篇先介绍Camera1的使用。 相机开发的流程： 检测设备摄像头，打开相机 创建预览画面，显示实时预览画面 设置相机参数，进行拍照监听 监听中，保存图片资源或者直接操作原始数据 释放相机资源 上面的是基本的相机开发流程，不同的Camera API在实现上会有不同，整体流程上还是统一的。 Camera1使用权限声明12345&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; 相机必须声明CAMERA权限，在Android6.0上，你还需要在代码中动态申请权限 12ActivityCompat.requestPermissions(this, new String[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_CAMERA_PERMISSION); 开发流程下图是一个开发流程的导览： 打开相机1Camera.open() 该方法的系统源码实现 1234567891011public static Camera open() &#123; int numberOfCameras = getNumberOfCameras(); CameraInfo cameraInfo = new CameraInfo(); for (int i = 0; i &lt; numberOfCameras; i++) &#123; getCameraInfo(i, cameraInfo); if (cameraInfo.facing == CameraInfo.CAMERA_FACING_BACK) &#123; return new Camera(i); &#125; &#125; return null;&#125; 这里会检查可用的摄像头，默认使用的CameraInfo.CAMERA_FACING_BACK后置摄像头 创建预览画面这里使用的是SurfaceView 123456789101112131415161718192021222324252627282930313233343536private SurfaceView mSurfaceView;private SurfaceHolder mSurfaceHolder;...mSurfaceHolder = mSurfaceView.getHolder();mSurfaceHolder.addCallback(new SurfaceHolder.Callback() &#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; ... startPreview(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; releaseCamera(); &#125;&#125;);...private void startPreview() &#123; try &#123; //设置实时预览 mCamera.setPreviewDisplay(mSurfaceHolder); //Orientation setCameraDisplayOrientation(); //开始预览 mCamera.startPreview(); startFaceDetect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 设置预览的时候，可以设置setPreviewCallback监听预览数据的回调 1void onPreviewFrame(byte[] data, Camera camera); 设置相机参数设置相机参数后，需要重新启动预览，这边在初始化的时候，已经设置好了。 1234567891011121314151617private void initParameters(final Camera camera) &#123; mParameters = camera.getParameters(); mParameters.setPreviewFormat(ImageFormat.NV21); //default if (isSupportFocus(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) &#123; mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE); &#125; else if (isSupportFocus(Camera.Parameters.FOCUS_MODE_AUTO)) &#123; mParameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO); &#125; //设置预览图片大小 setPreviewSize(); //设置图片大小 setPictureSize(); camera.setParameters(mParameters);&#125; Camera.Parameters可以设置的参数非常多，这里就介绍几个比较常用的 1.setFocusMode设置对焦模式 FOCUS_MODE_AUTO：自动对焦 FOCUS_MODE_INFINITY：无穷远 FOCUS_MODE_MACRO：微距 FOCUS_MODE_FIXED：固定焦距 FOCUS_MODE_EDOF：景深扩展 FOCUS_MODE_CONTINUOUS_PICTURE：持续对焦(针对照片) FOCUS_MODE_CONTINUOUS_VIDEO：(针对视频) 2.setPreviewSize设置预览图片大小 3.setPreviewFormat支持的格式： ImageFormat.NV16 ImageFormat.NV21 ImageFormat.YUY2 ImageFormat.YV12 ImgaeFormat.RGB_565 ImageFormat.JPEG如果不设置，默认返回NV21的数据 4.setPictureSize设置保存图片的大小 5.setPictureFormat设置保存图片的格式，格式和setPreviewFormat一样 6.setDisplayOrientation设置相机预览画面旋转的角度，degress取值0，90，180，270 7.setPreviewDisplay设置实时预览SurfaceHolder 8.setPreviewCallback监听相机预览数据回调 9.setParameters设置相机的Parameters其他一些设置，大家可以查看Android文档进行相应的设置 设置方向设置相机的预览方向，orientation比较详细的介绍 123456789101112131415161718192021222324252627282930313233private void setCameraDisplayOrientation() &#123; Camera.CameraInfo cameraInfo = new Camera.CameraInfo(); Camera.getCameraInfo(mCameraId, cameraInfo); int rotation = getWindowManager().getDefaultDisplay().getRotation(); //自然方向 int degrees = 0; switch (rotation) &#123; case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break; &#125; int result; //cameraInfo.orientation 图像传感方向 if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123; result = (cameraInfo.orientation + degrees) % 360; result = (360 - result) % 360; &#125; else &#123; result = (cameraInfo.orientation - degrees + 360) % 360; &#125; mOrientation = result; //相机预览方向 mCamera.setDisplayOrientation(result);&#125; 拍照123456789101112131415161718192021private void takePicture() &#123; if (null != mCamera) &#123; mCamera.takePicture(new Camera.ShutterCallback() &#123; @Override public void onShutter() &#123; &#125; &#125;, new Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123; //base data &#125; &#125;, new Camera.PictureCallback() &#123; @Override public void onPictureTaken(final byte[] data, Camera camera) &#123; mCamera.startPreview(); //save data &#125; &#125;); &#125;&#125; takePicture的源码实现： 1234public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback jpeg) &#123; takePicture(shutter, raw, null, jpeg); &#125; shutter(ShutterCallback)：快门按下后的回调 raw(PictureCallback)：raw图像数据 jpeg(PictureCallback)：jpeg图像生成以后的回调 释放相机资源在使用完成后，onPause或者onDestory中进行相机资源的释放 123456789private void releaseCamera() &#123; if (null != mCamera) &#123; mCamera.stopPreview(); mCamera.stopFaceDetection(); mCamera.setPreviewCallback(null); mCamera.release(); mCamera = null; &#125;&#125; stopPreview：停止预览 release：释放资源 Camera1的开发上，还是相对比较简单的，需要定制的功能项比较少，下面一篇开始介绍Camera2的使用。文章中涉及到的代码 参考 Android Camera 编程从入门到精通 Android之Camera1实现相机开发","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"SurfaceView","slug":"SurfaceView","permalink":"http://yeungeek.github.io/tags/SurfaceView/"}]},{"title":"Android Camera-基础知识篇","slug":"AndroidCamera-Basic","date":"2020-01-14T11:49:33.000Z","updated":"2023-07-31T03:40:56.493Z","comments":true,"path":"2020/01/14/AndroidCamera-Basic/","link":"","permalink":"http://yeungeek.github.io/2020/01/14/AndroidCamera-Basic/","excerpt":"现在随着音视频的应用越来越多，直接使用系统原生相机进行拍照裁剪和拍视频，已经不能满足需求了。需要通过Camera API进行自定义相机开发，满足一些复杂的业务场景，开篇先介绍Camera的基础知识，为后面Camera开发提供支持。","text":"现在随着音视频的应用越来越多，直接使用系统原生相机进行拍照裁剪和拍视频，已经不能满足需求了。需要通过Camera API进行自定义相机开发，满足一些复杂的业务场景，开篇先介绍Camera的基础知识，为后面Camera开发提供支持。 基础知识Android Framework提供Camera API来实现拍照与录制视频的功能，目前Android有三类API， Camera此类是用于控制设备相机的旧版 API，现已弃用，在Android5.0以下使用 Camera2此软件包是用于控制设备相机的主要 API，Android5.0以上使用 CameraX基于Camera 2 API封装，简化了开发流程，并增加生命周期控制 相关开发类 android.hardware.camera2控制相机的核心API，使用它可以实现拍照和录制视频的功能。 Camera此类是用于控制设备相机的旧版 API，现已弃用。 SurfaceView此类用于向用户呈现实时相机预览。 TextureView也是用于实时相机预览，Android4.0之后引入 MediaRecorder用于录制视频 IntentMediaStore.ACTION_IMAGE_CAPTURE 或 MediaStore.ACTION_VIDEO_CAPTURE 的 Intent 操作类型可用于捕获图像或视频，而无需直接使用 Camera 对象。 术语 ISO(感光度)CMOS（或胶卷）对光线的敏感程度，用ISO100的胶卷，相机2秒可以正确曝光的话，同样光线条件下用ISO200的胶卷只需要1秒即可，用ISO400则只要0.5秒。常见的标准：ISO100，ISO200，ISO400 曝光时间曝光时间是为了将光投射到相机感光片上，相机快门所要打开至关闭的时间 光圈用来控制光线透过镜头，进入相机内感光面光量的装置 焦距指的是平行的光线穿过镜片后，所汇集的焦点至镜片间之距离。数值越小，代表可以拍摄的角度越广，数值越大，代表可以拍摄的角度越小 景深拍摄时，当镜头聚集于某个被摄体时，这个被摄体就能在相机上结成清晰影像。使被摄体产生较为清晰影像的纵深的范围叫景深 测光测光模式：中央平均测光(average metering)、中央局部测光、点测光(spot metering)、多点测光、评价测光 自动曝光(Auto Exposure)相机根据光线条件自动来调整曝光时间等来确定曝光量 对焦对焦模式：自动对焦 AE(Auto Focus)、手动对焦 MF(Manual Focus)自动对焦分为对比度对焦(contrast)、相位对焦(PDAF: Phase Detection Auto Focus)和混合对焦(hybrid) 闪光灯(Flashlight)通过闪光灯打闪照亮物体来达到拍出清晰图片的目的 ScreenFlash通过屏幕打闪，照亮周围物体，拍出高清图片 高动态范围图像(HDR)HDR全称是High-Dynamic Range，即高动态范围图像技术。在拍照过程中开启HDR，可以让原先的暗场景变得更明亮更通透。 零延时拍照(ZSD)为了减少拍照延时,让拍照&amp;回显瞬间完成的一种技术 连拍(ContinuousShot)通过节约数据传输时间来捕捉摄影时机 预览大小(PreviewSize)相机预览图片的大小 拍照大小(PictureSize)拍照生成图片的大小 自动白平衡(Auto white balance)AWB(Auto white balance)，自动白平衡是相机的默认设置，相机中有一结构复杂的矩形图，它可决定画面中的白平衡基准点，以此来达到白平衡调校 对比度图像最亮和最暗之间的区域之间的比率，比值越大，从黑到白的渐变层次就越多，从而色彩表现越丰富 饱和度指色彩的鲜艳程度 锐度是反映图像平面清晰度和图像边缘锐利程度的一个指标 相机功能Android 支持多种相机功能，您可使用相机应用控制这些功能，如图片格式、闪光模式、对焦设置等等。通过Camera.Parameters可以设置大部分的功能，下面介绍几个重要功能： 区域测光和对焦 人脸检测 延时视频 区域测光和对焦从 Android 4.0（API 级别 14）开始，通过Camera.Parameters来确定对焦或亮度设置的区域，然后进行拍照或者录像 人脸检测这个和真正的人脸识别是不一样的 ，这里仅仅是检测人脸。通过照片分析，检测照片中是否包含人脸，使用人脸识别技术来识别人脸并计算照片设置 延时视频延时视频功能允许用户将间隔几秒钟或几分钟拍摄的图片串联起来，创建视频剪辑。使用MediaRecorder录制时间流逝片段的图像。 其他重要功能API： 参考 CameraX Camera Detecting camera features with Camera2 Android相机开发 - 1)基础概览篇 Android之Camera1实现相机开发","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"CameraX","slug":"CameraX","permalink":"http://yeungeek.github.io/tags/CameraX/"}]},{"title":"Android Camera-系列文章","slug":"AndroidCamera-Series","date":"2020-01-13T02:44:49.000Z","updated":"2023-07-31T03:40:56.495Z","comments":true,"path":"2020/01/13/AndroidCamera-Series/","link":"","permalink":"http://yeungeek.github.io/2020/01/13/AndroidCamera-Series/","excerpt":"最近比较忙，文章也很久没有更新了。最近项目中用到Camera，做了一些功能，发现Camera涉及到很多内容，可以做成一个系列来分析。随着5G时代的到来，音视频相关的内容，会越来越流行，而Camera应该算是最基础的设施了，所以接下来会对Camera这块进行分析，通过下面这些文章，可以对Camera有个更深入的理解。","text":"最近比较忙，文章也很久没有更新了。最近项目中用到Camera，做了一些功能，发现Camera涉及到很多内容，可以做成一个系列来分析。随着5G时代的到来，音视频相关的内容，会越来越流行，而Camera应该算是最基础的设施了，所以接下来会对Camera这块进行分析，通过下面这些文章，可以对Camera有个更深入的理解。 系列文章目录 Camera基础知识 Camera1使用 Camera2使用 CameraView和AndroidX使用 相机尺寸、方向和图像数据 CameraView源码分析 CameraX源码分析 参考 Android Camera CameraX Android Camera 编程从入门到精通","categories":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"CameraX","slug":"CameraX","permalink":"http://yeungeek.github.io/tags/CameraX/"}]},{"title":"Android NDK-深入理解JNI","slug":"AndroidNDK-DeepUnderstandJNI","date":"2019-08-21T03:21:43.000Z","updated":"2023-07-31T03:40:56.495Z","comments":true,"path":"2019/08/21/AndroidNDK-DeepUnderstandJNI/","link":"","permalink":"http://yeungeek.github.io/2019/08/21/AndroidNDK-DeepUnderstandJNI/","excerpt":"Java调用C&#x2F;C++在Java语言里面本来就有的，并非Android独有的，即JNI。JNI就是Java调用C++的规范。","text":"Java调用C&#x2F;C++在Java语言里面本来就有的，并非Android独有的，即JNI。JNI就是Java调用C++的规范。 JNI 概述JNI，全称为Java Native Interface，即Java本地接口，JNI是Java调用Native语言的一种特性，通过JNI可以使JAVA和 C&#x2F;C++进行交互。Java语言是跨平台的语言，而这跨平台的背后都是依靠Java虚拟机，虚拟机采用C&#x2F;C++编写，适配各个系统，通过JNI为上层Java提供各种服务，保证跨平台性。在Java语言出现前，就有很多程序和库都是由Native语言写的，如果想重复利用这些库，就可以所使用JNI来实现。在Android平台上，JNI就是一座将Java世界和Native世界联通的一座桥梁。通过JNI，Java世界和Native世界的代码就可以相互访问了。 JNI实例：Camera最新有在看系统的Camera相关，所以从系统Camera角度来分析下JNI的应用，下面讲的实例基于Camera2 Android5.0(21)之后android.hardware.Camera就被废弃了，取而代之的是全新的android.hardware.Camera2 相关代码： 1234frameworks/base/core/jni/AndroidRuntime.cppframeworks/base/core/java/android/hardware/camera2/impl/CameraMetadataNative.javaframeworks/base/core/jni/android_hardware_camera2_CameraMetadata.cpp Camera2 Java层对应的是CameraMetadataNative.java，Native层对应的是android_hardware_camera2_CameraMetadata.cpp Java层CameraMetadataNative相关代码在CameraMetadataNative.javaCamera2使用CameraManager(摄像头管理器)进行控制，CameraManager具体的操作会通过CameraMetadataNative来执行。CameraMetadataNative的初始化 12345678910public class CameraMetadataNative implements Parcelable static &#123; /* * We use a class initializer to allow the native code to cache some field offsets */ nativeClassInit(); registerAllMarshalers(); &#125; private static native void nativeClassInit();&#125; 静态方法初始化调用了Native层的方法nativeClassInit，这个方法对应的Native层具体实现，是在android_hardware_camera2_CameraMetadata.cpp Native层CameraMetadataNative层相关代码在android_hardware_camera2_CameraMetadata.cppNative方法初始化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static const JNINativeMethod gCameraMetadataMethods[] = &#123;// static methods &#123; &quot;nativeClassInit&quot;, &quot;()V&quot;, (void *)CameraMetadata_classInit &#125;, //和Java层nativeClassInit()对应 &#123; &quot;nativeGetAllVendorKeys&quot;, &quot;(Ljava/lang/Class;)Ljava/util/ArrayList;&quot;, (void *)CameraMetadata_getAllVendorKeys&#125;, &#123; &quot;nativeGetTagFromKey&quot;, &quot;(Ljava/lang/String;)I&quot;, (void *)CameraMetadata_getTagFromKey &#125;, &#123; &quot;nativeGetTypeFromTag&quot;, &quot;(I)I&quot;, (void *)CameraMetadata_getTypeFromTag &#125;, &#123; &quot;nativeSetupGlobalVendorTagDescriptor&quot;, &quot;()I&quot;, (void*)CameraMetadata_setupGlobalVendorTagDescriptor &#125;,// instance methods &#123; &quot;nativeAllocate&quot;, &quot;()J&quot;, (void*)CameraMetadata_allocate &#125;, &#123; &quot;nativeAllocateCopy&quot;, &quot;(L&quot; CAMERA_METADATA_CLASS_NAME &quot;;)J&quot;, (void *)CameraMetadata_allocateCopy &#125;, &#123; &quot;nativeIsEmpty&quot;, &quot;()Z&quot;, (void*)CameraMetadata_isEmpty &#125;, &#123; &quot;nativeGetEntryCount&quot;, &quot;()I&quot;, (void*)CameraMetadata_getEntryCount &#125;, &#123; &quot;nativeClose&quot;, &quot;()V&quot;, (void*)CameraMetadata_close &#125;, &#123; &quot;nativeSwap&quot;, &quot;(L&quot; CAMERA_METADATA_CLASS_NAME &quot;;)V&quot;, (void *)CameraMetadata_swap &#125;, &#123; &quot;nativeReadValues&quot;, &quot;(I)[B&quot;, (void *)CameraMetadata_readValues &#125;, &#123; &quot;nativeWriteValues&quot;, &quot;(I[B)V&quot;, (void *)CameraMetadata_writeValues &#125;, &#123; &quot;nativeDump&quot;, &quot;()V&quot;, (void *)CameraMetadata_dump &#125;,// Parcelable interface &#123; &quot;nativeReadFromParcel&quot;, &quot;(Landroid/os/Parcel;)V&quot;, (void *)CameraMetadata_readFromParcel &#125;, &#123; &quot;nativeWriteToParcel&quot;, &quot;(Landroid/os/Parcel;)V&quot;, (void *)CameraMetadata_writeToParcel &#125;,&#125;; gCameraMetadataMethods什么时候会被加载？ 12345678910111213141516int register_android_hardware_camera2_CameraMetadata(JNIEnv *env)&#123; ...... // Register native functions return RegisterMethodsOrDie(env, CAMERA_METADATA_CLASS_NAME, gCameraMetadataMethods, NELEM(gCameraMetadataMethods));&#125;......static inline int RegisterMethodsOrDie(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) &#123; int res = AndroidRuntime::registerNativeMethods(env, className, gMethods, numMethods); LOG_ALWAYS_FATAL_IF(res &lt; 0, &quot;Unable to register native methods.&quot;); return res;&#125; register_android_hardware_camera2_CameraMetadata何时会被调用到，这个就需要了解下JNI的查找方式。 JNI查找方式 Android系统在启动启动过程中，先启动Kernel创建init进程，紧接着由init进程fork第一个横穿Java和C&#x2F;C++的进程，即Zygote进程。Zygote启动过程中会AndroidRuntime.cpp中的startVm创建虚拟机，VM创建完成后，紧接着调用startReg完成虚拟机中的JNI方法注册。 刚才CameraMetadata中register_android_hardware_camera2_CameraMetadata方法，在AndroidRuntime.cpp的声明： 1extern int register_android_hardware_camera2_CameraMetadata(JNIEnv *env); 然后在gRegJNI中的静态声明 12345static const RegJNIRec gRegJNI[] = &#123; ...... REG_JNI(register_android_hardware_camera2_CameraMetadata), ......&#125; gRegJNI方法在startReg中被调用 1234567891011121314151617/*static*/ int AndroidRuntime::startReg(JNIEnv* env)&#123; ATRACE_NAME(&quot;RegisterAndroidNatives&quot;); androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(&quot;--- registering native functions ---\\n&quot;); env-&gt;PushLocalFrame(200); if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); //createJavaThread(&quot;fubar&quot;, quickTest, (void*) &quot;hello&quot;); return 0;&#125; register_jni_procs(gRegJNI, NELEM(gRegJNI), env)会循环调用gRegJNI数组成员所对应的方法 123456789101112static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)&#123; for (size_t i = 0; i &lt; count; i++) &#123; if (array[i].mProc(env) &lt; 0) &#123;#ifndef NDEBUG ALOGD(&quot;----------!!! %s failed to load\\n&quot;, array[i].mName);#endif return -1; &#125; &#125; return 0;&#125; 这样android_hardware_camera2_CameraMetadata.cpp中的int register_android_hardware_camera2_CameraMetadata(JNIEnv *env)就会被调用到。除了这种Android系统启动时，就注册JNI所对应的方法。还有一种就是程序自定义的JNI方法，以 MediePlay 为例：相关代码路径 12frameworks/base/media/java/android/media/MediaPlayer.javaframeworks/base/media/jni/android_media_MediaPlayer.cpp MediaPlayer声明： 1234567891011public class MediaPlayer extends PlayerBase implements SubtitleController.Listener&#123; ...... private static native final void native_init(); ...... static &#123; System.loadLibrary(&quot;media_jni&quot;); native_init(); &#125;&#125; 静态代码块中使用System.loadLibrary加载动态库，media_jni在Android平台对应的是libmedia_jni.so库。在jni目录/frameworks/base/media/jni/Android.mk中有相应的声明： 1234LOCAL_SRC_FILES:= \\android_media_MediaPlayer.cpp \\...LOCAL_MODULE:= libmedia_jni 在android_media_MediaPlayer.cpp找到对应的Native(natvie_init)方法： 1234567891011static voidandroid_media_MediaPlayer_native_init(JNIEnv *env)&#123; jclass clazz; clazz = env-&gt;FindClass(&quot;android/media/MediaPlayer&quot;); if (clazz == NULL) &#123; return; &#125; ......&#125; JNI注册的方法就是上面描述的两种方法： 在Android系统启动时注册，在AndroidRuntime.cpp中的gRegJNI方法中声明 使用System.loadLibrary()方式注册 JNI基础上面一节主要描述了系统中Java层和Native层交互和实现，并没有对JNI的基础理论，流程进行分析 JNI命名规则JNI方法名规范 : 1返回值 + Java前缀 + 全路径类名 + 方法名 + 参数① JNIEnv + 参数② jobject + 其它参数 简单的一个例子，返回一个字符串 123456extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_yeungeek_jnisample_NativeHelper_stringFromJNI(JNIEnv *env, jclass jclass1) &#123; LOGD(&quot;##### from c&quot;); return env-&gt;NewStringUTF(&quot;Hello JNI&quot;);&#125; 返回值：jstring 全路径类名：com_yeungeek_jnisample_NativeHelper 方法名：stringFromJNI JNI开发流程 在Java中先声明一个native方法 编译Java源文件javac得到.class文件 通过javah -jni命令导出JNI的.h头文件 使用Java需要交互的本地代码，实现在Java中声明的Native方法（如果Java需要与C++交互，那么就用C++实现Java的Native方法。） 将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib) 通过Java命令执行Java程序，最终实现Java调用本地代码。 数据类型基本数据类型 Signature Java Native B byte jbyte C char jchar D double jdouble F float jfloat I int jint S short jshort J long jlong Z boolean jboolean V void jvoid 引用数据类型 Signature Java Native L+classname +; Object jobject Ljava&#x2F;lang&#x2F;String; String jstring [L+classname +; Object[] jobjectArray Ljava.lang.Class; Class jclass Ljava.lang.Throwable; Throwable jthrowable [B byte[] jbyteArray [C char[] jcharArray [D double[] jdoubleArray [F float[] jfloatArray [I int[] jintArray [S short[] jshortArray [J long[] jlongArray [Z boolean[] jbooleanArray 方法签名JNI的方法签名的格式： 1(参数签名格式...)返回值签名格式 demo的native 方法： 1public static native java.lang.String stringFromJNI(); 可以通过javap命令生成方法签名&#96;&#96;： 1()Ljava/lang/String; JNI原理Java语言的执行环境是Java虚拟机(JVM)，JVM其实是主机环境中的一个进程，每个JVM虚拟机都在本地环境中有一个JavaVM结构体，该结构体在创建Java虚拟机时被返回，在JNI环境中创建JVM的函数为JNI_CreateJavaVM。JNI 定义了两个关键数据结构，即“JavaVM”和“JNIEnv”，两者本质上都是指向函数表的二级指针。 JavaVMJavaVM是Java虚拟机在JNI层的代表，JavaVM 提供了“调用接口”函数，您可以利用此类函数创建和销毁 JavaVM。理论上，每个进程可以包含多个JavaVM，但AnAndroid只允许每个进程包含一个JavaVM。 JNIEnvJNIEnv是一个线程相关的结构体，该结构体代表了Java在本线程的执行环境。JNIEnv 提供了大多数 JNI 函数。您的原生函数均会接收 JNIEnv 作为第一个参数。JNIEnv作用： 调用Java函数 操作Java代码 JNIEnv定义(jni.h)：libnativehelper/include/nativehelper/jni.h 1234567#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM; #elsetypedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif 定义中可以看到JavaVM，Android中一个进程只会有一个JavaVM，一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构 注册JNI函数Java世界和Native世界的方法是如何关联的，就是通过JNI函数注册来实现。JNI函数注册有两种方式： 静态注册这种方法就是通过函数名来找对应的JNI函数，可以通过javah命令行来生成JNI头文件 1javah com.yeungeek.jnisample.NativeHelper 生成对应的com_yeungeek_jnisample_NativeHelper.h文件，生成对应的JNI函数，然后在实现这个函数就可以了 1234567/* * Class: com_yeungeek_jnisample_NativeHelper * Method: stringFromJNI * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI (JNIEnv *, jclass); 静态注册方法中，Native是如何找到对应的JNI函数，在JNI查找方式中介绍系统的流程，并没有详细说明静态注册的查找。这里简单说明下这个过程(以上面的声明为例子s)：当Java调用native stringFromJNI函数时，会从对应JNI库中查找Java_com_yeungeek_jnisample_NativeHelper_stringFromJNI函数，如果没有找到，就会报错。静态注册方法，就是根据函数名来关联Java函数和JNI函数，JNI函数需要遵循特定的格式，这其中就有一些缺点： 声明了native方法的Java类，需要通过javah来生成头文件 JNI函数名称非常长 第一次调用native函数，需要通过函数名来搜索关联对应的JNI函数，效率比较低 如何解决这些问题，让native函数，提前知道JNI函数，就可以解决这个问题，这个过程就是动态注册。 动态注册动态注册在前面的Camera例子中，已经有涉及到，JNI函数classInit的声明。 1234567static const JNINativeMethod gCameraMetadataMethods[] = &#123;// static methods &#123; &quot;nativeClassInit&quot;, &quot;()V&quot;, (void *)CameraMetadata_classInit &#125;, //和Java层nativeClassInit()对应 ......&#125; JNI中有一种结构用来记录Java的Native方法和JNI方法的关联关系，它就是JNINativeMethod，它在jni.h中被定义： 12345typedef struct &#123; const char* name; //Java层native函数名 const char* signature; //Java函数签名，记录参数类型和个数，以及返回值类型 void* fnPtr; //Native层对应的函数指针&#125; JNINativeMethod; 在JNI查找方式说到，JNI注册的两种时间，第一种已经介绍过了，我们自定义的native函数，基本都是会使用System.loadLibrary(“xxx”)，来进行JNI函数的关联。 loadLibrary(Android7.0)123public static void loadLibrary(String libname) &#123; Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);&#125; 调用到Runtime(libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java)的loadLibrary0方法： 123456789101112131415161718192021222324252627282930313233343536synchronized void loadLibrary0(ClassLoader loader, String libname) &#123; ...... String libraryName = libname; if (loader != null) &#123; String filename = loader.findLibrary(libraryName); if (filename == null) &#123; // It&#x27;s not necessarily true that the ClassLoader used // System.mapLibraryName, but the default setup does, and it&#x27;s // misleading to say we didn&#x27;t find &quot;libMyLibrary.so&quot; when we // actually searched for &quot;liblibMyLibrary.so.so&quot;. throw new UnsatisfiedLinkError(loader + &quot; couldn&#x27;t find \\&quot;&quot; + System.mapLibraryName(libraryName) + &quot;\\&quot;&quot;); &#125; //doLoad String error = doLoad(filename, loader); if (error != null) &#123; throw new UnsatisfiedLinkError(error); &#125; return; &#125; //loader 为 null ...... for (String directory : getLibPaths()) &#123; String candidate = directory + filename; candidates.add(candidate); if (IoUtils.canOpenReadOnly(candidate)) &#123; String error = doLoad(candidate, loader); if (error == null) &#123; return; // We successfully loaded the library. Job done. &#125; lastError = error; &#125; &#125; ......&#125; doLoad123456private String doLoad(String name, ClassLoader loader) &#123; //调用 native 方法 synchronized (this) &#123; return nativeLoad(name, loader, librarySearchPath); &#125;&#125; nativeLoad进入到虚拟机代码/libcore/ojluni/src/main/native/Runtime.c 123456JNIEXPORT jstring JNICALLRuntime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename, jobject javaLoader, jstring javaLibrarySearchPath)&#123; return JVM_NativeLoad(env, javaFilename, javaLoader, javaLibrarySearchPath);&#125; 然后调用JVM_NativeLoad，JVM_NativeLoad方法申明在jvm.h中，实现在OpenjdkJvm.cc(/art/runtime/openjdkjvm/OpenjdkJvm.cc) 1234567891011121314151617181920212223242526JNIEXPORT jstring JVM_NativeLoad(JNIEnv* env, jstring javaFilename, jobject javaLoader, jstring javaLibrarySearchPath) &#123; ScopedUtfChars filename(env, javaFilename); if (filename.c_str() == NULL) &#123; return NULL; &#125; std::string error_msg; &#123; art::JavaVMExt* vm = art::Runtime::Current()-&gt;GetJavaVM(); bool success = vm-&gt;LoadNativeLibrary(env, filename.c_str(), javaLoader, javaLibrarySearchPath, &amp;error_msg); if (success) &#123; return nullptr; &#125; &#125; // Don&#x27;t let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF. env-&gt;ExceptionClear(); return env-&gt;NewStringUTF(error_msg.c_str());&#125; LoadNativeLibrary调用JavaVMExt的LoadNativeLibrary方法，方法在(art&#x2F;runtime&#x2F;java_vm_ext.cc)中，这个方法代码非常多，选取主要的部分进行分析 12345678910111213141516171819202122232425262728293031323334353637bool JavaVMExt::LoadNativeLibrary(JNIEnv* env, const std::string&amp; path, jobject class_loader, jstring library_path, std::string* error_msg) &#123; ...... bool was_successful = false; //加载so库中查找JNI_OnLoad方法，如果没有系统就认为是静态注册方式进行的，直接返回true，代表so库加载成功， //如果找到JNI_OnLoad就会调用JNI_OnLoad方法，JNI_OnLoad方法中一般存放的是方法注册的函数， //所以如果采用动态注册就必须要实现JNI_OnLoad方法，否则调用java中申明的native方法时会抛出异常 void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr); if (sym == nullptr) &#123; VLOG(jni) &lt;&lt; &quot;[No JNI_OnLoad found in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;; was_successful = true; &#125; else &#123; // Call JNI_OnLoad. We have to override the current class // loader, which will always be &quot;null&quot; since the stuff at the // top of the stack is around Runtime.loadLibrary(). (See // the comments in the JNI FindClass function.) ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride())); self-&gt;SetClassLoaderOverride(class_loader); VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;; typedef int (*JNI_OnLoadFn)(JavaVM*, void*); JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym); //调用JNI_OnLoad方法 int version = (*jni_on_load)(this, nullptr); if (runtime_-&gt;GetTargetSdkVersion() != 0 &amp;&amp; runtime_-&gt;GetTargetSdkVersion() &lt;= 21) &#123; // Make sure that sigchain owns SIGSEGV. EnsureFrontOfChain(SIGSEGV); &#125; self-&gt;SetClassLoaderOverride(old_class_loader.get()); &#125; ......&#125; 代码里的主要逻辑： 加载so库中查找JNI_OnLoad方法，如果没有系统就认为是静态注册方式进行的，直接返回true，代表so库加载成功 如果找到JNI_OnLoad就会调用JNI_OnLoad方法，JNI_OnLoad方法中一般存放的是方法注册的函数 所以如果采用动态注册就必须要实现JNI_OnLoad方法，否则调用Java中的native方法时会抛出异常 jclass、jmethodID和jfieldID如果要通过原生代码访问对象的字段，需要执行以下操作： 使用 FindClass 获取类的类对象引用 使用 GetFieldID 获取字段的字段 ID 使用适当内容获取字段的内容，例如 GetIntField 具体的使用，放在第二篇文章中讲解 JNI的引用JNI规范中定义了三种引用： 局部引用（Local Reference） 全局引用（Global Reference） 弱全局引用（Weak Global Reference） 局部引用也叫本地引用，在 JNI层函数使用的非全局引用对象都是Local Reference，最大的特点就是，JNI 函数返回后，这些声明的引用可能就会被垃圾回收 全局引用这种声明的对象，不会主动释放资源，不会被垃圾回收 弱全局引用一种特殊的全局引用，在运行过程中可能被回收，使用之前需要判断下是否为空 参考 Android：清晰讲解JNI 与 NDK（含实例教学） Android JNI学习 Android JNI原理分析 Android深入理解JNI（一）JNI原理与静态、动态注册 JNI Tips","categories":[{"name":"Android框架层","slug":"Android框架层","permalink":"http://yeungeek.github.io/categories/Android%E6%A1%86%E6%9E%B6%E5%B1%82/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"http://yeungeek.github.io/tags/JNI/"},{"name":"NDK","slug":"NDK","permalink":"http://yeungeek.github.io/tags/NDK/"}]},{"title":"Android网络编程-Retrofit源码角度分析Http","slug":"Network-Retrofit","date":"2019-07-25T11:31:38.000Z","updated":"2023-07-31T03:40:56.496Z","comments":true,"path":"2019/07/25/Network-Retrofit/","link":"","permalink":"http://yeungeek.github.io/2019/07/25/Network-Retrofit/","excerpt":"上一篇讲解了OKHttp，本篇来介绍下它的黄金搭档Retrofit，OKHttp+Retrofit是网络框架的不二之选。同是Square出品，和OKHttp融合起来非常简单。Retofit是一个RESTful的HTTP网络请求框架，有以下特点： 基于OKHttp 通过注解配置网络请求参数 支持同步、异步请求 支持多种序列化、反序列化格式 解耦彻底、模块高度封装，使用很多设计模式来实现","text":"上一篇讲解了OKHttp，本篇来介绍下它的黄金搭档Retrofit，OKHttp+Retrofit是网络框架的不二之选。同是Square出品，和OKHttp融合起来非常简单。Retofit是一个RESTful的HTTP网络请求框架，有以下特点： 基于OKHttp 通过注解配置网络请求参数 支持同步、异步请求 支持多种序列化、反序列化格式 解耦彻底、模块高度封装，使用很多设计模式来实现 基本使用下面讲解的是官网的例子 创建网络请求接口1234public interface GitHubService &#123; @GET(&quot;users/&#123;user&#125;/repos&quot;) Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);&#125; 创建Retrofit实例(使用建造者模式)1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.github.com/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); 创建网络接口实例123GitHubService service = retrofit.create(GitHubService.class);Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;yeungeek&quot;); 发送网络请求默认返回的是OKHttpCall，实际真正发送请求的就是OKHttp 同步1Response&lt;List&lt;Repo&gt;&gt; list = repos.execute() 异步123456789call.enqueue(new Callback&lt;List&lt;Repo&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Repo&gt;&gt; call, Response&lt;List&lt;Repo&gt;&gt; response) &#123; &#125; @Override public void onFailure(Call&lt;List&lt;Repo&gt;&gt; call, Throwable t) &#123; &#125;&#125;); 请求流程具体的请求流程可以分为7大步骤 解析网络请求接口的注解，配置网络请求参数 通过动态代理生成网络请求对象 通过CallAdapter，将网络请求对象进行平台适配(Android,Java8) 通过网络请求执行器(Call)，发送网络请求 通过Converter进行数据解析 通过回调执行器，进行线程切换 在主线程处理返回结果 Refrofit最大特点是使用了大量的设计模式，来进行解耦，下图是完整的流程图(来自Stay 在 Retrofit分析-漂亮的解耦套路)：接下来通过源码分析，详细讲解上面的流程 源码分析Retrofit初始化123456Retrofit retrofit = new Retrofit //1. Retrofit声明 .Builder() //2. Builder .baseUrl(&quot;https://api.github.com/&quot;) //3. baseUrl .addConverterFactory(GsonConverterFactory.create()) //4. Converter Factory .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) //5. CallAdapter Factory .build(); //6. 生成实例 Retrofit声明在使用Retrofit时，首先通过建造者模式构建Retrofit。 12345678910111213141516171819202122public final class Retrofit &#123; private final Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;(); final okhttp3.Call.Factory callFactory; final HttpUrl baseUrl; final List&lt;Converter.Factory&gt; converterFactories; final List&lt;CallAdapter.Factory&gt; callAdapterFactories; final @Nullable Executor callbackExecutor; final boolean validateEagerly; Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; callAdapterFactories, @Nullable Executor callbackExecutor, boolean validateEagerly) &#123; this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = converterFactories; // Copy+unmodifiable at call site. this.callAdapterFactories = callAdapterFactories; // Copy+unmodifiable at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; &#125; ......&#125; serviceMethodCache：网络请求配置对象缓存，通过解析网络请求接口后得到请求对象 callFactory：网络请求器工厂(Call)，默认实现是OKHttp baseUrl：网络请求Url地址 converterFactories：数据转换器工厂集合 callAdapterFactories：请求适配器工厂集合 callbackExecutor：回调方法执行器 validateEagerly：是否提前验证请求方法 剩下的步骤都是来初始化上面的参数 Builder123456789101112131415161718public static final class Builder &#123; private final Platform platform; private @Nullable okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(); private @Nullable Executor callbackExecutor; private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform; &#125; public Builder() &#123; this(Platform.get()); &#125; ......&#125; Builder中的参数和 Retrfit 是意义一一对应的，默认构造函数进行平台的选择 123456789101112131415161718192021222324class Platform &#123; private static final Platform PLATFORM = findPlatform(); static Platform get() &#123; return PLATFORM; &#125; private static Platform findPlatform() &#123; try &#123; Class.forName(&quot;android.os.Build&quot;); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName(&quot;java.util.Optional&quot;); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform(); &#125; ......&#125; 通过反射来判断选择Android还是Java8，以前版本还有对IOS平台的支持，最新版本已经去掉了。我们看下Android平台： 1234567891011121314151617181920static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; //默认回调执行器，会切换到主线程 return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); //默认的 CallAdapter return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125; &#125; baseUrl12345678910111213141516171819public Builder baseUrl(String baseUrl) &#123; checkNotNull(baseUrl, &quot;baseUrl == null&quot;); HttpUrl httpUrl = HttpUrl.parse(baseUrl); if (httpUrl == null) &#123; throw new IllegalArgumentException(&quot;Illegal URL: &quot; + baseUrl); &#125; return baseUrl(httpUrl); &#125;......public Builder baseUrl(HttpUrl baseUrl) &#123; checkNotNull(baseUrl, &quot;baseUrl == null&quot;); List&lt;String&gt; pathSegments = baseUrl.pathSegments(); //检查合法性 if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) &#123; throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; + baseUrl); &#125; this.baseUrl = baseUrl; return this;&#125; 把String url 转换成HttpUrl，会对baseUrl进行合法性校验(URL参数是不是以”&#x2F;“结尾) ConverterFactory1234public Builder addConverterFactory(Converter.Factory factory) &#123; converterFactories.add(checkNotNull(factory, &quot;factory == null&quot;)); return this; &#125; 把factory加到数据转换器集合中，看下GsonFactory.create()具体的实现： 123456789101112131415161718192021222324public static GsonConverterFactory create(Gson gson) &#123; if (gson == null) throw new NullPointerException(&quot;gson == null&quot;); return new GsonConverterFactory(gson);&#125;private final Gson gson;private GsonConverterFactory(Gson gson) &#123; this.gson = gson;&#125;@Overridepublic Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter);&#125;@Overridepublic Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonRequestBodyConverter&lt;&gt;(gson, adapter);&#125; GsonConverterFactory使用Gson 为初始化参数，实现responseBodyConverter和requestBodyConverter接口，进行真正的数据转换处理。 CallAdapterFactory1234public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123; callAdapterFactories.add(checkNotNull(factory, &quot;factory == null&quot;)); return this;&#125; 把factory加到请求适配器工厂集合中，Android 平台默认实现是ExecutorCallAdapterFactory，后面再进行详细讲解。 build最后一步build生成Retrofit对象 12345678910111213141516171819202122232425262728293031public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException(&quot;Base URL required.&quot;); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(1 + this.converterFactories.size()); // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);&#125; callFactory配置，默认OkHttpClient callbackExecutor配置，Android 平台默认使用MainThreadExecutor callAdapterFactories配置，先加入自定义的callAdapter，然后再加入defaultCallAdapterFactory converterFactories配置，先加入内建转换器(BuiltInConverters)，然后加入自定义的数据转换器 生成Retrofit对象 创建网络接口实例12345678public interface GitHubService &#123; @GET(&quot;users/&#123;user&#125;/repos&quot;) Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);&#125;//创建接口实例GitHubService service = retrofit.create(GitHubService.class);//生成请求对象Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;yeungeek&quot;); Retrofit通过外观模式和动态代理生成网络接口实例，网络接口的请求参数从接口声明获取 create123456789101112131415161718192021222324public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.adapt(okHttpCall); &#125; &#125;);&#125; create方法中最重要的是使用了动态代理，调用接口的方法都会到Proxy的invoke方法中，在invoke方法中最重要的就是下面三行代码 1234ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.adapt(okHttpCall); loadServiceMethod该方法读取网络请求接口里的方法，根据配置生成ServiceMethod对象 123456789101112ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; loadServiceMethod会先从cache中获取对象，如果获取不到，则通过建造者模式生成ServiceMethod对象。 1new ServiceMethod.Builder&lt;&gt;(this, method).build(); ServiceMethod123456789101112131415161718192021222324252627282930313233343536final class ServiceMethod&lt;R, T&gt; &#123; // Upper and lower characters, digits, underscores, and hyphens, starting with a character. static final String PARAM = &quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;; static final Pattern PARAM_URL_REGEX = Pattern.compile(&quot;\\\\&#123;(&quot; + PARAM + &quot;)\\\\&#125;&quot;); static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM); private final okhttp3.Call.Factory callFactory; private final CallAdapter&lt;R, T&gt; callAdapter; private final HttpUrl baseUrl; private final Converter&lt;ResponseBody, R&gt; responseConverter; private final String httpMethod; private final String relativeUrl; private final Headers headers; private final MediaType contentType; private final boolean hasBody; private final boolean isFormEncoded; private final boolean isMultipart; private final ParameterHandler&lt;?&gt;[] parameterHandlers; ServiceMethod(Builder&lt;R, T&gt; builder) &#123; this.callFactory = builder.retrofit.callFactory(); this.callAdapter = builder.callAdapter; this.baseUrl = builder.retrofit.baseUrl(); this.responseConverter = builder.responseConverter; this.httpMethod = builder.httpMethod; this.relativeUrl = builder.relativeUrl; this.headers = builder.headers; this.contentType = builder.contentType; this.hasBody = builder.hasBody; this.isFormEncoded = builder.isFormEncoded; this.isMultipart = builder.isMultipart; this.parameterHandlers = builder.parameterHandlers; &#125; ......&#125; callFactory：网络请求器工厂，和retrofit对象声明中的含义一样 callAdapter：网络请求适配器工厂 baseUrl：网络请求Url地址 responseConverter：Response 数据转换器 httpMethod：http 请求方法 relativeUrl：网络请求相对地址 headers：网络请求头 contentType：网络请求 body 类型 parameterHandlers：方法处理解析器 ServiceMethod.Builder1234567Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method; this.methodAnnotations = method.getAnnotations(); this.parameterTypes = method.getGenericParameterTypes(); this.parameterAnnotationsArray = method.getParameterAnnotations();&#125; methodAnnotations：网络请求接口方法注解 parameterTypes：网络请求接口方法里的参数注解 parameterAnnotationsArray：网络请求接口方法里的注解内容 build1234567891011121314151617181920212223242526272829303132333435public ServiceMethod build() &#123; //1. 从 Retrofit 中获取网络请求器 callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError(&quot;&#x27;&quot; + Utils.getRawType(responseType).getName() + &quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;); &#125; //2. 从 Refrofit 中获取数据转换器 responseConverter = createResponseConverter(); for (Annotation annotation : methodAnnotations) &#123; //3. 解析网络请求接口中方法的注解 parseMethodAnnotation(annotation); &#125; ..... int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, &quot;Parameter type must not include a type variable or wildcard: %s&quot;, parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, &quot;No Retrofit annotation found.&quot;); &#125; //4. 创建ParameterHandler&lt;?&gt;，用来解析来解析参数使用到注解 parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; ...... return new ServiceMethod&lt;&gt;(this);&#125; createCallAdapter：根据接口方法返回类型、接口请求的注解，获取网络请求器 12345678910111213141516171819private CallAdapter&lt;T, R&gt; createCallAdapter() &#123; //获取接口方法的返回类型 Type returnType = method.getGenericReturnType(); if (Utils.hasUnresolvableType(returnType)) &#123; throw methodError( &quot;Method return type must not include a type variable or wildcard: %s&quot;, returnType); &#125; if (returnType == void.class) &#123; throw methodError(&quot;Service methods cannot return void.&quot;); &#125; //获取接口请求的注解 Annotation[] annotations = method.getAnnotations(); try &#123; //noinspection unchecked return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, &quot;Unable to create call adapter for %s&quot;, returnType); &#125;&#125; createResponseConverter：根据接口请求注解类型、返回类型，获取数据数据转换器 12345678910private Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123; //获取接口请求的注解 Annotation[] annotations = method.getAnnotations(); try &#123; //从Rtrofit中获取数据转换器 return retrofit.responseBodyConverter(responseType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, &quot;Unable to create converter for %s&quot;, responseType); &#125;&#125; parseMethodAnnotation：解析请求接口的方法注解，主要有以下标签 Http请求方法 Headers Multipart FormUrlEncoded parseParameter：对方法的参数注解进行解析包含：Url，Path，Query，QueryName，QueryMap，Header，HeaderMap，Field，FieldMap，Part，PartMap，Body 1234567891011121314151617181920private ParameterHandler&lt;?&gt; parseParameter( int p, Type parameterType, Annotation[] annotations) &#123; ParameterHandler&lt;?&gt; result = null; for (Annotation annotation : annotations) &#123; //参数注解解析 ParameterHandler&lt;?&gt; annotationAction = parseParameterAnnotation( p, parameterType, annotations, annotation); if (annotationAction == null) &#123; continue; &#125; if (result != null) &#123; throw parameterError(p, &quot;Multiple Retrofit annotations found, only one allowed.&quot;); &#125; result = annotationAction; &#125; if (result == null) &#123; throw parameterError(p, &quot;No Retrofit annotation found.&quot;); &#125; return result;&#125; OKHttpCall根据serviceMethod和请求参数，创建OkHttpCall对象 12345678910111213141516171819final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod; private final @Nullable Object[] args; private volatile boolean canceled; @GuardedBy(&quot;this&quot;) private @Nullable okhttp3.Call rawCall; @GuardedBy(&quot;this&quot;) // Either a RuntimeException, non-fatal Error, or IOException. private @Nullable Throwable creationFailure; @GuardedBy(&quot;this&quot;) private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; ......&#125; serviceMethod和 args不做介绍了 rawCall：OKHttp，真正发送网络请求 canceled：取消请求标志位 executed：是否执行标志位 creationFailure：异常标志位 adapt根据ServiceMethod的中的callAdapter，来真正执行adapt方法ServiceMethod的adapt方法 123T adapt(Call&lt;R&gt; call) &#123; return callAdapter.adapt(call);&#125; Android 默认的返回 ExecutorCallAdapterFactory的Call这里使用了静态代理delegate，加入一些额外的操作 12345678public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallAdapterFactory.ExecutorCallbackCall(ExecutorCallAdapterFactory.this.callbackExecutor, call);&#125;......ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate;&#125; RxJavaCallAdapterFactory返回的是Observable 1234567891011121314151617181920212223242526272829@Override public Object adapt(Call&lt;R&gt; call) &#123; Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) &#123; observable = new ResultObservable&lt;&gt;(responseObservable); &#125; else if (isBody) &#123; observable = new BodyObservable&lt;&gt;(responseObservable); &#125; else &#123; observable = responseObservable; &#125; if (scheduler != null) &#123; observable = observable.subscribeOn(scheduler); &#125; if (isFlowable) &#123; return observable.toFlowable(BackpressureStrategy.LATEST); &#125; if (isSingle) &#123; return observable.singleOrError(); &#125; if (isMaybe) &#123; return observable.singleElement(); &#125; if (isCompletable) &#123; return observable.ignoreElements(); &#125; return observable;&#125; 经过上面几步操作 Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;yeungeek&quot;)，返回了一个 OKHttpCall 对象。 发送网络请求请求和 OKHttp 一样，分为同步请求和异步请求 同步请求execute 首先会调用ExecutorCallbackCall的execute方法： 123@Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute();&#125; delegate代理实际是 OKHttpCall，最终会调用OKHttpCall的execute方法 12345678910111213141516171819@Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; ...... call = rawCall; if (call == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException | Error e) &#123; throwIfFatal(e); // Do not assign a fatal error to creationFailure. creationFailure = e; throw e; &#125; &#125; &#125; if (canceled) &#123; call.cancel(); &#125; return parseResponse(call.execute());&#125; createRawCall创建真正发送的请求Request对象 123456789101112131415161718192021222324private okhttp3.Call createRawCall() throws IOException &#123; okhttp3.Call call = serviceMethod.toCall(args); if (call == null) &#123; throw new NullPointerException(&quot;Call.Factory returned null.&quot;); &#125; return call;&#125;//调用serviceMethod的 toCall 方法okhttp3.Call toCall(@Nullable Object... args) throws IOException &#123; //Request 的 builder 生成 Reuqest 对象 RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); @SuppressWarnings(&quot;unchecked&quot;) // It is an error to invoke a method with the wrong arg types. ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers; int argumentCount = args != null ? args.length : 0; if (argumentCount != handlers.length) &#123; throw new IllegalArgumentException(&quot;Argument count (&quot; + argumentCount + &quot;) doesn&#x27;t match expected count (&quot; + handlers.length + &quot;)&quot;); &#125; for (int p = 0; p &lt; argumentCount; p++) &#123; handlers[p].apply(requestBuilder, args[p]); &#125; return callFactory.newCall(requestBuilder.build());&#125; parseResponse调用OKHttp的execute发送网络请求，根据网络请求结果再进行结果解析 12345678910111213141516171819202122232425262728293031Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body&#x27;s source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125;&#125; 先对响应码进行处理，再通过serviceMethod.toResponse选择数据转换器，对数据进行解析后，生成Response对象返回 异步请求异步请求的流程和同步请求一样，就是再回调处理会进行线程切换ExecutorCallbackCall的enqueue方法 1234567891011121314151617181920212223242526@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, &quot;callback == null&quot;); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp&#x27;s behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;);&#125; 代理执行加入了线程切换到逻辑，通过callbackExecutor切换到主线程OKHttpCall的enqueue方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, &quot;callback == null&quot;); okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already executed.&quot;); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; throwIfFatal(t); failure = creationFailure = t; &#125; &#125; &#125; if (failure != null) &#123; callback.onFailure(this, failure); return; &#125; if (canceled) &#123; call.cancel(); &#125; call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123; Response&lt;T&gt; response; try &#123; response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; callFailure(e); &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;);&#125; 如果使用到RxJava，在上一节已经提到， adapt会进行适配，RxJava2CallAdapter的adapt方法中有对RxJava转换，具体逻辑实现这边先不展开 123Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Retrofit中的HTTP实现Retrofit真正请求网络，底层使用的是OKHttp，Refrofit主要负责网络请求接口的封装，看下源码中与HTTP相关的注解这些注解都是在接口上的声明，主要是HTTP的请求方法和参数，具体可以参考Android网络编程-HTTP&#x2F;HTTPS，这里也不具体展开了 设计模式应用我们再回顾下这张流程图: 构建者模式这个模式运用的比较多，Retrofit的Builder，ServiceMethod的Builder等设计模式可以参考建造者模式（Bulider模式）详解 工厂模式在Retrofit 初始化，addCallAdapterFactory中的CallAdapter就是用工厂方法模式 12345678910111213141516public interface CallAdapter&lt;R, T&gt; &#123; Type responseType(); T adapt(Call&lt;R&gt; call); abstract class Factory &#123; public abstract @Nullable CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit); protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123; return Utils.getParameterUpperBound(index, type); &#125; protected static Class&lt;?&gt; getRawType(Type type) &#123; return Utils.getRawType(type); &#125; &#125;&#125; 实现Factory中抽象方法get，就会返回不同的 CallAdapter 对象设计模式可以参考工厂方法模式（详解版） 外观模式(门面模式)Retrofit 就是一个典型的外观类，它屏蔽了所有的实现细节，提供给使用者方便的接口，统一调用创建接口实例和网络请求配置的方法设计模式可以参考外观模式（Facade模式）详解 策略模式主要应用CallAdapter类的adapt方法，在 Retrofit addCallAdapterFactory，对应 Factory 生成不同的CallAdapter，adapt就可以调用到不同实现CallAdapter就是一个Strategy，Retrofit 对应上下文(Context)设计模式可以参考策略模式（策略设计模式）详解 适配器模式还是在CallAdapter得到应用，Retrofit可以适配Android，Java8，RxJava,guava等平台， 不同平台有不同的特性，addCallAdapterFactory可以生成不同的平台的CallAdapter，把不同平台的特性，统一在一个接口中设计模式可以参考适配器模式（Adapter模式）详解 代理模式Retrofit实例的create方法，使用了动态代理模式，网络请求接口，都会调用到Proxy.newProxyInstance的 invoke 方法中 12345678910111213141516171819202122232425public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.adapt(okHttpCall); &#125; &#125;);&#125; 除了使用动态代理，Retrofit 还使用了静态代理模式，ExecutorCallbackCall的delegate，在发送请求和接收响应的过程中，增加了一些额外逻辑 @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, &quot;callback == null&quot;); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp&#39;s behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;)); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; 设计模式可以参考代理模式（代理设计模式）详解Retrofit使用了大量的设计模式，上面只是在主流过程使用到的，其他设计模式的应用，大家可以继续深入源码去分析，总之，Refrofit框架是非常值得深入研究的框架 参考 Retrofit官网 Android：手把手带你深入剖析 Retrofit 2.0 源码 拆轮子系列：拆 Retrofit Retrofit分析-漂亮的解耦套路 Retrofit2 源码解析之动态代理 Retrofit分析-经典设计模式案例","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://yeungeek.github.io/tags/Retrofit/"}]},{"title":"Android网络编程-OKHttp源码角度分析Http","slug":"Network-OKHttp","date":"2019-07-17T06:09:07.000Z","updated":"2023-07-31T03:40:56.496Z","comments":true,"path":"2019/07/17/Network-OKHttp/","link":"","permalink":"http://yeungeek.github.io/2019/07/17/Network-OKHttp/","excerpt":"前面介绍了网络的基础知识，这篇主要从OKHttp源码角度来分析Http。OKHttp是一个优秀的网络请求框架，有以下特点： 支持HTTP2&#x2F;SPDY Socket自动选择最好路线，并支持自动重连 拥有自动维护的Socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩） 实现基于Headers的缓存策略","text":"前面介绍了网络的基础知识，这篇主要从OKHttp源码角度来分析Http。OKHttp是一个优秀的网络请求框架，有以下特点： 支持HTTP2&#x2F;SPDY Socket自动选择最好路线，并支持自动重连 拥有自动维护的Socket连接池，减少握手次数 拥有队列线程池，轻松写并发 拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩） 实现基于Headers的缓存策略 基本使用同步请求同步的Get请求 1234567OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(url) .build();Response response = client.newCall(request).execute();return response.body().string(); 异步请求异步的Get请求 1234567891011121314151617OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url(url) .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.e(&quot;DEBUG&quot;, &quot;##### onFailure: &quot;, e); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d(&quot;DEBUG&quot;, &quot;##### response: &quot; + response.body().string()); &#125; &#125;); 源码分析我们从OKHttp的初始化开始分析。 OkHttpClient新建一个OkHttpClient对象 1OkHttpClient client = new OkHttpClient(); 构造函数声明： 123public OkHttpClient() &#123; this(new Builder());&#125; Builder模式构造： 1234567891011121314151617181920212223242526public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); if (proxySelector == null) &#123; proxySelector = new NullProxySelector(); &#125; cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; callTimeout = 0; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0;&#125; 声明了很多属性，具体含义，等后面用到在具体介绍。 请求流程请求流程可分为同步和异步，大体的请求流程如下图所示： 同步请求流程1client.newCall(request).execute(); newCall返回的是RealCall，上面代码实际上执行的是RealCall的execute方法。 1234567891011121314@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; transmitter.timeoutEnter(); transmitter.callStart(); try &#123; client.dispatcher().executed(this); return getResponseWithInterceptorChain(); &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; executed判断Call对象是否已经执行，每个Call对象只能执行一次 client.dispatcher()返回Dispatcher对象，任务核心调度类，是OKHttp中最重要类之一, executed方法把该线程添加到同步线程队列123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; getResponseWithInterceptorChain()获取HTTP请求结果，并会进行一系列拦截操作 client.dispatcher().finished(this)执行完毕操作 123void finished(RealCall call) &#123; finished(runningSyncCalls, call); &#125; 执行完毕后，会把线程从同步线程队列中移除： 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#x27;t in-flight!&quot;); idleCallback = this.idleCallback; &#125; //异步方法中调用 boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 异步请求流程RealCall的enqueue方法： 12345678@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; transmitter.callStart(); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; executed含义和同步请求一样，表示请求只能执行一次 client.dispatcher().enqueue(new AsyncCall(responseCallback));，会生成一个AsyncCall对象，并把它加入到readyAsyncCalls线程队列中，等待执行 AsyncCall是RealCall的内部类，并且是NamedRunnable线程类，具体执行方法： 123456789101112131415161718@Override protected void execute() &#123; boolean signalledCallback = false; transmitter.timeoutEnter(); try &#123; Response response = getResponseWithInterceptorChain(); signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, &quot;Callback failure for &quot; + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; getResponseWithInterceptorChain()获取HTTP请求结果，并会进行一系列拦截操作 client.dispatcher().finished(this);这个方法很重要，和同步方法中调用类似，但是异步的流程则完全不同 finish方法： 1234void finished(AsyncCall call) &#123; call.callsPerHost().decrementAndGet(); finished(runningAsyncCalls, call);&#125; 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(&quot;Call wasn&#x27;t in-flight!&quot;); idleCallback = this.idleCallback; &#125; //异步方法中调用 boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 异步流程中，promoteAndExecute方法： 12345678910111213141516171819202122private boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); asyncCall.callsPerHost().incrementAndGet(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; 会遍历异步等待线程队列，并对正在执行的异步线程队列进行最大请求size，以及每个host最大请求size进行检查。把异步等待线程放到正在执行线程队列中，并在等待线程队列中删除该线程，这样就把等待线程变成正在执行线程。 Dispatcher任务调度核心类，这个类，其实在同步和异步请求流程中已经介绍过，其最重要功能是负责请求的分发。Dispatcher在OKHttpClient的Builder中被初始化： 12345678910111213141516public Builder() &#123; dispatcher = new Dispatcher(); .....&#125;private int maxRequests = 64;private int maxRequestsPerHost = 5;private @Nullable Runnable idleCallback;/** Executes calls. Created lazily. */private @Nullable ExecutorService executorService;/** Ready async calls in the order they&#x27;ll be run. */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** Running asynchronous calls. Includes canceled calls that haven&#x27;t finished yet. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven&#x27;t finished yet. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); maxRequests：最大请求并发请求数64 maxRequestsPerHost：每个主机的最大请求数5 executorService：线程池 readyAsyncCalls：异步等待线程队列 runningAsyncCalls：正在运行的异步线程队列 runningSyncCalls：正在运行的同步线程队列 线程池executorService的声明： 1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); &#125; return executorService;&#125; 核心线程数为0，表示线程在空闲时不会被保留，等待一段时间后停止 最大线程数Integer.MAX_VALUE，基本上就是可以创建线程无上限 keepAliveTime为60s，表示如果线程空闲时，最多只能存活60s 综合上诉，在OKHttp中，设置了不设上限的线程，不保留最小线程，线程空闲时，最大存活时间为60s，保证I&#x2F;O任务中高阻塞低占用的过程，不会长时间卡在阻塞上。并通过maxRequests和maxRequestsPerHost来控制并发最大请求数。 拦截器在同步和异步请求中，具体的执行过程中都会调用到getResponseWithInterceptorChain方法，该方法添加了一系列的拦截器，它在OKHttp整理流程中处于非常重要的地位， 方法实现： 1234567891011121314151617181920212223242526272829303132Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(new RetryAndFollowUpInterceptor(client)); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); boolean calledNoMoreExchanges = false; try &#123; Response response = chain.proceed(originalRequest); if (transmitter.isCanceled()) &#123; closeQuietly(response); throw new IOException(&quot;Canceled&quot;); &#125; return response; &#125; catch (IOException e) &#123; calledNoMoreExchanges = true; throw transmitter.noMoreExchanges(e); &#125; finally &#123; if (!calledNoMoreExchanges) &#123; transmitter.noMoreExchanges(null); &#125; &#125;&#125; 默认添加的拦截器： RetryAndFollowUpInterceptor：负责失败重试以及重定向 BridgeInterceptor：负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应 CacheInterceptor：负责读取缓存直接返回、更新缓存 ConnectInterceptor：负责和服务器建立连接 CallServerInterceptor：负责向服务器发送请求数据、从服务器读取响应数据 这是典型的责任链模式，通过Interceptor，把Request转换为Response，每个Interceptor都有各自的责任和逻辑。 12345interceptors.addAll(client.interceptors());......if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; 开发者可以自己定义Interceptor，在最开始或者发送请求前，对Request和Response进行处理。 HTTP实现OKHttp中实现HTTP主要是在ConnectInterceptor和CallServerInterceptor。ConnectInterceptor建立服务器之间的连接，CallServerInterceptor发送请求和读取响应。OKHttp请求一个URL的流程： 根据请求的URL，createAddress方法会创建一个Address，用于连接服务器 检查address和routes，是否可以从ConnectionPool获取一个连接 如果没有获取到连接，会进行下一个路由选择(routeSelector)，并且重新尝试从ConnectionPool获取一个连接。重试还是获取不到，就会重新创建一个连接(RealConnection) 获取连接后，它会与服务器建立一个直接的Socket连接、使用TLS安全通道（基于HTTP代理的HTTPS），或直接TLS连接 发送HTTP请求，并获取响应 ConnectInterceptor在请求发送前的逻辑，都是ConnectInterceptor中实现，ConnectInterceptor的intercept，这个是3.14.2版本源码，和以前多版本稍微有些区别。 123456789@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); Transmitter transmitter = realChain.transmitter(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks); return realChain.proceed(request, transmitter, exchange);&#125; Exchange可以传输HTTP请求和响应，并管理连接和事件。newExchange方法调用： 12345678910111213141516/** Returns a new exchange to carry a new request and response. */Exchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; synchronized (connectionPool) &#123; if (noMoreExchanges) &#123; throw new IllegalStateException(&quot;released&quot;); &#125; if (exchange != null) &#123; throw new IllegalStateException(&quot;cannot make a new request because the previous response &quot; + &quot;is still open: please call response.close()&quot;); &#125; &#125; ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks); Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec); ...... &#125;&#125; find方法会最终执行ExchangeFinder的findConnection方法，在发送HTTP请求之前的逻辑，都是这个方法中实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. */private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; RealConnection releasedConnection; Socket toClose; synchronized (connectionPool) &#123; if (transmitter.isCanceled()) throw new IOException(&quot;Canceled&quot;); ...... if (result == null) &#123; //2.根据 Address 从连接池获取连接 // Attempt to get a connection from the pool. if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123; foundPooledConnection = true; result = transmitter.connection; &#125; else if (nextRouteToTry != null) &#123; selectedRoute = nextRouteToTry; nextRouteToTry = null; &#125; else if (retryCurrentRoute()) &#123; selectedRoute = transmitter.connection.route(); &#125; &#125; &#125; ...... // 3. 重新选择路由 // If we need a route selection, make one. This is a blocking operation. boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123; newRouteSelection = true; routeSelection = routeSelector.next(); &#125; List&lt;Route&gt; routes = null; synchronized (connectionPool) &#123; if (transmitter.isCanceled()) throw new IOException(&quot;Canceled&quot;); if (newRouteSelection) &#123; // Now that we have a set of IP addresses, make another attempt at getting a connection from // the pool. This could match due to connection coalescing. routes = routeSelection.getAll(); if (connectionPool.transmitterAcquirePooledConnection( address, transmitter, routes, false)) &#123; foundPooledConnection = true; result = transmitter.connection; &#125; &#125; if (!foundPooledConnection) &#123; if (selectedRoute == null) &#123; selectedRoute = routeSelection.next(); &#125; // 3. 重新选择路由，创建新的 `RealConnection` // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we&#x27;re about to do. result = new RealConnection(connectionPool, selectedRoute); connectingConnection = result; &#125; &#125; ...... // 4. 进行 Socket 连接 // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); connectionPool.routeDatabase.connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; connectingConnection = null; // Last attempt at connection coalescing, which only occurs if we attempted multiple // concurrent connections to the same host. if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123; // We lost the race! Close the connection we created and return the pooled connection. result.noNewExchanges = true; socket = result.socket(); result = transmitter.connection; &#125; else &#123; //把连接放入连接池中 connectionPool.put(result); transmitter.acquireConnectionNoEvents(result); &#125; &#125; ...... return result;&#125; HTTP 的连接主要是result.connect方法： 12345678910111213141516171819202122232425public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener)&#123; if (protocol != null) throw new IllegalStateException(&quot;already connected&quot;); ...... while (true) &#123; try &#123; if (route.requiresTunnel()) &#123; connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) &#123; // We were unable to connect the tunnel but properly closed down our resources. break; &#125; &#125; else &#123; connectSocket(connectTimeout, readTimeout, call, eventListener); &#125; establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener); eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol); break; &#125; catch (IOException e) &#123; ...... &#125; &#125; ......&#125; 在 for 循环中检查这个连接是否是隧道协议连接。connectSocket连接socket，establishProtocol根据HTTP协议版本进行连接处理。重点分析下connectSocket方法： 123456789101112131415161718192021private void connectSocket(int connectTimeout, int readTimeout, Call call, EventListener eventListener) throws IOException &#123; ...... try &#123; //连接 socket Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); &#125; catch (ConnectException e) &#123; ConnectException ce = new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress()); ce.initCause(e); throw ce; &#125; try &#123; source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); &#125; catch (NullPointerException npe) &#123; if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123; throw new IOException(npe); &#125; &#125;&#125; 使用 Okio，封装了Socket的读写操作， 建立连接后，就可以发送请求和获取响应。 CallServerInterceptorCallServerInterceptor的intercept()方法里负责发送请求和获取响应。具体操作都是通过Exchange来执行，Exchange通过各个功能模块再进行分发处理。通过 Socket 发送 HTTP消息，会按照以下声明周期： writeRequestHeaders发送 request Headers 如果有 request body，就通过 Sink 发送request body，然后关闭 Sink readResponseHeaders获取 response Headers 通过Source读取 response body，然后关闭 Source writeRequestHeadersExchange 调用writeRequestHeaders方法 1234567891011public void writeRequestHeaders(Request request) throws IOException &#123; try &#123; eventListener.requestHeadersStart(call); codec.writeRequestHeaders(request); eventListener.requestHeadersEnd(call, request); &#125; catch (IOException e) &#123; eventListener.requestFailed(call, e); trackFailure(e); throw e; &#125; &#125; 实际执行的方法codec实现类Http1ExchangeCodec(前面根据HTTP协议版本选择)的writeRequest方法 12345678910111213/** Returns bytes of a request header for sending on an HTTP transport. */public void writeRequest(Headers headers, String requestLine) throws IOException &#123; if (state != STATE_IDLE) throw new IllegalStateException(&quot;state: &quot; + state); sink.writeUtf8(requestLine).writeUtf8(&quot;\\r\\n&quot;); for (int i = 0, size = headers.size(); i &lt; size; i++) &#123; sink.writeUtf8(headers.name(i)) .writeUtf8(&quot;: &quot;) .writeUtf8(headers.value(i)) .writeUtf8(&quot;\\r\\n&quot;); &#125; sink.writeUtf8(&quot;\\r\\n&quot;); state = STATE_OPEN_REQUEST_BODY;&#125; readResponseHeaders读取响应头部，Http1ExchangeCodec的readResponseHeaders方法： 1234567891011121314151617181920212223242526272829@Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException &#123; if (state != STATE_OPEN_REQUEST_BODY &amp;&amp; state != STATE_READ_RESPONSE_HEADERS) &#123; throw new IllegalStateException(&quot;state: &quot; + state); &#125; try &#123; StatusLine statusLine = StatusLine.parse(readHeaderLine()); Response.Builder responseBuilder = new Response.Builder() .protocol(statusLine.protocol) .code(statusLine.code) .message(statusLine.message) .headers(readHeaders()); if (expectContinue &amp;&amp; statusLine.code == HTTP_CONTINUE) &#123; return null; &#125; else if (statusLine.code == HTTP_CONTINUE) &#123; state = STATE_READ_RESPONSE_HEADERS; return responseBuilder; &#125; state = STATE_OPEN_RESPONSE_BODY; return responseBuilder; &#125; catch (EOFException e) &#123; // Provide more context if the server ends the stream before sending a response. String address = &quot;unknown&quot;; if (realConnection != null) &#123; address = realConnection.route().address().url().redact(); &#125; throw new IOException(&quot;unexpected end of stream on &quot; + address, e); &#125;&#125; StatusLine解析HTTP版本信息，readHeaders()读取response header 信息。 123456789/** Reads headers or trailers. */private Headers readHeaders() throws IOException &#123; Headers.Builder headers = new Headers.Builder(); // parse the result headers until the first blank line for (String line; (line = readHeaderLine()).length() != 0; ) &#123; Internal.instance.addLenient(headers, line); &#125; return headers.build();&#125; response body解析 response body 内容： 12345678910if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build();&#125; else &#123; response = response.newBuilder() .body(exchange.openResponseBody(response)) .build();&#125; 如果不是websocket，调用Exchange的openResponseBody方法： 1234567891011121314public ResponseBody openResponseBody(Response response) throws IOException &#123; try &#123; eventListener.responseBodyStart(call); String contentType = response.header(&quot;Content-Type&quot;); long contentLength = codec.reportedContentLength(response); Source rawSource = codec.openResponseBodySource(response); ResponseBodySource source = new ResponseBodySource(rawSource, contentLength); return new RealResponseBody(contentType, contentLength, Okio.buffer(source)); &#125; catch (IOException e) &#123; eventListener.responseFailed(call, e); trackFailure(e); throw e; &#125;&#125; 获取返回的 body，通过 Source 转换为需要的数据类型，ResponseBody提供的 string()，转换为 String 类型 123456public final String string() throws IOException &#123; try (BufferedSource source = source()) &#123; Charset charset = Util.bomAwareCharset(source, charset()); return source.readString(charset); &#125;&#125; 通过上述的分析，OKHttp是通过Okio操作Socket实现了Http协议，凭借高效的性能，Android系统从4.4版本开始，HTTP的实现已经替换为OKHttp。 参考 OKHttp源码解析(一)–初阶 拆轮子系列：拆 OkHttp","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"OKHttp","slug":"OKHttp","permalink":"http://yeungeek.github.io/tags/OKHttp/"}]},{"title":"Android网络编程-Cookie，Session，Token","slug":"Network-Cookie-Session-Token","date":"2019-07-15T15:04:35.000Z","updated":"2023-07-31T03:40:56.496Z","comments":true,"path":"2019/07/15/Network-Cookie-Session-Token/","link":"","permalink":"http://yeungeek.github.io/2019/07/15/Network-Cookie-Session-Token/","excerpt":"HTTP协议是无状态的，每次HTTP请求响应后，就会断开这次连接。如果客户端再次发送请求，服务端也不能识别出这个客户端是不是上次请求过的客户端，HTTP协议不能进行会话跟踪。而Cookie，Session，Token正是为了解决HTTP协议无状态问题。","text":"HTTP协议是无状态的，每次HTTP请求响应后，就会断开这次连接。如果客户端再次发送请求，服务端也不能识别出这个客户端是不是上次请求过的客户端，HTTP协议不能进行会话跟踪。而Cookie，Session，Token正是为了解决HTTP协议无状态问题。 CookieCookie机制是在客户端实现，采用客户端保持状态的方案。Cookie由服务端生成，发送给客户端(Set-Cookie)，客户端请求的时候会带上这个Cookie。请求流程：Cookie字段：名字、值、过期时间、路径和域。路径与域一起构成Cookie的作用范围。通过Chrome的开发者工具中看到，在github.com上保存在客户端的Cookie信息。 Name：名字 Value：值 Domain：域 Path：路径 Expaires&#x2F;Max-Age：过期时间 上图中logged_in和user_session两个Cookie值表示登录github.com后保存下来的登录状态和Session。 SessionSession是在服务端实现，当客户端请求服务端时，服务端会检查请求中是否包含Session标识(Session id)， 如果没有,那么服务端就生成一个随机的Session以及和它匹配的Session id,并将Session id返回给客户端。 如果有,那么服务器就在存储中根据Session id 查找到对应的Session。 TokenToken也称作令牌，由uid+time+sign[+固定参数]组成: uid：用户唯一身份标识 time：当前时间的时间戳 sign：签名, 使用 hash&#x2F;encrypt 压缩成定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器 以下几点特性会让你在程序中使用基于Token的身份验证： 无状态、可扩展 支持移动设备 跨程序调用 安全 Token是有客户端来保存，用户的状态在服务端的内存中是不存储的，所以这是一种无状态的认证机制。而认证的具体流程如下： 客户端使用用户名跟密码请求登录服务端收到请求，去验证用户名与密码验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里客户端每次向服务端请求资源的时候需要带着服务端签发的 Token服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 第三方授权登录这是Token的一种应用场景，使用OAuth实现。OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。我们看下github的授权流程： 图片来源：github 授权登录教程与如何设计第三方授权登录的用户表 区别Cookie和Session 维度 Cookie Sesson 存放位置 客户端 服务端 存取方式 只能保管ASCII字符串 任何类型的数据 安全性 对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容 对客户端是透明的，不存在敏感信息泄露的风险 有效期 可以保持很长时间不过期 依赖于JSESSIONID的Cookie，默许过期时间为–1，只需关闭了浏览器，该Session就会失效 跨域支持 支持跨域名访问 仅在它所在的域名内有效 Token和Session作为身份认证Token安全性比Session好。Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。Token,如果指的是OAuth Token 或类似的机制的话，提供的是认证和授权 ，认证是针对用户，授权是针对App。 参考 Cookie、Session、Token那点事儿 彻底理解cookie，session，token 精读《图解HTTP》","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Session","slug":"Session","permalink":"http://yeungeek.github.io/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yeungeek.github.io/tags/Cookie/"},{"name":"Token","slug":"Token","permalink":"http://yeungeek.github.io/tags/Token/"}]},{"title":"Android网络编程-HTTP/HTTPS","slug":"Network-Http","date":"2019-07-12T02:09:56.000Z","updated":"2023-07-31T03:40:56.496Z","comments":true,"path":"2019/07/12/Network-Http/","link":"","permalink":"http://yeungeek.github.io/2019/07/12/Network-Http/","excerpt":"HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,在TCP&#x2F;IP体系中属于最高层(应用层)是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。","text":"HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,在TCP&#x2F;IP体系中属于最高层(应用层)是用于从万维网服务器传输超文本到本地浏览器的传送协议。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。这是最基本的HTTP工作原理，如图所示: HTTP报文HTTP属于应用层，应用层传输的数据单位是报文。HTTP报文分为请求报文和响应报文。 请求报文HTTP请求报文由以下4个部分组成: 请求行：请求类型,要访问的资源以及所使用的HTTP版本。 请求头部：服务器要使用的附加信息。 空行：请求头部后面的空行是必须的 请求包体：可以添加任意的其他数据 请求行请求行组成：请求方法，请求URL，协议版本。 请求方法 方法 作用 说明 GET 获取资源 用来请求访问已被URI标识的 POST 传输实体主体 POST主要用来传输数据，而GET主要用来获取资源 HEAD 获取报文首部 和GET方法类似，但是不返回报文实体主体部分 PUT 上传文件 用来传输文件，由于自身不带验证机制，任何人都可以上传文件 DELETE 删除文件 与PUT功能相反，并且同样不带验证机制 OPTIONS 查询支持的方法 用来查询针对请求URI请求的资源支持的方法 TRACE 追踪路径 服务器会将通信路径返回给客户端 CONNECT 要求用隧道协议连接代理 使用 SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输 请求URLURL(Uniform Resource Locator)统一资源定位符，表示资源的地点(互联网上的地址)。URI(Uniform Resource Identifier)统一资源标识符，用字符串标识某一互联网资源，URL是URI的子集。 协议版本 HTTP&#x2F;1.0：HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用 HTTP&#x2F;1.1：HTTP协议的第三个版本是HTTP 1.1，是目前使用最广泛的协议版本 HTTP&#x2F;2.0：HTTP 2.0是下一代HTTP协议，目前应用还非常少 请求头部请求头部由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。有4种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段，所有完整首部这里我们先了解下常用的请求首部。 字段 说明 Accept 用户代理可处理的媒体类型 Accept-Encoding 优先的内容编码Accept-Encoding: gzip, deflate, br Authorization Web 认证信息 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Content-Encoding 实体主体适用的编码方式 Content-Type 实体主体的媒体类型 Content-Length 实体主体的大小 Host 请求资源所在服务器 If-Modified-Since 服务器上次返回的Last-Modified日期，如果在这个日期之后，请求的资源都没有更新过，则返回304 Not Modified响应 If-None-Match 比较实体标记，值为上一次返回的ETag，一般会和If-Modified-Since一起返回 Referer 对请求中URI的原始获取方 User-Agent HTTP 客户端程序的信息 Cookie 保存状态信息 Transfer-Encoding 指定报文主体的传输编码方式 请求包体请求包体不在 GET 方法中使用，而是在POST 方法中使用。HTTP请求的请求体有三种不同的形式： 任意类型：服务器不会解析请求体，请求体的处理需要自己解析，比如JSON 键值对(application&#x2F;x-www-form-urlencoded)：最常见的 POST 提交数据的方式，表单模式 文件分割：请求体被分成为多个部分，文件上传时会被使用 示例使用抓包工具或者Chrome来查看 123456789POST /getconfig HTTP/1.1Content-Type: application/x-www-form-urlencodedUser-Agent: Dalvik/2.1.0 (Linux; U; Android 9; Redmi Note 7 MIUI/V10.3.2.0.PFGCNXM)Host: data.mistat.xiaomi.comAccept-Encoding: gzipContent-Length: 205Connection: closeapp_id=1000274&amp;app_version=10.8.3 请求行：显示Post请求，协议版本为HTTP&#x2F;1.1 请求头部：Content-Type,User-Agent,Host,Accept-Encoding,Content-Length,Connection 请求体：Content-Type声明为键值对 响应报文HTTP 响应报文由状态行、响应头部、空行和响应包体4个部分组成。 状态行状态行由HTTP协议版本字段、状态码和状态码的描述文本 3 个部分组成，他们之间使用空格隔开;协议版本和请求中的对应，状态码和描述会一一对应。 状态码、描述状态码由三位数字组成，第一位数字表示响应的类型，常用的状态码有五大类： 1xx：Informational（信息性状态码），接收的请求正在处理; 2xx：Success（成功状态码），请求正常处理完毕; 3xx：Redirection（重定向状态码），需要进行附加操作以完成请求; 4xx：Client Error（客户端错误状态码），服务器无法处理请求; 5xx：Server Error（服务器错误状态码），服务器处理请求出错; 常用的一些状态码和描述 1xx 状态码、描述 说明 100 Continue 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应 2xx 状态码、描述 说明 200 OK 请求成功 204 No Content 请求已经成功处理，但是返回的响应报文不包含实体的主体部分 206 Partial Content 表示客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容 3xx 状态码、描述 说明 301 Moved Permanently 永久性重定向 302 Found 临时性重定向 304 Not Modified 如果请求报文首部包含一些条件，If-Match，If-Range, If-Modified-Since，If-None-Match，，If-Unmodified-Since。如果不满足条件，则服务器会返回 304 状态码 307 Temporary Redirect 临时重定向，与 302 的含义类似，但是307要求浏览器不会把重定向请求的POST方法改成GET方法 4xx 状态码、描述 说明 400 Bad Request 请求报文中存在语法错误 401 Unauthorized 请求需要验证用户 403 Forbidden 访问权限问题 404 Not Found 5xx 状态码、描述 说明 500 Internal Server Error 服务器正在执行请求时发生错误 503 Service Unavailable 服务器正在执行请求时发生错误 响应头部和请求头部一样，由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。常用的请求首部 字段 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Transfer-Encoding 指定报文主体的传输编码方式 Content-Encoding 实体主体适用的编码方式 Content-Type 实体主体的媒体类型 Content-Length 实体主体的大小 Expires 实体主体过期的日期时间 ETag 资源的匹配信息，和If-Nome-Match对应 Date 服务端 Location 令客户端重定向至指定 URI Server HTTP 服务器的安装信息 Last-Modified 资源的最后修改日期时间 Set-Cookie 设置Cookie，客户端得到响应报文后把 Cookie 内容保存到浏览器中 其他更详细的首部信息，可以参考这里 响应包体服务器返回给客户端的文本信息。和请求包体的分类一样。 示例12345678HTTP/1.1 200 OKDate: Sat, 13 Jul 2019 08:40:52 GMTContent-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedContent-Encoding: gzipConnection: close&#123;&quot;errorCode&quot;:-2,&quot;reason&quot;:&quot;no changing&quot;,&quot;result&quot;:null&#125; 响应行：返回响应码200 Ok，表示服务端返回数据成功 响应头部：Content-Type设置返回的类型为JSON格式 响应包体：返回具体JSON数据 HTTPSHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改） 与HTTP区别 协议 原理 数据格式 传输速度 端口 HTTP 应用层 明文传输 三次握手，传输三个包 80 HTTPS 传输层 SSL加密 三次握手基础上增加ssl握手(9个包)，传输12个包 443 缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 HTTP框架VolleyVolley是Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持 HttpClient、HttpUrlConnection，甚至支持OKHttp。 OKHttpOKHttp是Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库，所以它的职责跟 HttpUrlConnection 是一样的，支持 spdy、http 2.0、websocket ，支持同步、异步。已被谷歌加入到Android的源码中。 RetrofitRetrofit是Square公司出品的默认基于OKHttp 封装的一套 RESTful 网络请求框架 后续文章会从OKHttp、Retrofit角度来分析Http。 参考 Http 这是一份全面&amp; 详细 HTTP协议 学习攻略 精读《图解HTTP》 HTTP 协议入门","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"Https","slug":"Https","permalink":"http://yeungeek.github.io/tags/Https/"}]},{"title":"Android网络编程-Socket","slug":"Network-Socket","date":"2019-06-26T12:18:07.000Z","updated":"2023-07-31T03:40:56.497Z","comments":true,"path":"2019/06/26/Network-Socket/","link":"","permalink":"http://yeungeek.github.io/2019/06/26/Network-Socket/","excerpt":"Socket在Android网络编程中，有着非常重要的作用。 Socket基本概念即套接字，是应用层 与 TCP&#x2F;IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP &#x2F; IP协议族 的编程接口（API）。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。","text":"Socket在Android网络编程中，有着非常重要的作用。 Socket基本概念即套接字，是应用层 与 TCP&#x2F;IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP &#x2F; IP协议族 的编程接口（API）。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 借用下网上结构图:IP地址和端口号组成了Socket，都是成对出现。 1Socket =&#123;(IP地址1:PORT端口号)，(IP地址2:PORT端口号)&#125; 单独的Socke是没用任何作用的,基于一定的协议（TCP或者UDP）下的Socket编程才能进行数据传输。 Socket工作流程服务端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。客户端初始化一个socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务端的连接就建立了。客户端发送数据请求，服务端接收请求并处理请求，然后把回应数据发给客户端，客户端读取数据，最后关闭数据，一次交互结束。 分类Socket使用类型有两种： 基于TCP协议，流套接字，采用流的方式提供可靠的字节流服务 基于UDP协议，数据报套接字，采用数据报文提供数据打包发送的服务 基于TCP的Socket编程主要APISocket构造方法12public Socket(String host, int port) throws UnknownHostException, IOException 创建流套接字并将其连接到指定主机上的指定端口号。 host: 主机地址 port: 端口号 getInputStream返回Socket的输入流，用户接受数据。 getOutputStream返回Socket的输出流，用于发送数据。 ServerSocketSocket的服务端实现 构造函数1public ServerSocket(int port) throws IOException 创建服务端Socket，绑定到指定端口。 port: 端口号 accept1public Socket accept() throws IOException 监听并接受到此套接字的连接。该方法将阻塞，直到建立连接。 示例服务端1234567891011121314151617181920212223242526272829public class Server &#123; public static void main(String[] args) throws IOException &#123; //1. 创建ServerSocket ServerSocket serverSocket = new ServerSocket(8888); //2. 监听 Socket socket = serverSocket.accept(); System.out.println(&quot;server start listen&quot;); //3. 输入流 InputStream is = socket.getInputStream(); InputStreamReader reader = new InputStreamReader(is); BufferedReader br = new BufferedReader(reader); String content = null; StringBuffer sb = new StringBuffer(); while ((content = br.readLine()) != null) &#123; sb.append(content); &#125; System.out.println(&quot;server receiver: &quot; + sb.toString()); socket.shutdownInput(); br.close(); reader.close(); is.close(); socket.close(); serverSocket.close(); &#125;&#125; 非常简单的Socket服务端，接收到客户端的数据，就会关闭当前的连接。这个示例只是展示了一个完整的流程。如果需要复杂的服务端实现，可以使用Netty、Mina或者其他Socket框架。 客户端12345678910111213//1. 创建客户端Socket socket = new Socket(&quot;your ip&quot;, 8888);//2. 输出流OutputStream os = socket.getOutputStream();//3. 发送数据os.write(&quot;Hello world&quot;.getBytes());System.out.println(&quot;send message&quot;);os.flush();socket.shutdownOutput();os.close();socket.close(); 客户端就是连接后，发送了一份数据，就关闭连接了。这样就实现了客户端和服务端的通信。 基于UDP的Socket编程主要APIDatagramPacket用来包装接收和发送的数据。 构造接收数据包 1public DatagramPacket(byte[] buf,int length) 用来接收长度为 length 的数据包。 构造发送数据包 12DatagramPacket(byte[] buf, int length,SocketAddress address)DatagramPacket(byte[] buf, int length, InetAddress address, int port) 用来将长度为 length 的包发送到指定主机上的指定端口号。 DatagramSocket用来发送和接收数据报包的套接字。 构造方法12345//创建数据报套接字并将其绑定到本地主机上的指定端口DatagramSocket(int port) //创建数据报套接字，将其绑定到指定的本地地址DatagramSocket(int port, InetAddress laddr) 发送数据1void send(DatagramPacket p) DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号 接收数据1void receive(DatagramPacket p) 当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。 示例服务端1234567891011121314151617181920public class UDPServer &#123; public static void main(String[] args) throws IOException &#123; byte[] buf = new byte[1024]; // receive // 1.create DatagramPacket packet = new DatagramPacket(buf, buf.length); // 2.create udp socket DatagramSocket socket = new DatagramSocket(8888); // 3. receive start socket.receive(packet); // 4. receive data System.out.println(&quot;sever: &quot; + new String(buf, 0, buf.length)); // send DatagramPacket p = new DatagramPacket(buf, buf.length, packet.getAddress(), packet.getPort()); socket.send(p); socket.close(); &#125;&#125; 客户端12345678910111213141516// sendInetAddress address = InetAddress.getByName(&quot;your ip&quot;);//1.create packetDatagramPacket packet = new DatagramPacket(bytes, bytes.length, address, 8888);//2.create socketDatagramSocket socket = new DatagramSocket();//3.send datasocket.send(packet);// receive//1.create packetfinal byte[] bytes = new byte[1024];DatagramPacket receiverPacket = new DatagramPacket(bytes, bytes.length);socket.receive(receiverPacket);System.out.println(&quot;client: &quot; + new String(bytes, 0, bytes.length));socket.close(); 客户端和服务端的实现，都比较简单。 关于Socket编程，就介绍好了，这篇只是开了头，最主要的还是得去项目中实践。 参考 Android：这是一份很详细的Socket使用攻略 Scoket编程","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Socket","slug":"Socket","permalink":"http://yeungeek.github.io/tags/Socket/"}]},{"title":"Android网络编程-TCP/IP协议","slug":"Network-TCP-IP","date":"2019-06-21T03:28:07.000Z","updated":"2023-07-31T03:40:56.497Z","comments":true,"path":"2019/06/21/Network-TCP-IP/","link":"","permalink":"http://yeungeek.github.io/2019/06/21/Network-TCP-IP/","excerpt":"在Android网络编程-计算机网络基础一文中得知，IP协议属于网络层，TCP、UDP协议属于传输层。IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。TCP协议是面向连接的传输层协议，提供一种面向连接的、可靠的字节流服务。UDP协议是面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。","text":"在Android网络编程-计算机网络基础一文中得知，IP协议属于网络层，TCP、UDP协议属于传输层。IP协议是TCP&#x2F;IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。TCP协议是面向连接的传输层协议，提供一种面向连接的、可靠的字节流服务。UDP协议是面向无连接的传输层协议，提供面向事务的简单不可靠信息传输服务。 数据报文在不同层传输的数据单位名称不同，在网络层传输的叫数据报，在传输层传输的叫报文段。 IP数据报IP数据报格式如下图:各个字段的详细说明： 名称 长度 说明 版本 4bit IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6 首部长度 4bit IP报头的长度，最大长度60字节(15*4)，分为固定部分的长度(20字节)和可变部分的长度 服务类型 8bit Type Of Service 总长度 16bit IP报文的总长度。数据报的最大长度为 65535 字节 标识 16bit 它是一个计数器，用来产生数据报的标识。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，此标识表示同一个数据报的分片。 标志 3bit R、DF、MF三位，目前只有后两位有效。DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。 片偏移 13bit 本分片在原先数据报文中相对首位的偏移位。片偏移以8个字节为偏移单位。 生存时间 8bit TTL (Time To Live)表示数据报在网络中的寿命，其单位为秒。在目前的实际应用中，常以“跳”为单位。 协议 8bit 指出IP报文携带的数据使用的哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2. 首部校验和 16bit 计算IP头部的校验和，检查IP报头的完整性。 源地址 32bit 标识IP数据报的源端设备。 目的地址 32bit 标识IP数据报的目的地址。 可选字段 长度可变 1～40 字节，用于增加IP数据报的控制功能。 填充 保证IP首部长度是4字节的整倍数 TCP报文 名称 长度 说明 源端口 16bit 数据发送方的端口号 目的端口 16bit 数据接受方的端口号 序号 32bit 本数据报文中的的第一个字节的序号(在数据流中每个字节都对应一个序号) 确认号 32bit 希望收到的下一个数据报文中的第一个字节的序号 数据偏移 4bit 表示本报文数据段距离报文段有多远 保留字段 6bit 保留为今后使用，但目前应置为0 紧急比特URG 当值为1时表示次报文段中有需要紧急处理 确认比特ACK 值为1时确认号有效，值为0时确认号无效 复位比特RST 值为1时表示TCP连接存在严重的错误，需要重新进行连接 同步比特SYN 值为1表示这是一个连接请求或连接接受报文 终止比特FIN 值为1表示要发送的数据报已经发送完毕，需要释放传送连接 窗口 16bit TCP连接的一端根据缓存空间的大小来确定自己接受窗口的大小限制发送放的窗口上限 检验和 16bit 用来检验首部和数据两部分的正确性 紧急指针字段 16bit 紧急指针指出在本报文段中的紧急数据的最后一个字节的序号 选项字段 长度可变 TCP 首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项 UDP报文相对于TCP报文，UDP报文简单了很多。 名称 长度 说明 源端口 16bit 数据发送方的端口号 目的端口 16bit 数据接受方的端口号 包长度 16bit UDP首部的长度和数据的长度之和。单位为字节 校验和 16bit 用来检验首部和数据两部分的正确性 TCP三次握手和四次挥手TCP用三次握手来创建连接，使用四次分手来释放连接。 三次握手三次握手的目的是同步连接双方的序列号和确认号并交换TCP窗口大小的信息。握手过程： 第一次握手：建立连接，客户端先发送连接请求报文，将SYN设置为1，Sequence Number为x。客户端进入SYN+SEND状态，等待服务器确认。 第二次握手：服务器收到SYN报文。服务器收到客户端的SYN报文，需要对这个SYN报文进行确认，设置Acknowledgment Number为x+1(Sequence+1)；同时，自己还要送法SYN消息，将SYN位置为1，Sequence Number为y；服务器将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN+RECV状态。 第三次握手：客户端收到服务器的 SYN+ACK报文段。然后将Acknowlegment Number设为y+1,向服务器发送ACK报文段，这个报文段发送完毕后，客户端端服务器都进入ESTABLISHED状态，完成TCP三次握手。 完成了三次握手，客户端和服务器就可以开始传送数据了。 四次挥手当客户端和服务端传输数据完毕后，需要断开TCP连接。TCP断开的过程，就是四次挥手。 第一次挥手：客户端(也可以是服务器)，设置Sequence Number和Acknowledgment Number，向服务器发送一个FIN报文段。此时客户端进入FIN_WAIT_1状态；这表示客户端没有数据发送给主机了。 第二次挥手：服务器收到客户端发来的FIN报文段，向客户端回一个ACK报文段，Acknowledgement Number为Sequence Number加1；客户端进入FIN_WAIT_2状态，服务器进入CLOSE_WAIT状态；服务器告诉客户端，我同意你的”关闭”请求。 第三次挥手：服务器向客户端发送FIN报文段，请求关闭连接，同时服务器进入LAST_ACK状态。 第四次挥手：客户端收到服务器发送的FIN报文段，向主机发送ACK报文段，然后客户端进入TIME_WAIT状态，服务器收到客户端的ACK报文段以后，就关闭连接，此时，客户端等待2MSL后一次没有到收到回复，则证明服务端已正常关闭，那好，客户端也可以关闭连接了。 TCP三次握手的必要性防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源。 TCP四次挥手的必要性为了保证通信双方都能通知对方，需释放、断开连接。 为什么客户端关闭连接前要等待2MSL时间 MSL: 最大报文段生存时间 四个报文发送完毕后，就可以直接进入CLOSE状态了，但是有可能网络是不可靠的，一切都可能发生，比如有可能最后一个ACK丢失。所以TIME_WAIT状态是用来重发可能丢失的ACK报文。展开具体来讲： 为了保证客户端发送的最后1个连接释放确认报文 能到达服务器，从而使得服务器能正常释放连接。 防止早已失效的连接请求报文，出现在本连接中。客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。 TCP、UDP比较 TCP UDP 可靠性 可靠 不可靠 连接性 面向连接 无连接 报文 面向字节流 面向报文 效率 低效 高效 双工性 全双工 一对一，一对多，多对一，多对多支持多播和广播 流量控制 滑动窗口机制 拥塞控制 慢开始&#x2F;拥塞避免快重传&#x2F;快恢复 传输速度 慢 快 应用场景 效率要求相对低，准确要求相对高。要求有连接的场景 效率要求相对高，准确要求相对低 应用 SMTP，TELNET，HTTP，FTP DNS，RIP，NFS，SNMP，IP电话，流媒体 参考 计算机网络：这是一份全面 &amp; 详细 的TCP协议攻略 《图解TCP&#x2F;IP》读书笔记 Android网络编程：基础理论汇总","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"TCP","slug":"TCP","permalink":"http://yeungeek.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"http://yeungeek.github.io/tags/UDP/"},{"name":"IP","slug":"IP","permalink":"http://yeungeek.github.io/tags/IP/"}]},{"title":"Android网络编程-计算机网络基础","slug":"Network-Basic","date":"2019-06-14T14:58:01.000Z","updated":"2023-07-31T03:40:56.496Z","comments":true,"path":"2019/06/14/Network-Basic/","link":"","permalink":"http://yeungeek.github.io/2019/06/14/Network-Basic/","excerpt":"从本篇开始，真正进入我们的Android网络编程学习之旅。 概念计算机网络是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统。","text":"从本篇开始，真正进入我们的Android网络编程学习之旅。 概念计算机网络是利用通信设备和线路将地理位置不同的、功能独立的多个计算机系统连接起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。简单的说即连接两台或多台计算机进行通信的系统。 计算机网络体系结构 计算机网络体系结构可以定义为是网络协议的层次划分与各层协议的集合，同一层中的协议根据该层所要实现的功能来确定。各对等层之间的协议功能由相应的底层提供服务完成。—— 百度百科 分层对于复杂的计算机网络协议，结构分层很有必要。就像Android开发中，把应用分层各个模块。 优缺点优点： 各层之间相互独立。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间接口（即界面）所提供的服务 灵活性好。当任何一层发送变化时（例如由于技术的变化），只要层间接口关系保持不变，则在这层以上或以下各层均不受影响 结构上可分割开。各层都可以采用最合适的技术来实现 易于实现和维护。 这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统 能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明 缺点：各层之间会有相同的功能出现，产生额外开销。 体系结构目前有3种体系结构: OSI参考模型，概念清楚，理论也较完整，但它既复杂又不实用 TCP&#x2F;IP体系结构，是一系列网络协议的总称，目前应用最广泛 五层体系结构，综合OSI和TCP&#x2F;IP的优点,既简洁又能将概念阐述清楚 OSI参考模型 分层 功能 数据单位 协议栈 物理层 屏蔽传输媒体和通信手段的差异 比特(bit) 数据链路层 互连设备之间传送和识别数据帧 帧(frame) 点对点协议以太网协议 高级数据链路协议帧中继 网络层 地址管理和路由选择 数据报(datagram) IP协议路由选择协议 传输层 管理两个节点之间的数据传输 负责可靠传输（确保数据被可靠地传送到目标地址） 报文段(segment) TCP协议UDP协议 会话层 通信管理。负责建立和断开通信连接（数据流动的逻辑通路） 提供了数据交换定界和同步功能 管理传输层一下的分层 表示层 数据压缩、加密以及数据描述 应用层 针对特定应用的协议 报文(message) HTTPDNSFTPSMTPSSH TCP&#x2F;IPTCP&#x2F;IP的体系结构比较简单，只有四层。它并不是遵循严格的 OSI 分层概念，应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。可以演化成如下图所示: 五层协议OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。TCP&#x2F;IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP&#x2F;IP 是一个四层的体系结构。在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP&#x2F;IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。 五层协议中各层的主要功能五层协议中，没有表示层和会话层，这两层的功能留给开发者来处理。 物理层在物理层，定义了以下内容： 接口特性 机械特性：规定了接口的几何形状等 电器特性：规定了接口使用的电平大小等 功能特性：规定了接口引脚个数及各项功能等 规程特性：定义了接口在工作过程中遵循的相应过程。 比特编码：用比特对信息按照一定规则进行编码，用于传输 数据率：即数据传输速率 比特同步：时钟同步 通讯方式: 单工通信：单向传输 半双工通信：双向交替传输 双工通信：双向同时传输 数据链路层功能： 负责结点-结点数据传输 组桢：将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 物理寻址：在桢头添加发送端或接收端的物理地址标识数据帧的发送端或接收端。 流量控制：匹配发送端与接收端的发送速度与接收速度，避免数据淹没接收端。 差错控制：检测并重传损坏或丢失帧，并避免重复帧。 访问（接入）控制：在任一给定时刻决定哪个设备拥有链路（物理介质）的控制使用权。 网络层功能: 负责源主机到目的主机数据分组（packet）的交付（可能穿越多个网络）。 逻辑寻址：全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址（穿越多个网络时，链路层的物理寻址并不能用）。 路由：路由器（或网关）互连网络，并路由分组至最终目的主机，进行路径选择。 分组转发 传输层传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节。功能: 负责源-目的（端-端）（进程间）完整报文传输 报文分段与重组 SAP寻址：确保将完整报文提交给正确进程，如端口号 连接控制：负责端-端的连接控制（建立连接、拆除连接），是一种逻辑连接 流量控制：控制端-端传输的速度 差错控制：差错检测与纠正 应用层应用层直接为用户的应用进程提供服务 主要协议IP协议规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。IP的主要作用就是在复杂的网络环境中将数据包发给最终的目标地址。相关技术： DNS：域名系统，一种分布式的网络目录服务，主要用于域名与IP地址的要互转换。 ARP：ARP是一种解决地址问题的协议，以目标地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。不过，ARP只适用于IPv4，不适用于IPv6。 ICMP：Internet控制报文协议，作用是报告一些网络传输过程中的错误与做一些同步工作。 DHCP：动态主机配置协议，实现自动设置IP地址、统一管理IP地址分配。 NAT：网络地址转换，作用是将IP数据报头中的IP地址转换为另一个IP地址。 IP隧道：是一种数据包封装技术，它是将原始IP包（其报头包含原始发送者和最终目的地）封装在另一个数据包（称为封装的IP包）的数据净荷中进行传输。 TCP协议传输控制协议(Transmission Control Protocol)，面向连接的、可靠的流协议，提供可靠的通信传输。 UDP协议用户数据报协议(User Datagram Protocol)，面向无连接的，具有不可靠性的数据报协议。 路由协议Routing protocol，是一种指定数据包转送方式的网上协议。 Socket即套接字，是应用层 与 TCP&#x2F;IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP &#x2F; IP协议族 的编程接口（API）。 HTTP协议超文本传输协议(Hyper Text Transfer Protocol)，用于从万维网服务器传输超文本到本地浏览器的传送协议。 系列文章目录 参考 趣谈网络协议 互联网协议入门（一） 《图解TCP&#x2F;IP》读书笔记 计算机网络 面试带你飞：这是一份全面的 计算机网络基础 总结攻略 计算机网络的体系结构 计算机网络体系结构","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"}]},{"title":"Android网络编程-系列文章","slug":"Network-Series","date":"2019-06-13T15:34:10.000Z","updated":"2023-07-31T03:40:56.496Z","comments":true,"path":"2019/06/13/Network-Series/","link":"","permalink":"http://yeungeek.github.io/2019/06/13/Network-Series/","excerpt":"在Android开发过程中，网络编程是必不可少的。大家接触的Volley,Retrofit,OKHttp等网络框架，很好地封装了底层实现的细节，在使用过程中非常的方便。但是掌握其中的细节，对我们来说真的非常重要，只有掌握了网络编程的原理，才能真正理解这些网络框架的源码实现。","text":"在Android开发过程中，网络编程是必不可少的。大家接触的Volley,Retrofit,OKHttp等网络框架，很好地封装了底层实现的细节，在使用过程中非常的方便。但是掌握其中的细节，对我们来说真的非常重要，只有掌握了网络编程的原理，才能真正理解这些网络框架的源码实现。 本系列会介绍计算机网络的基础、TCP&#x2F;UDP、Http协议、Socket等，并从源码角度分析Retrofit、OKHttp，它们是如何实现Http的。 千里之行，始于足下。不管何时，我相信，扎实的功底和过硬的技术，都会是你职业发展的助力器。 —- 极客时间《趣谈网络协议》刘超 系列文章目录 01.Android网络编程-计算机网络基础 02.Android网络编程-TCP&#x2F;IP协议 03.Android网络编程-Socket 04.Android网络编程-HTTP&#x2F;HTTPS 05.Android网络编程-Cookie，Session，Token 06.Android网络编程-OKHttp源码角度分析Http 07.Android网络编程-Retrofit源码角度分析Http 参考 Android网络编程：基础理论汇总 计算机网络 面试带你飞：这是一份全面的 计算机网络基础 总结攻略 Android网络编程系列","categories":[{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"OKHttp","slug":"OKHttp","permalink":"http://yeungeek.github.io/tags/OKHttp/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://yeungeek.github.io/tags/Retrofit/"}]}],"categories":[{"name":"Android框架层","slug":"Android框架层","permalink":"http://yeungeek.github.io/categories/Android%E6%A1%86%E6%9E%B6%E5%B1%82/"},{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/categories/Camera/"},{"name":"Android应用层","slug":"Android应用层","permalink":"http://yeungeek.github.io/categories/Android%E5%BA%94%E7%94%A8%E5%B1%82/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yeungeek.github.io/tags/Android/"},{"name":"Camera2","slug":"Camera2","permalink":"http://yeungeek.github.io/tags/Camera2/"},{"name":"CameraX","slug":"CameraX","permalink":"http://yeungeek.github.io/tags/CameraX/"},{"name":"Camera","slug":"Camera","permalink":"http://yeungeek.github.io/tags/Camera/"},{"name":"SurfaceView","slug":"SurfaceView","permalink":"http://yeungeek.github.io/tags/SurfaceView/"},{"name":"TextureView","slug":"TextureView","permalink":"http://yeungeek.github.io/tags/TextureView/"},{"name":"CameraView","slug":"CameraView","permalink":"http://yeungeek.github.io/tags/CameraView/"},{"name":"Orientation","slug":"Orientation","permalink":"http://yeungeek.github.io/tags/Orientation/"},{"name":"JNI","slug":"JNI","permalink":"http://yeungeek.github.io/tags/JNI/"},{"name":"NDK","slug":"NDK","permalink":"http://yeungeek.github.io/tags/NDK/"},{"name":"Network","slug":"Network","permalink":"http://yeungeek.github.io/tags/Network/"},{"name":"Http","slug":"Http","permalink":"http://yeungeek.github.io/tags/Http/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://yeungeek.github.io/tags/Retrofit/"},{"name":"OKHttp","slug":"OKHttp","permalink":"http://yeungeek.github.io/tags/OKHttp/"},{"name":"Session","slug":"Session","permalink":"http://yeungeek.github.io/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yeungeek.github.io/tags/Cookie/"},{"name":"Token","slug":"Token","permalink":"http://yeungeek.github.io/tags/Token/"},{"name":"Https","slug":"Https","permalink":"http://yeungeek.github.io/tags/Https/"},{"name":"Socket","slug":"Socket","permalink":"http://yeungeek.github.io/tags/Socket/"},{"name":"TCP","slug":"TCP","permalink":"http://yeungeek.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"http://yeungeek.github.io/tags/UDP/"},{"name":"IP","slug":"IP","permalink":"http://yeungeek.github.io/tags/IP/"}]}